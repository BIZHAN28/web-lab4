{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph and JSXCompressor.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n    JSXCompressor is free software dual licensed under the GNU LGPL or Apache License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n      OR\n      * Apache License Version 2.0\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License, Apache\n    License, and the MIT License along with JSXGraph. If not, see\n    <https://www.gnu.org/licenses/>, <https://www.apache.org/licenses/LICENSE-2.0.html>,\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\n/**\n * @fileoverview Utilities for uncompressing and base64 decoding\n */\n\nimport JXG from \"../jxg\";\n\n// Zip routine constants\n\nvar bitReverse = [0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff],\n  cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],\n  cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99] /* 99==invalid */,\n  cpdist = [0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001],\n  cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],\n  border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n  NAMEMAX = 256;\n\n// Util namespace\nJXG.Util = JXG.Util || {};\n\n/**\n * @class Unzip class\n * Class for gunzipping, unzipping and base64 decoding of files.\n * It is used for reading GEONExT, Geogebra and Intergeo files.\n *\n * Only Huffman codes are decoded in gunzip.\n * The code is based on the source code for gunzip.c by Pasi Ojala\n * @see http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c\n * @see http://www.cs.tut.fi/~albert\n */\nJXG.Util.Unzip = function (barray) {\n  var gpflags,\n    // SIZE,\n    fileout,\n    flens,\n    fmax,\n    outputArr = [],\n    files = 0,\n    unzipped = [],\n    buf32k = new Array(32768),\n    bIdx = 0,\n    modeZIP = false,\n    barraylen = barray.length,\n    bytepos = 0,\n    bb = 1,\n    // bits = 0,\n    literalTree = new Array(288),\n    distanceTree = new Array(32),\n    treepos = 0,\n    Places = null,\n    // crc,\n    // output = \"\",\n    // debug = false,\n    // bitpos = 0,\n    // Places2 = null,\n    // impDistanceTree = new Array(64),\n    // impLengthTree = new Array(64),\n    len = 0,\n    fpos = new Array(17),\n    nameBuf = [];\n  fpos[0] = 0;\n  function readByte() {\n    // bits += 8;\n\n    if (bytepos < barraylen) {\n      return barray[bytepos++];\n    }\n    return -1;\n  }\n  function byteAlign() {\n    bb = 1;\n  }\n  function readBit() {\n    var carry;\n\n    // Prevent problems on iOS7 with >>\n    try {\n      // bits++;\n      carry = bb & 1;\n      bb >>= 1;\n      if (bb === 0) {\n        bb = readByte();\n        carry = bb & 1;\n        bb = bb >> 1 | 0x80;\n      }\n    } catch (e) {\n      console.log(\"Probably problems on iOS7 with >>\");\n      throw e;\n    }\n    return carry;\n  }\n  function readBits(a) {\n    var res = 0,\n      i = a;\n\n    // Prevent problems on iOS7 with >>\n    try {\n      while (i--) {\n        res = res << 1 | readBit();\n      }\n      if (a) {\n        res = bitReverse[res] >> 8 - a;\n      }\n    } catch (e) {\n      console.log(\"Probably problems on iOS7 with >>\");\n      throw e;\n    }\n    return res;\n  }\n  function flushBuffer() {\n    bIdx = 0;\n  }\n  function addBuffer(a) {\n    // SIZE++;\n    buf32k[bIdx++] = a;\n    outputArr.push(String.fromCharCode(a));\n    if (bIdx === 0x8000) {\n      bIdx = 0;\n    }\n  }\n  function HufNode() {\n    this.b0 = 0;\n    this.b1 = 0;\n    this.jump = null;\n    this.jumppos = -1;\n  }\n  function isPat() {\n    var endless = true;\n    while (endless) {\n      if (fpos[len] >= fmax) {\n        return -1;\n      }\n      if (flens[fpos[len]] === len) {\n        return fpos[len]++;\n      }\n      fpos[len]++;\n    }\n  }\n  function rec() {\n    var curplace = Places[treepos],\n      tmp;\n    if (len === 17) {\n      return -1;\n    }\n    treepos++;\n    len++;\n    tmp = isPat();\n    if (tmp >= 0) {\n      /* leaf cell for 0-bit */\n      curplace.b0 = tmp;\n    } else {\n      /* Not a Leaf cell */\n      curplace.b0 = 0x8000;\n      if (rec()) {\n        return -1;\n      }\n    }\n    tmp = isPat();\n    if (tmp >= 0) {\n      /* leaf cell for 1-bit */\n      curplace.b1 = tmp;\n      /* Just for the display routine */\n      curplace.jump = null;\n    } else {\n      /* Not a Leaf cell */\n      curplace.b1 = 0x8000;\n      curplace.jump = Places[treepos];\n      curplace.jumppos = treepos;\n      if (rec()) {\n        return -1;\n      }\n    }\n    len--;\n    return 0;\n  }\n  function createTree(currentTree, numval, lengths, show) {\n    var i;\n    Places = currentTree;\n    treepos = 0;\n    flens = lengths;\n    fmax = numval;\n    for (i = 0; i < 17; i++) {\n      fpos[i] = 0;\n    }\n    len = 0;\n    if (rec()) {\n      return -1;\n    }\n    return 0;\n  }\n  function decodeValue(currentTree) {\n    var len,\n      i,\n      b,\n      endless = true,\n      xtreepos = 0,\n      X = currentTree[xtreepos];\n\n    /* decode one symbol of the data */\n    while (endless) {\n      b = readBit();\n      if (b) {\n        if (!(X.b1 & 0x8000)) {\n          /* If leaf node, return data */\n          return X.b1;\n        }\n        X = X.jump;\n        len = currentTree.length;\n        for (i = 0; i < len; i++) {\n          if (currentTree[i] === X) {\n            xtreepos = i;\n            break;\n          }\n        }\n      } else {\n        if (!(X.b0 & 0x8000)) {\n          /* If leaf node, return data */\n          return X.b0;\n        }\n        xtreepos++;\n        X = currentTree[xtreepos];\n      }\n    }\n  }\n  function deflateLoop() {\n    var last,\n      c,\n      type,\n      i,\n      j,\n      l,\n      ll,\n      ll2,\n      len,\n      blockLen,\n      dist,\n      cSum,\n      n,\n      // z,\n      literalCodes,\n      distCodes,\n      lenCodes,\n      endless = true;\n    do {\n      last = readBit();\n      type = readBits(2);\n      if (type === 0) {\n        // Stored\n        byteAlign();\n        blockLen = readByte();\n        blockLen |= readByte() << 8;\n        cSum = readByte();\n        cSum |= readByte() << 8;\n        if ((blockLen ^ ~cSum) & 0xffff) {\n          JXG.debug(\"BlockLen checksum mismatch\\n\");\n        }\n        while (blockLen--) {\n          c = readByte();\n          addBuffer(c);\n        }\n      } else if (type === 1) {\n        /* Fixed Huffman tables -- fixed decode routine */\n        while (endless) {\n          /*\n               256    0000000        0\n               :   :     :\n               279    0010111        23\n               0   00110000    48\n               :    :      :\n               143    10111111    191\n               280 11000000    192\n               :    :      :\n               287 11000111    199\n               144    110010000    400\n               :    :       :\n               255    111111111    511\n                Note the bit order!\n               */\n\n          j = bitReverse[readBits(7)] >> 1;\n          if (j > 23) {\n            j = j << 1 | readBit(); /* 48..255 */\n\n            if (j > 199) {\n              /* 200..255 */\n              j -= 128; /*  72..127 */\n              j = j << 1 | readBit(); /* 144..255 << */\n            } else {\n              /*  48..199 */\n              j -= 48; /*   0..151 */\n              if (j > 143) {\n                j = j + 136; /* 280..287 << */\n                /*   0..143 << */\n              }\n            }\n          } else {\n            /*   0..23 */\n            j += 256; /* 256..279 << */\n          }\n          if (j < 256) {\n            addBuffer(j);\n          } else if (j === 256) {\n            /* EOF */\n            break;\n          } else {\n            j -= 256 + 1; /* bytes + EOF */\n            len = readBits(cplext[j]) + cplens[j];\n            j = bitReverse[readBits(5)] >> 3;\n            if (cpdext[j] > 8) {\n              dist = readBits(8);\n              dist |= readBits(cpdext[j] - 8) << 8;\n            } else {\n              dist = readBits(cpdext[j]);\n            }\n            dist += cpdist[j];\n            for (j = 0; j < len; j++) {\n              c = buf32k[bIdx - dist & 0x7fff];\n              addBuffer(c);\n            }\n          }\n        } // while\n      } else if (type === 2) {\n        // \"static\" just to preserve stack\n        ll = new Array(288 + 32);\n\n        // Dynamic Huffman tables\n        literalCodes = 257 + readBits(5);\n        distCodes = 1 + readBits(5);\n        lenCodes = 4 + readBits(4);\n        for (j = 0; j < 19; j++) {\n          ll[j] = 0;\n        }\n\n        // Get the decode tree code lengths\n\n        for (j = 0; j < lenCodes; j++) {\n          ll[border[j]] = readBits(3);\n        }\n        len = distanceTree.length;\n        for (i = 0; i < len; i++) {\n          distanceTree[i] = new HufNode();\n        }\n        if (createTree(distanceTree, 19, ll, 0)) {\n          flushBuffer();\n          return 1;\n        }\n\n        //read in literal and distance code lengths\n        n = literalCodes + distCodes;\n        i = 0;\n        // z = -1;\n\n        while (i < n) {\n          // z++;\n          j = decodeValue(distanceTree);\n\n          // length of code in bits (0..15)\n          if (j < 16) {\n            ll[i++] = j;\n            // repeat last length 3 to 6 times\n          } else if (j === 16) {\n            j = 3 + readBits(2);\n            if (i + j > n) {\n              flushBuffer();\n              return 1;\n            }\n            l = i ? ll[i - 1] : 0;\n            while (j--) {\n              ll[i++] = l;\n            }\n          } else {\n            // 3 to 10 zero length codes\n            if (j === 17) {\n              j = 3 + readBits(3);\n              // j == 18: 11 to 138 zero length codes\n            } else {\n              j = 11 + readBits(7);\n            }\n            if (i + j > n) {\n              flushBuffer();\n              return 1;\n            }\n            while (j--) {\n              ll[i++] = 0;\n            }\n          }\n        }\n\n        // Can overwrite tree decode tree as it is not used anymore\n        len = literalTree.length;\n        for (i = 0; i < len; i++) {\n          literalTree[i] = new HufNode();\n        }\n        if (createTree(literalTree, literalCodes, ll, 0)) {\n          flushBuffer();\n          return 1;\n        }\n        len = literalTree.length;\n        for (i = 0; i < len; i++) {\n          distanceTree[i] = new HufNode();\n        }\n        ll2 = [];\n        for (i = literalCodes; i < ll.length; i++) {\n          ll2[i - literalCodes] = ll[i];\n        }\n        if (createTree(distanceTree, distCodes, ll2, 0)) {\n          flushBuffer();\n          return 1;\n        }\n        while (endless) {\n          j = decodeValue(literalTree);\n\n          // In C64: if carry set\n          if (j >= 256) {\n            j -= 256;\n            if (j === 0) {\n              // EOF\n              break;\n            }\n            j -= 1;\n            len = readBits(cplext[j]) + cplens[j];\n            j = decodeValue(distanceTree);\n            if (cpdext[j] > 8) {\n              dist = readBits(8);\n              dist |= readBits(cpdext[j] - 8) << 8;\n            } else {\n              dist = readBits(cpdext[j]);\n            }\n            dist += cpdist[j];\n            while (len--) {\n              c = buf32k[bIdx - dist & 0x7fff];\n              addBuffer(c);\n            }\n          } else {\n            addBuffer(j);\n          }\n        }\n      }\n    } while (!last);\n    flushBuffer();\n    byteAlign();\n    return 0;\n  }\n\n  /**\n   * nextFile:\n   * Extract the next file from the compressed archive.\n   * Calls skipdir() to proceed recursively.\n   *\n   * @return {Boolean}  false if the end of files' data section has baseElement\n   * reached. Then, then all recursive functions are stopped immediately.\n   *\n   */\n  function nextFile() {\n    /* eslint-disable no-unused-vars */\n    var i,\n      c,\n      extralen,\n      filelen,\n      size,\n      compSize,\n      crc,\n      method,\n      tmp = [];\n\n    // Prevent problems on iOS7 with >>\n    try {\n      outputArr = [];\n      modeZIP = false;\n      tmp[0] = readByte();\n      tmp[1] = readByte();\n\n      //GZIP\n      if (tmp[0] === 0x78 && tmp[1] === 0xda) {\n        deflateLoop();\n        unzipped[files] = [outputArr.join(\"\"), \"geonext.gxt\"];\n        files++;\n      }\n\n      //GZIP\n      if (tmp[0] === 0x1f && tmp[1] === 0x8b) {\n        skipdir();\n        unzipped[files] = [outputArr.join(\"\"), \"file\"];\n        files++;\n      }\n\n      //ZIP\n      if (tmp[0] === 0x50 && tmp[1] === 0x4b) {\n        modeZIP = true;\n        tmp[2] = readByte();\n        tmp[3] = readByte();\n        if (tmp[2] === 0x03 && tmp[3] === 0x04) {\n          //MODE_ZIP\n          tmp[0] = readByte();\n          tmp[1] = readByte();\n          gpflags = readByte();\n          gpflags |= readByte() << 8;\n          method = readByte();\n          method |= readByte() << 8;\n          readByte();\n          readByte();\n          readByte();\n          readByte();\n          crc = readByte();\n          crc |= readByte() << 8;\n          crc |= readByte() << 16;\n          crc |= readByte() << 24;\n          compSize = readByte();\n          compSize |= readByte() << 8;\n          compSize |= readByte() << 16;\n          compSize |= readByte() << 24;\n          size = readByte();\n          size |= readByte() << 8;\n          size |= readByte() << 16;\n          size |= readByte() << 24;\n          filelen = readByte();\n          filelen |= readByte() << 8;\n          extralen = readByte();\n          extralen |= readByte() << 8;\n          i = 0;\n          nameBuf = [];\n          while (filelen--) {\n            c = readByte();\n            if (c === \"/\" | c === \":\") {\n              i = 0;\n            } else if (i < NAMEMAX - 1) {\n              nameBuf[i++] = String.fromCharCode(c);\n            }\n          }\n          if (!fileout) {\n            fileout = nameBuf;\n          }\n          i = 0;\n          while (i < extralen) {\n            c = readByte();\n            i++;\n          }\n\n          // SIZE = 0;\n          if (method === 8) {\n            deflateLoop();\n            unzipped[files] = new Array(2);\n            unzipped[files][0] = outputArr.join(\"\");\n            unzipped[files][1] = nameBuf.join(\"\");\n            files++;\n          }\n          if (skipdir()) {\n            // We are beyond the files' data in the zip archive.\n            // Let's get out immediately...\n            return false;\n          }\n        }\n        return true;\n      }\n    } catch (e) {\n      console.log(\"Probably problems on iOS7 with >>\");\n      throw e;\n    }\n    return false;\n    /* eslint-enable no-unused-vars */\n  }\n\n  /**\n   * Test if the end of the files' data part of the archive has baseElement\n   * reached. If not, uncompressing is resumed.\n   *\n   * @return {Boolean}  true if the end of the files' data sections have\n   * been reached.\n   *\n   * @private\n   */\n  function skipdir() {\n    /* eslint-disable no-unused-vars */\n    var crc,\n      compSize,\n      size,\n      os,\n      i,\n      c,\n      tmp = [];\n    if (gpflags & 8) {\n      tmp[0] = readByte();\n      tmp[1] = readByte();\n      tmp[2] = readByte();\n      tmp[3] = readByte();\n\n      // signature for data descriptor record: 0x08074b50\n      // 12 bytes:\n      //  crc 4 bytes\n      //  compressed size 4 bytes\n      // uncompressed size 4 bytes\n      if (tmp[0] === 0x50 && tmp[1] === 0x4b && tmp[2] === 0x07 && tmp[3] === 0x08) {\n        crc = readByte();\n        crc |= readByte() << 8;\n        crc |= readByte() << 16;\n        crc |= readByte() << 24;\n      } else {\n        crc = tmp[0] | tmp[1] << 8 | tmp[2] << 16 | tmp[3] << 24;\n      }\n      compSize = readByte();\n      compSize |= readByte() << 8;\n      compSize |= readByte() << 16;\n      compSize |= readByte() << 24;\n      size = readByte();\n      size |= readByte() << 8;\n      size |= readByte() << 16;\n      size |= readByte() << 24;\n    }\n    if (modeZIP) {\n      if (nextFile()) {\n        // A file has been decompressed, we have to proceed\n        return false;\n      }\n    }\n    tmp[0] = readByte();\n    if (tmp[0] !== 8) {\n      // It seems, we are beyond the files' data in the zip archive.\n      // We'll skip the rest..\n      return true;\n    }\n\n    // There is another file in the zip file. We proceed...\n    gpflags = readByte();\n    readByte();\n    readByte();\n    readByte();\n    readByte();\n    readByte();\n    os = readByte();\n    if (gpflags & 4) {\n      tmp[0] = readByte();\n      tmp[2] = readByte();\n      len = tmp[0] + 256 * tmp[1];\n      for (i = 0; i < len; i++) {\n        readByte();\n      }\n    }\n    if (gpflags & 8) {\n      i = 0;\n      nameBuf = [];\n      c = readByte();\n      while (c) {\n        if (c === \"7\" || c === \":\") {\n          i = 0;\n        }\n        if (i < NAMEMAX - 1) {\n          nameBuf[i++] = c;\n        }\n        c = readByte();\n      }\n    }\n    if (gpflags & 16) {\n      c = readByte();\n      while (c) {\n        c = readByte();\n      }\n    }\n    if (gpflags & 2) {\n      readByte();\n      readByte();\n    }\n    deflateLoop();\n    crc = readByte();\n    crc |= readByte() << 8;\n    crc |= readByte() << 16;\n    crc |= readByte() << 24;\n    size = readByte();\n    size |= readByte() << 8;\n    size |= readByte() << 16;\n    size |= readByte() << 24;\n    if (modeZIP) {\n      if (nextFile()) {\n        // A file has been decompressed, we have to proceed\n        return false;\n      }\n    }\n\n    // We are here in non-ZIP-files only,\n    // In that case the eturn value doesn't matter\n    return false;\n    /* eslint-enable no-unused-vars */\n  }\n  JXG.Util.Unzip.prototype.unzipFile = function (name) {\n    var i;\n    this.unzip();\n    for (i = 0; i < unzipped.length; i++) {\n      if (unzipped[i][1] === name) {\n        return unzipped[i][0];\n      }\n    }\n    return \"\";\n  };\n  JXG.Util.Unzip.prototype.unzip = function () {\n    nextFile();\n    return unzipped;\n  };\n};\nexport default JXG.Util;","map":{"version":3,"names":["JXG","bitReverse","cplens","cplext","cpdist","cpdext","border","NAMEMAX","Util","Unzip","barray","gpflags","fileout","flens","fmax","outputArr","files","unzipped","buf32k","Array","bIdx","modeZIP","barraylen","length","bytepos","bb","literalTree","distanceTree","treepos","Places","len","fpos","nameBuf","readByte","byteAlign","readBit","carry","e","console","log","readBits","a","res","i","flushBuffer","addBuffer","push","String","fromCharCode","HufNode","b0","b1","jump","jumppos","isPat","endless","rec","curplace","tmp","createTree","currentTree","numval","lengths","show","decodeValue","b","xtreepos","X","deflateLoop","last","c","type","j","l","ll","ll2","blockLen","dist","cSum","n","literalCodes","distCodes","lenCodes","debug","nextFile","extralen","filelen","size","compSize","crc","method","join","skipdir","os","prototype","unzipFile","name","unzip"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/utils/zip.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph and JSXCompressor.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n    JSXCompressor is free software dual licensed under the GNU LGPL or Apache License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n      OR\n      * Apache License Version 2.0\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License, Apache\n    License, and the MIT License along with JSXGraph. If not, see\n    <https://www.gnu.org/licenses/>, <https://www.apache.org/licenses/LICENSE-2.0.html>,\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\n/**\n * @fileoverview Utilities for uncompressing and base64 decoding\n */\n\nimport JXG from \"../jxg\";\n\n// Zip routine constants\n\nvar bitReverse = [\n        0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0,\n        0x70, 0xf0, 0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8,\n        0x38, 0xb8, 0x78, 0xf8, 0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94,\n        0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,\n        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2,\n        0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0x0a, 0x8a, 0x4a, 0xca,\n        0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x06, 0x86,\n        0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\n        0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe,\n        0x7e, 0xfe, 0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1,\n        0x31, 0xb1, 0x71, 0xf1, 0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99,\n        0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,\n        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad,\n        0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x03, 0x83, 0x43, 0xc3,\n        0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0x0b, 0x8b,\n        0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\n        0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7,\n        0x77, 0xf7, 0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf,\n        0x3f, 0xbf, 0x7f, 0xff\n    ],\n    cplens = [\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99,\n        115, 131, 163, 195, 227, 258, 0, 0\n    ],\n    cplext = [\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,\n        99, 99\n    ] /* 99==invalid */,\n    cpdist = [\n        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011, 0x0019, 0x0021,\n        0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601,\n        0x0801, 0x0c01, 0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001\n    ],\n    cpdext = [\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12,\n        12, 13, 13\n    ],\n    border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    NAMEMAX = 256;\n\n// Util namespace\nJXG.Util = JXG.Util || {};\n\n/**\n * @class Unzip class\n * Class for gunzipping, unzipping and base64 decoding of files.\n * It is used for reading GEONExT, Geogebra and Intergeo files.\n *\n * Only Huffman codes are decoded in gunzip.\n * The code is based on the source code for gunzip.c by Pasi Ojala\n * @see http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c\n * @see http://www.cs.tut.fi/~albert\n */\nJXG.Util.Unzip = function (barray) {\n    var gpflags,\n        // SIZE,\n        fileout,\n        flens,\n        fmax,\n        outputArr = [],\n        files = 0,\n        unzipped = [],\n        buf32k = new Array(32768),\n        bIdx = 0,\n        modeZIP = false,\n        barraylen = barray.length,\n        bytepos = 0,\n        bb = 1,\n        // bits = 0,\n        literalTree = new Array(288),\n        distanceTree = new Array(32),\n        treepos = 0,\n        Places = null,\n        // crc,\n        // output = \"\",\n        // debug = false,\n        // bitpos = 0,\n        // Places2 = null,\n        // impDistanceTree = new Array(64),\n        // impLengthTree = new Array(64),\n        len = 0,\n        fpos = new Array(17),\n        nameBuf = [];\n\n    fpos[0] = 0;\n\n    function readByte() {\n        // bits += 8;\n\n        if (bytepos < barraylen) {\n            return barray[bytepos++];\n        }\n\n        return -1;\n    }\n\n    function byteAlign() {\n        bb = 1;\n    }\n\n    function readBit() {\n        var carry;\n\n        // Prevent problems on iOS7 with >>\n        try {\n            // bits++;\n            carry = bb & 1;\n            bb >>= 1;\n\n            if (bb === 0) {\n                bb = readByte();\n                carry = bb & 1;\n                bb = (bb >> 1) | 0x80;\n            }\n        } catch (e) {\n            console.log(\"Probably problems on iOS7 with >>\");\n            throw e;\n        }\n\n        return carry;\n    }\n\n    function readBits(a) {\n        var res = 0,\n            i = a;\n\n        // Prevent problems on iOS7 with >>\n        try {\n            while (i--) {\n                res = (res << 1) | readBit();\n            }\n\n            if (a) {\n                res = bitReverse[res] >> (8 - a);\n            }\n        } catch (e) {\n            console.log(\"Probably problems on iOS7 with >>\");\n            throw e;\n        }\n        return res;\n    }\n\n    function flushBuffer() {\n        bIdx = 0;\n    }\n\n    function addBuffer(a) {\n        // SIZE++;\n        buf32k[bIdx++] = a;\n        outputArr.push(String.fromCharCode(a));\n\n        if (bIdx === 0x8000) {\n            bIdx = 0;\n        }\n    }\n\n    function HufNode() {\n        this.b0 = 0;\n        this.b1 = 0;\n        this.jump = null;\n        this.jumppos = -1;\n    }\n\n    function isPat() {\n        var endless = true;\n        while (endless) {\n            if (fpos[len] >= fmax) {\n                return -1;\n            }\n\n            if (flens[fpos[len]] === len) {\n                return fpos[len]++;\n            }\n\n            fpos[len]++;\n        }\n    }\n\n    function rec() {\n        var curplace = Places[treepos],\n            tmp;\n\n        if (len === 17) {\n            return -1;\n        }\n        treepos++;\n        len++;\n\n        tmp = isPat();\n\n        if (tmp >= 0) {\n            /* leaf cell for 0-bit */\n            curplace.b0 = tmp;\n        } else {\n            /* Not a Leaf cell */\n            curplace.b0 = 0x8000;\n\n            if (rec()) {\n                return -1;\n            }\n        }\n\n        tmp = isPat();\n\n        if (tmp >= 0) {\n            /* leaf cell for 1-bit */\n            curplace.b1 = tmp;\n            /* Just for the display routine */\n            curplace.jump = null;\n        } else {\n            /* Not a Leaf cell */\n            curplace.b1 = 0x8000;\n            curplace.jump = Places[treepos];\n            curplace.jumppos = treepos;\n            if (rec()) {\n                return -1;\n            }\n        }\n        len--;\n\n        return 0;\n    }\n\n    function createTree(currentTree, numval, lengths, show) {\n        var i;\n\n        Places = currentTree;\n        treepos = 0;\n        flens = lengths;\n        fmax = numval;\n\n        for (i = 0; i < 17; i++) {\n            fpos[i] = 0;\n        }\n        len = 0;\n\n        if (rec()) {\n            return -1;\n        }\n\n        return 0;\n    }\n\n    function decodeValue(currentTree) {\n        var len,\n            i, b,\n            endless = true,\n            xtreepos = 0,\n            X = currentTree[xtreepos];\n\n        /* decode one symbol of the data */\n        while (endless) {\n            b = readBit();\n\n            if (b) {\n                if (!(X.b1 & 0x8000)) {\n                    /* If leaf node, return data */\n                    return X.b1;\n                }\n\n                X = X.jump;\n                len = currentTree.length;\n\n                for (i = 0; i < len; i++) {\n                    if (currentTree[i] === X) {\n                        xtreepos = i;\n                        break;\n                    }\n                }\n            } else {\n                if (!(X.b0 & 0x8000)) {\n                    /* If leaf node, return data */\n                    return X.b0;\n                }\n                xtreepos++;\n                X = currentTree[xtreepos];\n            }\n        }\n    }\n\n    function deflateLoop() {\n        var last, c, type, i, j, l, ll, ll2,\n            len, blockLen, dist, cSum, n,// z,\n            literalCodes, distCodes, lenCodes,\n            endless = true;\n\n        do {\n            last = readBit();\n            type = readBits(2);\n\n            if (type === 0) {\n                // Stored\n                byteAlign();\n                blockLen = readByte();\n                blockLen |= readByte() << 8;\n\n                cSum = readByte();\n                cSum |= readByte() << 8;\n\n                if ((blockLen ^ ~cSum) & 0xffff) {\n                    JXG.debug(\"BlockLen checksum mismatch\\n\");\n                }\n\n                while (blockLen--) {\n                    c = readByte();\n                    addBuffer(c);\n                }\n            } else if (type === 1) {\n                /* Fixed Huffman tables -- fixed decode routine */\n                while (endless) {\n                    /*\n                         256    0000000        0\n                         :   :     :\n                         279    0010111        23\n                         0   00110000    48\n                         :    :      :\n                         143    10111111    191\n                         280 11000000    192\n                         :    :      :\n                         287 11000111    199\n                         144    110010000    400\n                         :    :       :\n                         255    111111111    511\n\n                         Note the bit order!\n                         */\n\n                    j = bitReverse[readBits(7)] >> 1;\n\n                    if (j > 23) {\n                        j = (j << 1) | readBit(); /* 48..255 */\n\n                        if (j > 199) {\n                            /* 200..255 */\n                            j -= 128; /*  72..127 */\n                            j = (j << 1) | readBit(); /* 144..255 << */\n                        } else {\n                            /*  48..199 */\n                            j -= 48; /*   0..151 */\n                            if (j > 143) {\n                                j = j + 136; /* 280..287 << */\n                                /*   0..143 << */\n                            }\n                        }\n                    } else {\n                        /*   0..23 */\n                        j += 256; /* 256..279 << */\n                    }\n\n                    if (j < 256) {\n                        addBuffer(j);\n                    } else if (j === 256) {\n                        /* EOF */\n                        break;\n                    } else {\n                        j -= 256 + 1; /* bytes + EOF */\n                        len = readBits(cplext[j]) + cplens[j];\n                        j = bitReverse[readBits(5)] >> 3;\n\n                        if (cpdext[j] > 8) {\n                            dist = readBits(8);\n                            dist |= readBits(cpdext[j] - 8) << 8;\n                        } else {\n                            dist = readBits(cpdext[j]);\n                        }\n\n                        dist += cpdist[j];\n\n                        for (j = 0; j < len; j++) {\n                            c = buf32k[(bIdx - dist) & 0x7fff];\n                            addBuffer(c);\n                        }\n                    }\n                } // while\n            } else if (type === 2) {\n                // \"static\" just to preserve stack\n                ll = new Array(288 + 32);\n\n                // Dynamic Huffman tables\n                literalCodes = 257 + readBits(5);\n                distCodes = 1 + readBits(5);\n                lenCodes = 4 + readBits(4);\n\n                for (j = 0; j < 19; j++) {\n                    ll[j] = 0;\n                }\n\n                // Get the decode tree code lengths\n\n                for (j = 0; j < lenCodes; j++) {\n                    ll[border[j]] = readBits(3);\n                }\n                len = distanceTree.length;\n\n                for (i = 0; i < len; i++) {\n                    distanceTree[i] = new HufNode();\n                }\n\n                if (createTree(distanceTree, 19, ll, 0)) {\n                    flushBuffer();\n                    return 1;\n                }\n\n                //read in literal and distance code lengths\n                n = literalCodes + distCodes;\n                i = 0;\n                // z = -1;\n\n                while (i < n) {\n                    // z++;\n                    j = decodeValue(distanceTree);\n\n                    // length of code in bits (0..15)\n                    if (j < 16) {\n                        ll[i++] = j;\n                        // repeat last length 3 to 6 times\n                    } else if (j === 16) {\n                        j = 3 + readBits(2);\n\n                        if (i + j > n) {\n                            flushBuffer();\n                            return 1;\n                        }\n                        l = i ? ll[i - 1] : 0;\n\n                        while (j--) {\n                            ll[i++] = l;\n                        }\n                    } else {\n                        // 3 to 10 zero length codes\n                        if (j === 17) {\n                            j = 3 + readBits(3);\n                            // j == 18: 11 to 138 zero length codes\n                        } else {\n                            j = 11 + readBits(7);\n                        }\n\n                        if (i + j > n) {\n                            flushBuffer();\n                            return 1;\n                        }\n\n                        while (j--) {\n                            ll[i++] = 0;\n                        }\n                    }\n                }\n\n                // Can overwrite tree decode tree as it is not used anymore\n                len = literalTree.length;\n                for (i = 0; i < len; i++) {\n                    literalTree[i] = new HufNode();\n                }\n\n                if (createTree(literalTree, literalCodes, ll, 0)) {\n                    flushBuffer();\n                    return 1;\n                }\n\n                len = literalTree.length;\n\n                for (i = 0; i < len; i++) {\n                    distanceTree[i] = new HufNode();\n                }\n\n                ll2 = [];\n\n                for (i = literalCodes; i < ll.length; i++) {\n                    ll2[i - literalCodes] = ll[i];\n                }\n\n                if (createTree(distanceTree, distCodes, ll2, 0)) {\n                    flushBuffer();\n                    return 1;\n                }\n\n                while (endless) {\n                    j = decodeValue(literalTree);\n\n                    // In C64: if carry set\n                    if (j >= 256) {\n                        j -= 256;\n                        if (j === 0) {\n                            // EOF\n                            break;\n                        }\n\n                        j -= 1;\n                        len = readBits(cplext[j]) + cplens[j];\n                        j = decodeValue(distanceTree);\n\n                        if (cpdext[j] > 8) {\n                            dist = readBits(8);\n                            dist |= readBits(cpdext[j] - 8) << 8;\n                        } else {\n                            dist = readBits(cpdext[j]);\n                        }\n\n                        dist += cpdist[j];\n\n                        while (len--) {\n                            c = buf32k[(bIdx - dist) & 0x7fff];\n                            addBuffer(c);\n                        }\n                    } else {\n                        addBuffer(j);\n                    }\n                }\n            }\n        } while (!last);\n\n        flushBuffer();\n        byteAlign();\n\n        return 0;\n    }\n\n    /**\n     * nextFile:\n     * Extract the next file from the compressed archive.\n     * Calls skipdir() to proceed recursively.\n     *\n     * @return {Boolean}  false if the end of files' data section has baseElement\n     * reached. Then, then all recursive functions are stopped immediately.\n     *\n     */\n    function nextFile() {\n        /* eslint-disable no-unused-vars */\n        var i,\n            c,\n            extralen,\n            filelen,\n            size,\n            compSize,\n            crc,\n            method,\n            tmp = [];\n\n        // Prevent problems on iOS7 with >>\n        try {\n            outputArr = [];\n            modeZIP = false;\n            tmp[0] = readByte();\n            tmp[1] = readByte();\n\n            //GZIP\n            if (tmp[0] === 0x78 && tmp[1] === 0xda) {\n                deflateLoop();\n                unzipped[files] = [outputArr.join(\"\"), \"geonext.gxt\"];\n                files++;\n            }\n\n            //GZIP\n            if (tmp[0] === 0x1f && tmp[1] === 0x8b) {\n                skipdir();\n                unzipped[files] = [outputArr.join(\"\"), \"file\"];\n                files++;\n            }\n\n            //ZIP\n            if (tmp[0] === 0x50 && tmp[1] === 0x4b) {\n                modeZIP = true;\n                tmp[2] = readByte();\n                tmp[3] = readByte();\n\n                if (tmp[2] === 0x03 && tmp[3] === 0x04) {\n                    //MODE_ZIP\n                    tmp[0] = readByte();\n                    tmp[1] = readByte();\n\n                    gpflags = readByte();\n                    gpflags |= readByte() << 8;\n\n                    method = readByte();\n                    method |= readByte() << 8;\n\n                    readByte();\n                    readByte();\n                    readByte();\n                    readByte();\n\n                    crc = readByte();\n                    crc |= readByte() << 8;\n                    crc |= readByte() << 16;\n                    crc |= readByte() << 24;\n\n                    compSize = readByte();\n                    compSize |= readByte() << 8;\n                    compSize |= readByte() << 16;\n                    compSize |= readByte() << 24;\n\n                    size = readByte();\n                    size |= readByte() << 8;\n                    size |= readByte() << 16;\n                    size |= readByte() << 24;\n\n                    filelen = readByte();\n                    filelen |= readByte() << 8;\n\n                    extralen = readByte();\n                    extralen |= readByte() << 8;\n\n                    i = 0;\n                    nameBuf = [];\n\n                    while (filelen--) {\n                        c = readByte();\n                        if ((c === \"/\") | (c === \":\")) {\n                            i = 0;\n                        } else if (i < NAMEMAX - 1) {\n                            nameBuf[i++] = String.fromCharCode(c);\n                        }\n                    }\n\n                    if (!fileout) {\n                        fileout = nameBuf;\n                    }\n\n                    i = 0;\n                    while (i < extralen) {\n                        c = readByte();\n                        i++;\n                    }\n\n                    // SIZE = 0;\n                    if (method === 8) {\n                        deflateLoop();\n                        unzipped[files] = new Array(2);\n                        unzipped[files][0] = outputArr.join(\"\");\n                        unzipped[files][1] = nameBuf.join(\"\");\n                        files++;\n                    }\n\n                    if (skipdir()) {\n                        // We are beyond the files' data in the zip archive.\n                        // Let's get out immediately...\n                        return false;\n                    }\n                }\n                return true;\n            }\n        } catch (e) {\n            console.log(\"Probably problems on iOS7 with >>\");\n            throw e;\n        }\n        return false;\n        /* eslint-enable no-unused-vars */\n    }\n\n    /**\n     * Test if the end of the files' data part of the archive has baseElement\n     * reached. If not, uncompressing is resumed.\n     *\n     * @return {Boolean}  true if the end of the files' data sections have\n     * been reached.\n     *\n     * @private\n     */\n    function skipdir() {\n        /* eslint-disable no-unused-vars */\n        var crc, compSize, size, os, i, c,\n            tmp = [];\n\n        if (gpflags & 8) {\n            tmp[0] = readByte();\n            tmp[1] = readByte();\n            tmp[2] = readByte();\n            tmp[3] = readByte();\n\n            // signature for data descriptor record: 0x08074b50\n            // 12 bytes:\n            //  crc 4 bytes\n            //  compressed size 4 bytes\n            // uncompressed size 4 bytes\n            if (tmp[0] === 0x50 && tmp[1] === 0x4b && tmp[2] === 0x07 && tmp[3] === 0x08) {\n                crc = readByte();\n                crc |= readByte() << 8;\n                crc |= readByte() << 16;\n                crc |= readByte() << 24;\n            } else {\n                crc = tmp[0] | (tmp[1] << 8) | (tmp[2] << 16) | (tmp[3] << 24);\n            }\n\n            compSize = readByte();\n            compSize |= readByte() << 8;\n            compSize |= readByte() << 16;\n            compSize |= readByte() << 24;\n\n            size = readByte();\n            size |= readByte() << 8;\n            size |= readByte() << 16;\n            size |= readByte() << 24;\n        }\n\n        if (modeZIP) {\n            if (nextFile()) {\n                // A file has been decompressed, we have to proceed\n                return false;\n            }\n        }\n\n        tmp[0] = readByte();\n        if (tmp[0] !== 8) {\n            // It seems, we are beyond the files' data in the zip archive.\n            // We'll skip the rest..\n            return true;\n        }\n\n        // There is another file in the zip file. We proceed...\n        gpflags = readByte();\n\n        readByte();\n        readByte();\n        readByte();\n        readByte();\n\n        readByte();\n        os = readByte();\n\n        if (gpflags & 4) {\n            tmp[0] = readByte();\n            tmp[2] = readByte();\n            len = tmp[0] + 256 * tmp[1];\n            for (i = 0; i < len; i++) {\n                readByte();\n            }\n        }\n\n        if (gpflags & 8) {\n            i = 0;\n            nameBuf = [];\n\n            c = readByte();\n            while (c) {\n                if (c === \"7\" || c === \":\") {\n                    i = 0;\n                }\n\n                if (i < NAMEMAX - 1) {\n                    nameBuf[i++] = c;\n                }\n\n                c = readByte();\n            }\n        }\n\n        if (gpflags & 16) {\n            c = readByte();\n            while (c) {\n                c = readByte();\n            }\n        }\n\n        if (gpflags & 2) {\n            readByte();\n            readByte();\n        }\n\n        deflateLoop();\n\n        crc = readByte();\n        crc |= readByte() << 8;\n        crc |= readByte() << 16;\n        crc |= readByte() << 24;\n\n        size = readByte();\n        size |= readByte() << 8;\n        size |= readByte() << 16;\n        size |= readByte() << 24;\n\n        if (modeZIP) {\n            if (nextFile()) {\n                // A file has been decompressed, we have to proceed\n                return false;\n            }\n        }\n\n        // We are here in non-ZIP-files only,\n        // In that case the eturn value doesn't matter\n        return false;\n        /* eslint-enable no-unused-vars */\n\n    }\n\n    JXG.Util.Unzip.prototype.unzipFile = function (name) {\n        var i;\n\n        this.unzip();\n\n        for (i = 0; i < unzipped.length; i++) {\n            if (unzipped[i][1] === name) {\n                return unzipped[i][0];\n            }\n        }\n\n        return \"\";\n    };\n\n    JXG.Util.Unzip.prototype.unzip = function () {\n        nextFile();\n        return unzipped;\n    };\n};\n\nexport default JXG.Util;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,OAAOA,GAAG,MAAM,QAAQ;;AAExB;;AAEA,IAAIC,UAAU,GAAG,CACT,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAClF,IAAI,EAAE,IAAI,EAAE,IAAI,EA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}