{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n\"use strict\";\n\nimport Type from \"../utils/type\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Numerics from \"./numerics\";\nimport Quadtree from \"./bqdt\";\n\n/**\n * Plotting of curves which are given implicitly as the set of points solving an equation\n * <i>f(x,y) = 0</i>.\n * <p>\n * The main class initializes a new implicit plot instance.\n * <p>\n * The algorithm should be able to plot most implicit curves as long as the equations\n * are not too complex. We are aware of the paper by Oliver Labs,\n * <a href=\"https://link.springer.com/chapter/10.1007/978-1-4419-0999-2_6\">A List of Challenges for Real Algebraic Plane Curve Visualization Software</a>\n * which contains many equations where this algorithm may fail.\n * For example,  at the time being there is no attempt to detect <i>solitary points</i>.\n * Also, it is always a trade off to find all components of the curve and\n * keep the construction responsive.\n *\n * @name JXG.Math.ImplicitPlot\n * @exports Mat.ImplicitPlot as JXG.Math.ImplicitPlot\n * @param {Array} bbox Bounding box of the area in which solutions of the equation\n * are determined.\n * @param {Object} config Configuration object. Default:\n * <pre>\n *  {\n *      resolution_out: 5,    // Horizontal resolution: distance between vertical lines to search for components\n *      resolution_in: 5,     // Vertical resolution to search for components\n *      max_steps: 1024,      // Max number of points in one call of tracing\n *      alpha_0: 0.05,        // Angle between two successive tangents: smoothness of curve\n *\n *      tol_u0: Mat.eps,      // Tolerance to find starting points for tracing.\n *      tol_newton: 1.0e-7,   // Tolerance for Newton steps.\n *      tol_cusp: 0.05,       // Tolerance for cusp / bifurcation detection\n *      tol_progress: 0.0001, // If two points are closer than this value, we bail out\n *      qdt_box: 0.2,         // half of box size to search in qdt\n *      kappa_0: 0.2,         // Inverse of planned number of Newton steps\n *      delta_0: 0.05,        // Distance of predictor point to curve\n *\n *      h_initial: 0.1,       // Initial stepwidth\n *      h_critical: 0.001,    // If h is below this threshold we bail out\n *      h_max: 1,             // Maximal value of h (user units)\n *      loop_dist: 0.09,      // Allowed distance (multiplied by actual stepwidth) to detect loop\n *      loop_dir: 0.99,       // Should be > 0.95\n *      loop_detection: true, // Use Gosper's loop detector\n *      unitX: 10,            // unitX of board\n *      unitY: 10             // unitX of board\n *   };\n * </pre>\n * @param {function} f function from <b>R</b><sup>2</sup> to <b>R</b>\n * @param {function} [dfx] Optional partial derivative of <i>f</i> with regard to <i>x</i>\n * @param {function} [dfy] Optional partial derivative of <i>f</i> with regard to <i>y</i>\n *\n * @constructor\n * @example\n *     var f = (x, y) => x**3 - 2 * x * y + y**3;\n *     var c = board.create('curve', [[], []], {\n *             strokeWidth: 3,\n *             strokeColor: JXG.palette.red\n *         });\n *\n *     c.updateDataArray = function () {\n *         var bbox = this.board.getBoundingBox(),\n *             ip, cfg,\n *             ret = [],\n *             mgn = 1;\n *\n *         bbox[0] -= mgn;\n *         bbox[1] += mgn;\n *         bbox[2] += mgn;\n *         bbox[3] -= mgn;\n *\n *         cfg = {\n *             resolution_out: 5,\n *             resolution_in: 5,\n *             unitX: this.board.unitX,\n *             unitY: this.board.unitX\n *         };\n *\n *         this.dataX = [];\n *         this.dataY = [];\n *         ip = new JXG.Math.ImplicitPlot(bbox, cfg, f, null, null);\n *         ret = ip.plot();\n *         this.dataX = ret[0];\n *         this.dataY = ret[1];\n *     };\n *     board.update();\n * </pre><div id=\"JXGf3e8cd82-2b67-4efb-900a-471eb92b3b96\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGf3e8cd82-2b67-4efb-900a-471eb92b3b96',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var f = (x, y) => x**3 - 2 * x * y + y**3;\n *             var c = board.create('curve', [[], []], {\n *                     strokeWidth: 3,\n *                     strokeColor: JXG.palette.red\n *                 });\n *\n *             c.updateDataArray = function () {\n *                 var bbox = this.board.getBoundingBox(),\n *                     ip, cfg,\n *                     ret = [],\n *                     mgn = 1;\n *\n *                 bbox[0] -= mgn;\n *                 bbox[1] += mgn;\n *                 bbox[2] += mgn;\n *                 bbox[3] -= mgn;\n *\n *                 cfg = {\n *                     resolution_out: 5,\n *                     resolution_in: 5,\n *                     unitX: this.board.unitX,\n *                     unitY: this.board.unitX\n *                 };\n *\n *                 this.dataX = [];\n *                 this.dataY = [];\n *\n *                 ip = new JXG.Math.ImplicitPlot(bbox, cfg, f, null, null);\n *                 ret = ip.plot();\n *\n *                 this.dataX = ret[0];\n *                 this.dataY = ret[1];\n *             };\n *             board.update();\n *\n *     })();\n *\n * </script><pre>\n *\n */\nMat.ImplicitPlot = function (bbox, config, f, dfx, dfy) {\n  // Default values\n  var cfg_default = {\n    resolution_out: 5,\n    // Distance between vertical lines to search for components\n    resolution_in: 5,\n    // Distance between vertical lines to search for components\n    max_steps: 1024,\n    // Max number of points in one call of tracing\n    alpha_0: 0.05,\n    // Angle between two successive tangents: smoothness of curve\n\n    tol_u0: Mat.eps,\n    // Tolerance to find starting points for tracing.\n    tol_newton: 1.0e-7,\n    // Tolerance for Newton steps.\n    tol_cusp: 0.05,\n    // Tolerance for cusp / bifurcation detection\n    tol_progress: 0.0001,\n    // If two points are closer than this value, we bail out\n    qdt_box: 0.2,\n    // half of box size to search in qdt\n    kappa_0: 0.2,\n    // Inverse of planned number of Newton steps\n    delta_0: 0.05,\n    // Distance of predictor point to curve\n\n    h_initial: 0.1,\n    // Initial step width\n    h_critical: 0.001,\n    // If h is below this threshold we bail out\n    h_max: 1,\n    // Maximum value of h (user units)\n    loop_dist: 0.09,\n    // Allowed distance (multiplied by actual step width) to detect loop\n    loop_dir: 0.99,\n    // Should be > 0.95\n    loop_detection: true,\n    // Use Gosper's loop detector\n    unitX: 10,\n    // unitX of board\n    unitY: 10 // unitX of board\n  };\n  this.config = Type.merge(cfg_default, config);\n  this.f = f;\n  this.dfx = null;\n  this.dfy = null;\n  if (Type.isFunction(dfx)) {\n    this.dfx = dfx;\n  } else {\n    this.dfx = function (x, y) {\n      var h = Mat.eps * Mat.eps;\n      return (this.f(x + h, y) - this.f(x - h, y)) * 0.5 / h;\n    };\n  }\n  if (Type.isFunction(dfy)) {\n    this.dfy = dfy;\n  } else {\n    this.dfy = function (x, y) {\n      var h = Mat.eps * Mat.eps;\n      return (this.f(x, y + h) - this.f(x, y - h)) * 0.5 / h;\n    };\n  }\n  this.bbox = bbox;\n  this.qdt = new Quadtree(20, 5, bbox);\n  this.components = [];\n};\nType.extend(Mat.ImplicitPlot.prototype, /** @lends JXG.Math.ImplicitPlot.prototype */{\n  /**\n   * Implicit plotting method.\n   *\n   * @returns {Array} consisting of [dataX, dataY, number_of_components]\n   */\n  plot: function () {\n    var\n      // components = [],\n      doVerticalSearch = true,\n      doHorizontalSearch = true,\n      x,\n      y,\n      mi_x,\n      ma_x,\n      mi_y,\n      ma_y,\n      dataX = [],\n      dataY = [],\n      ret = [],\n      num_components = 0,\n      delta,\n      that = this,\n      fmi_x = function (t) {\n        return that.f(x, t);\n      },\n      fma_x = function (t) {\n        return -that.f(x, t);\n      },\n      fmi_y = function (t) {\n        return that.f(t, y);\n      },\n      fma_y = function (t) {\n        return -that.f(t, y);\n      };\n\n    // Vertical lines or circular search:\n    mi_x = Math.min(this.bbox[0], this.bbox[2]) - Mat.eps;\n    ma_x = Math.max(this.bbox[0], this.bbox[2]);\n    mi_y = Math.min(this.bbox[1], this.bbox[3]) + Mat.eps;\n    ma_y = Math.max(this.bbox[1], this.bbox[3]);\n    if (doVerticalSearch) {\n      delta = this.config.resolution_out / this.config.unitX;\n      delta *= 1 + Mat.eps;\n      // console.log(\"Outer delta x\", delta)\n\n      for (x = mi_x; x < ma_x; x += delta) {\n        ret = this.searchLine(fmi_x, fma_x, x, [mi_y, ma_y], 'vertical', num_components, dataX, dataY);\n        if (ret !== false) {\n          dataX = ret[0];\n          dataY = ret[1];\n          num_components = ret[2];\n        }\n      }\n    }\n    if (doHorizontalSearch) {\n      delta = this.config.resolution_out / this.config.unitY;\n      delta *= 1 + Mat.eps;\n      // console.log(\"Outer delta y\", delta)\n\n      for (y = mi_y; y < ma_y; y += delta) {\n        ret = this.searchLine(fmi_y, fma_y, y, [mi_x, ma_x], 'horizontal', num_components, dataX, dataY);\n        if (ret !== false) {\n          dataX = ret[0];\n          dataY = ret[1];\n          num_components = ret[2];\n        }\n      }\n    }\n    return [dataX, dataY, num_components];\n  },\n  /**\n   * Recursively search a horizontal or vertical line for points on the\n   * fulfilling the given equation.\n   *\n   * @param {Function} fmi Minimization function\n   * @param {Function} fma Maximization function\n   * @param {Number} fix Value of the fixed variable\n   * @param {Array} interval Search interval of the free variable\n   * @param {String} dir 'vertical' or 'horizontal'\n   * @param {Number} num_components Number of components before search\n   * @param {Array} dataX x-coordinates of points so far\n   * @param {Array} dataY y-coordinates of points so far\n   * @returns {Array} consisting of [dataX, dataY, number_of_components]-\n   * @private\n   */\n  searchLine: function (fmi, fma, fix, interval, dir, num_components, dataX, dataY) {\n    var t_mi,\n      t_ma,\n      t,\n      ft,\n      mi,\n      ma,\n      tmp,\n      m,\n      is_in,\n      u0,\n      i,\n      le,\n      ret,\n      offset,\n      delta,\n      eps = this.config.tol_u0,\n      DEBUG = false,\n      b = interval[0],\n      e = interval[1];\n    t_mi = Numerics.fminbr(fmi, [b, e]);\n    mi = fmi(t_mi);\n    t_ma = Numerics.fminbr(fma, [b, e]);\n    ma = fmi(t_ma);\n    if (mi < eps && ma > -eps) {\n      tmp = t_mi;\n      t_mi = Math.min(tmp, t_ma);\n      t_ma = Math.max(tmp, t_ma);\n      t = Numerics.fzero(fmi, [t_mi, t_ma]);\n      // t = Numerics.chandrupatla(fmi, [t_mi, t_ma]);\n\n      ft = fmi(t);\n      if (Math.abs(ft) > Math.max((ma - mi) * Mat.eps, 0.001)) {\n        //console.log(\"searchLine:\",  dir, fix, t, \"no root \" + ft);\n        return false;\n        // throw new Error(\"searchLine: no root \" + ft);\n      }\n      if (dir === 'vertical') {\n        u0 = [1, fix, t];\n        delta = this.config.resolution_in / this.config.unitY;\n        // console.log(\"Inner delta x\", delta)\n      } else {\n        u0 = [1, t, fix];\n        delta = this.config.resolution_in / this.config.unitX;\n        // console.log(\"Inner delta y\", delta)\n      }\n      delta *= 1 + Mat.eps;\n      is_in = this.curveContainsPoint(u0, dataX, dataY, delta * 2,\n      // Allowed dist from segment\n      this.config.qdt_box // 0.5 of box size to search in qdt\n      );\n      if (is_in) {\n        if (DEBUG) {\n          console.log(\"Found in quadtree\", u0);\n        }\n      } else {\n        if (DEBUG) {\n          console.log(\"Not in quadtree\", u0, dataX.length);\n        }\n        ret = this.traceComponent(u0, 1);\n        if (ret.length > 0) {\n          // Add jump in curve\n          if (num_components > 0) {\n            dataX.push(NaN);\n            dataY.push(NaN);\n          }\n          offset = dataX.length;\n          le = ret[0].length;\n          for (i = 1; i < le; i++) {\n            this.qdt.insertItem({\n              xlb: Math.min(ret[0][i - 1], ret[0][i]),\n              xub: Math.max(ret[0][i - 1], ret[0][i]),\n              ylb: Math.min(ret[1][i - 1], ret[1][i]),\n              yub: Math.max(ret[1][i - 1], ret[1][i]),\n              idx1: offset + i - 1,\n              idx2: offset + i,\n              comp: num_components\n            });\n          }\n          num_components++;\n          dataX = dataX.concat(ret[0]);\n          dataY = dataY.concat(ret[1]);\n        }\n      }\n      m = t - delta * 0.01;\n      if (m - b > delta) {\n        ret = this.searchLine(fmi, fma, fix, [b, m], dir, num_components, dataX, dataY);\n        if (ret !== false) {\n          dataX = ret[0];\n          dataY = ret[1];\n          num_components = ret[2];\n        }\n      }\n      m = t + delta * 0.01;\n      if (e - m > delta) {\n        ret = this.searchLine(fmi, fma, fix, [m, e], dir, num_components, dataX, dataY);\n        if (ret !== false) {\n          dataX = ret[0];\n          dataY = ret[1];\n          num_components = ret[2];\n        }\n      }\n      return [dataX, dataY, num_components];\n    }\n    return false;\n  },\n  /**\n   * Test if the data points contain a given coordinate, i.e. if the\n   * given coordinate is close enough to the polygonal chain\n   * through the data points.\n   *\n   * @param {Array} p Homogenous coordinates [1, x, y] of the coordinate point\n   * @param {Array} dataX x-coordinates of points so far\n   * @param {Array} dataY y-coordinates of points so far\n   * @param {Number} tol Maximal distance of p from the polygonal chain through the data points\n   * @param {Number} eps Helper tolerance used for the quadtree\n   * @returns Boolean\n   */\n  curveContainsPoint: function (p, dataX, dataY, tol, eps) {\n    var i,\n      le,\n      hits,\n      d,\n      x = p[1],\n      y = p[2];\n    hits = this.qdt.find([x - eps, y + eps, x + eps, y - eps]);\n    le = hits.length;\n    for (i = 0; i < le; i++) {\n      d = Geometry.distPointSegment(p, [1, dataX[hits[i].idx1], dataY[hits[i].idx1]], [1, dataX[hits[i].idx2], dataY[hits[i].idx2]]);\n      if (d < tol) {\n        return true;\n      }\n    }\n    return false;\n  },\n  /**\n   * Starting at an initial point the curve is traced with a Euler-Newton method.\n   * After tracing in one direction the algorithm stops if the component is a closed loop.\n   * Otherwise, the curved is traced in the opposite direction, starting from\n   * the same initial point. Finally, the two components are glued together.\n   *\n   * @param {Array} u0 Initial point in homogenous coordinates [1, x, y].\n   * @returns Array [dataX, dataY] containing a new component.\n   * @private\n   */\n  traceComponent: function (u0) {\n    var dataX = [],\n      dataY = [],\n      arr = [];\n\n    // Trace in first direction\n    // console.log(\"---- Start tracing forward ---------\")\n    arr = this.tracing(u0, 1);\n    if (arr.length === 0) {\n      // console.log(\"Could not start tracing due to singularity\")\n    } else {\n      // console.log(\"Trace from\", [arr[0][0], arr[1][0]], \"to\", [arr[0][arr[0].length - 1], arr[1][arr[1].length - 1]],\n      //     \"num points:\", arr[0].length);\n      dataX = arr[0];\n      dataY = arr[1];\n    }\n\n    // Trace in the other direction\n    if (!arr[2]) {\n      // No loop in the first tracing step,\n      // now explore the other direction.\n\n      // console.log(\"---- Start tracing backward ---------\")\n      arr = this.tracing(u0, -1);\n      if (arr.length === 0) {\n        // console.log(\"Could not start backward tracing due to singularity\")\n      } else {\n        // console.log(\"Trace backwards from\", [arr[0][0], arr[1][0]], \"to\",\n        //     [arr[0][arr[0].length - 1], arr[1][arr[1].length - 1]], \"num points:\", arr[0].length);\n        dataX = arr[0].reverse().concat(dataX.slice(1));\n        dataY = arr[1].reverse().concat(dataY.slice(1));\n      }\n    }\n    if (dataX.length < 6) {\n      // Solitary point\n      dataX.push(dataX[dataX.length - 1]);\n      dataY.push(dataY[dataY.length - 1]);\n    }\n    return [dataX, dataY];\n  },\n  /**\n   * Starting at a point <i>u0</i>, this routine traces the curve <i>f(u)=0</i> until\n   * a loop is detected, a critical point is reached, the curve leaves the bounding box,\n   * or the maximum number of points is reached.\n   * <p>\n   * The method is a predictor / corrector method consisting of Euler and Newton steps\n   * together with step width adaption.\n   * <p>\n   * The algorithm is an adaption of the algorithm in\n   * Eugene L. Allgower, Kurt Georg: <i>Introduction to Numerical Continuation methods.</i>\n   *\n   * @param {Array} u0 Starting point in homogenous coordinates  [1, x, y].\n   * @param {Number} direction 1 or -1\n   * @returns Array [pathX, pathY, loop_closed] or []\n   * @private\n   */\n  tracing: function (u0, direction) {\n    var u = [],\n      v = [],\n      v_start = [],\n      w = [],\n      t_u,\n      t_v,\n      t_u_0,\n      A,\n      grad,\n      nrm,\n      dir,\n      steps = 0,\n      k = 0,\n      loop_closed = false,\n      k0,\n      k1,\n      denom,\n      dist,\n      progress,\n      kappa,\n      delta,\n      alpha,\n      factor,\n      point_added = false,\n      quasi = false,\n      cusp_or_bifurc = false,\n      kappa_0 = this.config.kappa_0,\n      // Inverse of planned number of Newton steps\n      delta_0 = this.config.delta_0,\n      // Distance of predictor point to curve\n      alpha_0 = this.config.alpha_0,\n      // Angle between two successive tangents\n      h = this.config.h_initial,\n      max_steps = this.config.max_steps,\n      omega = direction,\n      pathX = [],\n      pathY = [],\n      T = [],\n      // Gosper's loop detector table\n      n,\n      m,\n      i,\n      e;\n    u = u0.slice(1);\n    pathX.push(u[0]);\n    pathY.push(u[1]);\n    t_u = this.tangent(u);\n    if (t_u === false) {\n      // We don't want to start at a singularity.\n      // Get out of here and search for another starting point.\n      return [];\n    }\n    A = [this.dfx(u[0], u[1]), this.dfy(u[0], u[1])];\n    do {\n      if (quasi) {\n        t_u = this.tangent_A(A);\n      } else {\n        t_u = this.tangent(u);\n      }\n      if (t_u === false) {\n        u = v.slice();\n        pathX.push(u[0]);\n        pathY.push(u[1]);\n        // console.log(\"-> Bail out: t_u undefined.\");\n        break;\n      }\n      if (pathX.length === 1) {\n        // Store first point\n        t_u_0 = t_u.slice();\n      } else if (pathX.length === 2) {\n        T.push(pathX.length - 1); // Put first point into Gosper table T\n      } else if (point_added && pathX.length > 2 && !cusp_or_bifurc) {\n        // Detect if loop has been closed\n        dist = Geometry.distPointSegment([1, u[0], u[1]], [1, pathX[0], pathY[0]], [1, pathX[1], pathY[1]]);\n        if (dist < this.config.loop_dist * h && Mat.innerProduct(t_u, t_u_0, 2) > this.config.loop_dir) {\n          // console.log(\"Loop detected after\", steps, \"steps\");\n          // console.log(\"\\t\", \"v\", v, \"u0:\", u0)\n          // console.log(\"\\t\", \"Dist(v, path0)\", dist, config.loop_dist * h)\n          // console.log(\"\\t\", \"t_u\", t_u);\n          // console.log(\"\\t\", \"inner:\", Mat.innerProduct(t_u, t_u_0, 2));\n          // console.log(\"\\t\", \"h\", h);\n\n          u = u0.slice(1);\n          pathX.push(u[0]);\n          pathY.push(u[1]);\n          loop_closed = true;\n          break;\n        }\n\n        // Gosper's loop detector\n        if (this.config.loop_detection) {\n          n = pathX.length - 1;\n          // console.log(\"Check Gosper\", n);\n          m = Math.floor(Mat.log2(n));\n          for (i = 0; i <= m; i++) {\n            dist = Geometry.distPointSegment([1, u[0], u[1]], [1, pathX[T[i] - 1], pathY[T[i] - 1]], [1, pathX[T[i]], pathY[T[i]]]);\n            if (dist < this.config.loop_dist * h) {\n              // console.log(\"!!!!!!!!!!!!!!! GOSPER LOOP CLOSED !!!!\", i, n + 1,\n              //     this.config.loop_dist * h\n              // );\n\n              t_v = this.tangent([pathX[T[i]], pathY[T[i]]]);\n              if (Mat.innerProduct(t_u, t_v, 2) > this.config.loop_dir) {\n                // console.log(\"!!!!!!!!!!!!!!! angle is good enough\");\n                break;\n              }\n            }\n          }\n          if (i <= m) {\n            loop_closed = true;\n            break;\n          }\n          m = 1;\n          e = 0;\n          for (i = 0; i < 100; i++) {\n            if ((n + 1) % m !== 0) {\n              break;\n            }\n            m *= 2;\n            e++;\n          }\n          // console.log(\"Add at e\", e);\n          T[e] = n;\n        }\n      }\n\n      // Predictor step\n      // if (true /*h < 2 * this.config.h_initial*/) {\n      // Euler\n      // console.log(\"euler\")\n      v[0] = u[0] + h * omega * t_u[0];\n      v[1] = u[1] + h * omega * t_u[1];\n      // } else {\n      //     // Heun\n      //     // console.log(\"heun\")\n      //     v[0] = u[0] + h * omega * t_u[0];\n      //     v[1] = u[1] + h * omega * t_u[1];\n\n      //     t_v = this.tangent(v);\n      //     v[0] = 0.5 * u[0] + 0.5 * (v[0] + h * omega * t_v[0]);\n      //     v[1] = 0.5 * u[1] + 0.5 * (v[1] + h * omega * t_v[1]);\n      // }\n      if (quasi) {\n        A = this.updateA(A, u, v);\n        v_start = v.slice();\n      }\n\n      // Corrector step: Newton\n      k = 0;\n      do {\n        if (quasi) {\n          grad = A;\n        } else {\n          grad = [this.dfx(v[0], v[1]), this.dfy(v[0], v[1])];\n        }\n\n        // Compute w = v - A(v) * f(v),\n        // grad: row vector and A(v) is the Moore-Penrose inverse:\n        // grad^T * (grad * grad^T)^(-1)\n        denom = grad[0] * grad[0] + grad[1] * grad[1];\n        nrm = this.f(v[0], v[1]) / denom;\n        w[0] = v[0] - grad[0] * nrm;\n        w[1] = v[1] - grad[1] * nrm;\n        if (k === 0) {\n          k0 = Math.abs(nrm) * Math.sqrt(denom);\n        } else if (k === 1) {\n          k1 = Math.abs(nrm) * Math.sqrt(denom);\n        }\n        v[0] = w[0];\n        v[1] = w[1];\n        k++;\n      } while (k < 20 && Math.abs(this.f(v[0], v[1])) > this.config.tol_newton);\n      delta = k0;\n      if (k > 1) {\n        kappa = k1 / k0;\n      } else {\n        kappa = 0.0;\n      }\n      if (quasi) {\n        A = this.updateA(A, v_start, v);\n        t_v = this.tangent_A(A);\n      } else {\n        t_v = this.tangent(v);\n      }\n      dir = Mat.innerProduct(t_u, t_v, 2);\n      dir = Math.max(-1, Math.min(1, dir));\n      alpha = Math.acos(dir);\n\n      // Look for simple bifurcation points and cusps\n      cusp_or_bifurc = false;\n      progress = Geometry.distance(u, v, 2);\n      if (progress < this.config.tol_progress) {\n        u = v.slice();\n        pathX.push(u[0]);\n        pathY.push(u[1]);\n        // console.log(\"-> Bail out, no progress\", progress, steps);\n        break;\n      } else if (dir < 0.0) {\n        if (h > this.config.h_critical) {\n          // console.log(\"Critical point at [\", u[0].toFixed(4), u[1].toFixed(4), \"], v: [\", v[0].toFixed(4), v[1].toFixed(4), \"], but large  h:\", h);\n        } else {\n          cusp_or_bifurc = true;\n          if (this.isBifurcation(u, this.config.tol_cusp)) {\n            // console.log(steps, \"bifurcation point between\", u, \"and\", v, \":\", dir, \"h\", h, \"alpha\", alpha);\n            // A = [dfx(v[0], v[1]), dfy(v[0], v[1])];\n            omega *= -1;\n            // If there is a bifurcation point, we\n            // ignore the angle alpha for subsequent step length\n            // adaption. Because then we might be able to\n            // \"jump over the critical point\"\n            alpha = 0;\n          } else {\n            // Cusp or something more weird\n            u = v.slice();\n            pathX.push(u[0]);\n            pathY.push(u[1]);\n            // console.log(\"-> Bail out, cusp\")\n            break;\n          }\n        }\n      }\n\n      // Adapt stepwidth\n      if (!cusp_or_bifurc) {\n        factor = Math.max(Math.sqrt(kappa / kappa_0), Math.sqrt(delta / delta_0), alpha / alpha_0);\n        if (isNaN(factor)) {\n          factor = 1;\n        }\n        factor = Math.max(Math.min(factor, 2), 0.5);\n        h /= factor;\n        h = Math.min(this.config.h_max, h);\n        if (factor >= 2) {\n          steps++;\n          if (steps >= 3 * max_steps) {\n            break;\n          }\n          point_added = false;\n          continue;\n        }\n      }\n      u = v.slice();\n      pathX.push(u[0]);\n      pathY.push(u[1]);\n      point_added = true;\n      steps++;\n    } while (steps < max_steps && u[0] >= this.bbox[0] && u[1] <= this.bbox[1] && u[0] <= this.bbox[2] && u[1] >= this.bbox[3]);\n\n    // if (!loop_closed) {\n    //     console.log(\"No loop\", steps);\n    // } else {\n    //     console.log(\"Loop\", steps);\n    // }\n\n    return [pathX, pathY, loop_closed];\n  },\n  /**\n   * If both eigenvalues of the Hessian are different from zero, the critical point at u\n   * is a simple bifurcation point.\n   *\n   * @param {Array} u Critical point [x, y]\n   * @param {Number} tol Tolerance of the eigenvalues to be zero.\n   * @returns Boolean True if the point is a simple bifurcation point.\n   * @private\n   */\n  isBifurcation: function (u, tol) {\n    // Former experiments:\n    // If the Hessian has exactly one zero eigenvalue,\n    // we claim that there is a cusp.\n    // Otherwise, we decide that there is a bifurcation point.\n    // In the latter case, if both eigenvalues are zero\n    // this is a somewhat crude decision.\n    //\n    var h = Mat.eps * Mat.eps * 100,\n      x,\n      y,\n      a,\n      b,\n      c,\n      d,\n      ad,\n      lbda1,\n      lbda2,\n      dis;\n    x = u[0];\n    y = u[1];\n    a = 0.5 * (this.dfx(x + h, y) - this.dfx(x - h, y)) / h;\n    b = 0.5 * (this.dfx(x, y + h) - this.dfx(x, y - h)) / h;\n    c = 0.5 * (this.dfy(x + h, y) - this.dfy(x - h, y)) / h;\n    d = 0.5 * (this.dfy(x, y + h) - this.dfy(x, y - h)) / h;\n\n    // c = b\n    ad = a + d;\n    dis = ad * ad - 4 * (a * d - b * c);\n    lbda1 = 0.5 * (ad + Math.sqrt(dis));\n    lbda2 = 0.5 * (ad - Math.sqrt(dis));\n\n    // console.log(a, b, c, d)\n    // console.log(\"Eigenvals u:\", lbda1, lbda2, tol);\n\n    if (Math.abs(lbda1) > tol && Math.abs(lbda2) > tol) {\n      // if (lbda1 * lbda2 > 0) {\n      //     console.log(\"Seems to be isolated singularity at\", u);\n      // }\n      return true;\n    }\n    return false;\n  },\n  /**\n   * Search in an arc around a critical point for a further point on the curve.\n   * Unused for the moment.\n   *\n   * @param {Array} u Critical point [x, y]\n   * @param {Array} t_u Tangent at u\n   * @param {Number} r Radius\n   * @param {Number} omega angle\n   * @returns {Array} Coordinates [x, y] of a new point.\n   * @private\n   */\n  handleCriticalPoint: function (u, t_u, r, omega) {\n    var a = Math.atan2(omega * t_u[1], omega * t_u[0]),\n      // s = a - 0.75 * Math.PI,\n      // e = a + 0.75 * Math.PI,\n      f_circ = function (t) {\n        var x = u[0] + r * Math.cos(t),\n          y = u[1] + r * Math.sin(t);\n        return this.f(x, y);\n      },\n      x,\n      y,\n      t0;\n\n    // t0 = Numerics.fzero(f_circ, [s, e]);\n    t0 = Numerics.root(f_circ, a);\n    x = u[0] + r * Math.cos(t0);\n    y = u[1] + r * Math.sin(t0);\n    // console.log(\"\\t\", \"result\", x, y, \"f\", f(x, y));\n\n    return [x, y];\n  },\n  /**\n   * Quasi-Newton update of the Moore-Penrose inverse.\n   * See (7.2.3) in Allgower, Georg.\n   *\n   * @param {Array} A\n   * @param {Array} u0\n   * @param {Array} u1\n   * @returns Array\n   * @private\n   */\n  updateA: function (A, u0, u1) {\n    var s = [u1[0] - u0[0], u1[1] - u0[1]],\n      y = this.f(u1[0], u1[1]) - this.f(u0[0], u0[1]),\n      nom,\n      denom;\n    denom = s[0] * s[0] + s[1] * s[1];\n    nom = y - (A[0] * s[0] + A[1] * s[1]);\n    nom /= denom;\n    A[0] += nom * s[0];\n    A[1] += nom * s[1];\n    return A;\n  },\n  /**\n   * Approximate tangent (of norm 1) with Quasi-Newton method\n   * @param {Array} A\n   * @returns Array\n   * @private\n   */\n  tangent_A: function (A) {\n    var t = [-A[1], A[0]],\n      nrm = Mat.norm(t, 2);\n    if (nrm < Mat.eps) {\n      // console.log(\"Approx. Singularity\", t, \"is zero\", nrm);\n    }\n    return [t[0] / nrm, t[1] / nrm];\n  },\n  /**\n   * Tangent of norm 1 at point u.\n   * @param {Array} u Point [x, y]\n   * @returns Array\n   * @private\n   */\n  tangent: function (u) {\n    var t = [-this.dfy(u[0], u[1]), this.dfx(u[0], u[1])],\n      nrm = Mat.norm(t, 2);\n    if (nrm < Mat.eps * Mat.eps) {\n      // console.log(\"Singularity\", t, \"is zero\", \"at\", u, \":\", nrm);\n      return false;\n    }\n    return [t[0] / nrm, t[1] / nrm];\n  }\n});\nexport default Mat.ImplicitPlot;","map":{"version":3,"names":["Type","Mat","Geometry","Numerics","Quadtree","ImplicitPlot","bbox","config","f","dfx","dfy","cfg_default","resolution_out","resolution_in","max_steps","alpha_0","tol_u0","eps","tol_newton","tol_cusp","tol_progress","qdt_box","kappa_0","delta_0","h_initial","h_critical","h_max","loop_dist","loop_dir","loop_detection","unitX","unitY","merge","isFunction","x","y","h","qdt","components","extend","prototype","plot","doVerticalSearch","doHorizontalSearch","mi_x","ma_x","mi_y","ma_y","dataX","dataY","ret","num_components","delta","that","fmi_x","t","fma_x","fmi_y","fma_y","Math","min","max","searchLine","fmi","fma","fix","interval","dir","t_mi","t_ma","ft","mi","ma","tmp","m","is_in","u0","i","le","offset","DEBUG","b","e","fminbr","fzero","abs","curveContainsPoint","console","log","length","traceComponent","push","NaN","insertItem","xlb","xub","ylb","yub","idx1","idx2","comp","concat","p","tol","hits","d","find","distPointSegment","arr","tracing","reverse","slice","direction","u","v","v_start","w","t_u","t_v","t_u_0","A","grad","nrm","steps","k","loop_closed","k0","k1","denom","dist","progress","kappa","alpha","factor","point_added","quasi","cusp_or_bifurc","omega","pathX","pathY","T","n","tangent","tangent_A","innerProduct","floor","log2","updateA","sqrt","acos","distance","isBifurcation","isNaN","a","c","ad","lbda1","lbda2","dis","handleCriticalPoint","r","atan2","f_circ","cos","sin","t0","root","u1","s","nom","norm"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/math/implicitplot.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n\"use strict\";\n\nimport Type from \"../utils/type\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Numerics from \"./numerics\";\nimport Quadtree from \"./bqdt\";\n\n/**\n * Plotting of curves which are given implicitly as the set of points solving an equation\n * <i>f(x,y) = 0</i>.\n * <p>\n * The main class initializes a new implicit plot instance.\n * <p>\n * The algorithm should be able to plot most implicit curves as long as the equations\n * are not too complex. We are aware of the paper by Oliver Labs,\n * <a href=\"https://link.springer.com/chapter/10.1007/978-1-4419-0999-2_6\">A List of Challenges for Real Algebraic Plane Curve Visualization Software</a>\n * which contains many equations where this algorithm may fail.\n * For example,  at the time being there is no attempt to detect <i>solitary points</i>.\n * Also, it is always a trade off to find all components of the curve and\n * keep the construction responsive.\n *\n * @name JXG.Math.ImplicitPlot\n * @exports Mat.ImplicitPlot as JXG.Math.ImplicitPlot\n * @param {Array} bbox Bounding box of the area in which solutions of the equation\n * are determined.\n * @param {Object} config Configuration object. Default:\n * <pre>\n *  {\n *      resolution_out: 5,    // Horizontal resolution: distance between vertical lines to search for components\n *      resolution_in: 5,     // Vertical resolution to search for components\n *      max_steps: 1024,      // Max number of points in one call of tracing\n *      alpha_0: 0.05,        // Angle between two successive tangents: smoothness of curve\n *\n *      tol_u0: Mat.eps,      // Tolerance to find starting points for tracing.\n *      tol_newton: 1.0e-7,   // Tolerance for Newton steps.\n *      tol_cusp: 0.05,       // Tolerance for cusp / bifurcation detection\n *      tol_progress: 0.0001, // If two points are closer than this value, we bail out\n *      qdt_box: 0.2,         // half of box size to search in qdt\n *      kappa_0: 0.2,         // Inverse of planned number of Newton steps\n *      delta_0: 0.05,        // Distance of predictor point to curve\n *\n *      h_initial: 0.1,       // Initial stepwidth\n *      h_critical: 0.001,    // If h is below this threshold we bail out\n *      h_max: 1,             // Maximal value of h (user units)\n *      loop_dist: 0.09,      // Allowed distance (multiplied by actual stepwidth) to detect loop\n *      loop_dir: 0.99,       // Should be > 0.95\n *      loop_detection: true, // Use Gosper's loop detector\n *      unitX: 10,            // unitX of board\n *      unitY: 10             // unitX of board\n *   };\n * </pre>\n * @param {function} f function from <b>R</b><sup>2</sup> to <b>R</b>\n * @param {function} [dfx] Optional partial derivative of <i>f</i> with regard to <i>x</i>\n * @param {function} [dfy] Optional partial derivative of <i>f</i> with regard to <i>y</i>\n *\n * @constructor\n * @example\n *     var f = (x, y) => x**3 - 2 * x * y + y**3;\n *     var c = board.create('curve', [[], []], {\n *             strokeWidth: 3,\n *             strokeColor: JXG.palette.red\n *         });\n *\n *     c.updateDataArray = function () {\n *         var bbox = this.board.getBoundingBox(),\n *             ip, cfg,\n *             ret = [],\n *             mgn = 1;\n *\n *         bbox[0] -= mgn;\n *         bbox[1] += mgn;\n *         bbox[2] += mgn;\n *         bbox[3] -= mgn;\n *\n *         cfg = {\n *             resolution_out: 5,\n *             resolution_in: 5,\n *             unitX: this.board.unitX,\n *             unitY: this.board.unitX\n *         };\n *\n *         this.dataX = [];\n *         this.dataY = [];\n *         ip = new JXG.Math.ImplicitPlot(bbox, cfg, f, null, null);\n *         ret = ip.plot();\n *         this.dataX = ret[0];\n *         this.dataY = ret[1];\n *     };\n *     board.update();\n * </pre><div id=\"JXGf3e8cd82-2b67-4efb-900a-471eb92b3b96\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n * <script type=\"text/javascript\">\n *     (function() {\n *         var board = JXG.JSXGraph.initBoard('JXGf3e8cd82-2b67-4efb-900a-471eb92b3b96',\n *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n *             var f = (x, y) => x**3 - 2 * x * y + y**3;\n *             var c = board.create('curve', [[], []], {\n *                     strokeWidth: 3,\n *                     strokeColor: JXG.palette.red\n *                 });\n *\n *             c.updateDataArray = function () {\n *                 var bbox = this.board.getBoundingBox(),\n *                     ip, cfg,\n *                     ret = [],\n *                     mgn = 1;\n *\n *                 bbox[0] -= mgn;\n *                 bbox[1] += mgn;\n *                 bbox[2] += mgn;\n *                 bbox[3] -= mgn;\n *\n *                 cfg = {\n *                     resolution_out: 5,\n *                     resolution_in: 5,\n *                     unitX: this.board.unitX,\n *                     unitY: this.board.unitX\n *                 };\n *\n *                 this.dataX = [];\n *                 this.dataY = [];\n *\n *                 ip = new JXG.Math.ImplicitPlot(bbox, cfg, f, null, null);\n *                 ret = ip.plot();\n *\n *                 this.dataX = ret[0];\n *                 this.dataY = ret[1];\n *             };\n *             board.update();\n *\n *     })();\n *\n * </script><pre>\n *\n */\nMat.ImplicitPlot = function (bbox, config, f, dfx, dfy) {\n\n    // Default values\n    var cfg_default = {\n        resolution_out: 5,    // Distance between vertical lines to search for components\n        resolution_in: 5,     // Distance between vertical lines to search for components\n        max_steps: 1024,      // Max number of points in one call of tracing\n        alpha_0: 0.05,        // Angle between two successive tangents: smoothness of curve\n\n        tol_u0: Mat.eps,      // Tolerance to find starting points for tracing.\n        tol_newton: 1.0e-7,   // Tolerance for Newton steps.\n        tol_cusp: 0.05,       // Tolerance for cusp / bifurcation detection\n        tol_progress: 0.0001, // If two points are closer than this value, we bail out\n        qdt_box: 0.2,         // half of box size to search in qdt\n        kappa_0: 0.2,         // Inverse of planned number of Newton steps\n        delta_0: 0.05,        // Distance of predictor point to curve\n\n        h_initial: 0.1,       // Initial step width\n        h_critical: 0.001,    // If h is below this threshold we bail out\n        h_max: 1,             // Maximum value of h (user units)\n        loop_dist: 0.09,      // Allowed distance (multiplied by actual step width) to detect loop\n        loop_dir: 0.99,       // Should be > 0.95\n        loop_detection: true, // Use Gosper's loop detector\n        unitX: 10,            // unitX of board\n        unitY: 10             // unitX of board\n    };\n\n    this.config = Type.merge(cfg_default, config);\n\n    this.f = f;\n\n    this.dfx = null;\n    this.dfy = null;\n\n    if (Type.isFunction(dfx)) {\n        this.dfx = dfx;\n    } else {\n        this.dfx = function (x, y) {\n            var h = Mat.eps * Mat.eps;\n            return (this.f(x + h, y) - this.f(x - h, y)) * 0.5 / h;\n        };\n    }\n\n    if (Type.isFunction(dfy)) {\n        this.dfy = dfy;\n    } else {\n        this.dfy = function (x, y) {\n            var h = Mat.eps * Mat.eps;\n            return (this.f(x, y + h) - this.f(x, y - h)) * 0.5 / h;\n        };\n    }\n\n    this.bbox = bbox;\n    this.qdt = new Quadtree(20, 5, bbox);\n\n    this.components = [];\n};\n\nType.extend(\n    Mat.ImplicitPlot.prototype,\n    /** @lends JXG.Math.ImplicitPlot.prototype */ {\n\n        /**\n         * Implicit plotting method.\n         *\n         * @returns {Array} consisting of [dataX, dataY, number_of_components]\n         */\n        plot: function () {\n            var // components = [],\n                doVerticalSearch = true,\n                doHorizontalSearch = true,\n                x, y,\n                mi_x, ma_x, mi_y, ma_y,\n                dataX = [],\n                dataY = [],\n                ret = [],\n                num_components = 0,\n\n                delta,\n                that = this,\n\n                fmi_x = function (t) {\n                    return that.f(x, t);\n                },\n                fma_x = function (t) {\n                    return -that.f(x, t);\n                },\n                fmi_y = function (t) {\n                    return that.f(t, y);\n                },\n                fma_y = function (t) {\n                    return -that.f(t, y);\n                };\n\n            // Vertical lines or circular search:\n            mi_x = Math.min(this.bbox[0], this.bbox[2]) - Mat.eps;\n            ma_x = Math.max(this.bbox[0], this.bbox[2]);\n            mi_y = Math.min(this.bbox[1], this.bbox[3]) + Mat.eps;\n            ma_y = Math.max(this.bbox[1], this.bbox[3]);\n\n            if (doVerticalSearch) {\n                delta = this.config.resolution_out / this.config.unitX;\n                delta *= (1 + Mat.eps);\n                // console.log(\"Outer delta x\", delta)\n\n                for (x = mi_x; x < ma_x; x += delta) {\n                    ret = this.searchLine(\n                        fmi_x, fma_x, x,\n                        [mi_y, ma_y], 'vertical',\n                        num_components, dataX, dataY);\n\n                    if (ret !== false) {\n                        dataX = ret[0];\n                        dataY = ret[1];\n                        num_components = ret[2];\n                    }\n\n                }\n            }\n            if (doHorizontalSearch) {\n                delta = this.config.resolution_out / this.config.unitY;\n                delta *= (1 + Mat.eps);\n                // console.log(\"Outer delta y\", delta)\n\n                for (y = mi_y; y < ma_y; y += delta) {\n                    ret = this.searchLine(\n                        fmi_y, fma_y, y,\n                        [mi_x, ma_x], 'horizontal',\n                        num_components, dataX, dataY);\n\n                    if (ret !== false) {\n                        dataX = ret[0];\n                        dataY = ret[1];\n                        num_components = ret[2];\n                    }\n                }\n            }\n\n            return [dataX, dataY, num_components];\n        },\n\n        /**\n         * Recursively search a horizontal or vertical line for points on the\n         * fulfilling the given equation.\n         *\n         * @param {Function} fmi Minimization function\n         * @param {Function} fma Maximization function\n         * @param {Number} fix Value of the fixed variable\n         * @param {Array} interval Search interval of the free variable\n         * @param {String} dir 'vertical' or 'horizontal'\n         * @param {Number} num_components Number of components before search\n         * @param {Array} dataX x-coordinates of points so far\n         * @param {Array} dataY y-coordinates of points so far\n         * @returns {Array} consisting of [dataX, dataY, number_of_components]-\n         * @private\n         */\n        searchLine: function (fmi, fma, fix, interval, dir,\n            num_components, dataX, dataY) {\n            var t_mi, t_ma, t,\n                ft,\n                mi, ma, tmp, m,\n                is_in,\n                u0, i, le,\n                ret,\n                offset,\n                delta,\n                eps = this.config.tol_u0,\n                DEBUG = false,\n                b = interval[0],\n                e = interval[1];\n\n            t_mi = Numerics.fminbr(fmi, [b, e]);\n            mi = fmi(t_mi);\n            t_ma = Numerics.fminbr(fma, [b, e]);\n            ma = fmi(t_ma);\n\n            if (mi < eps && ma > -eps) {\n                tmp = t_mi;\n                t_mi = Math.min(tmp, t_ma);\n                t_ma = Math.max(tmp, t_ma);\n\n                t = Numerics.fzero(fmi, [t_mi, t_ma]);\n                // t = Numerics.chandrupatla(fmi, [t_mi, t_ma]);\n\n                ft = fmi(t);\n                if (Math.abs(ft) > Math.max((ma - mi) * Mat.eps, 0.001)) {\n                    //console.log(\"searchLine:\",  dir, fix, t, \"no root \" + ft);\n                    return false;\n                    // throw new Error(\"searchLine: no root \" + ft);\n                }\n                if (dir === 'vertical') {\n                    u0 = [1, fix, t];\n                    delta = this.config.resolution_in / this.config.unitY;\n                    // console.log(\"Inner delta x\", delta)\n                } else {\n                    u0 = [1, t, fix];\n                    delta = this.config.resolution_in / this.config.unitX;\n                    // console.log(\"Inner delta y\", delta)\n                }\n                delta *= (1 + Mat.eps);\n\n                is_in = this.curveContainsPoint(u0, dataX, dataY,\n                    delta * 2,           // Allowed dist from segment\n                    this.config.qdt_box  // 0.5 of box size to search in qdt\n                );\n\n                if (is_in) {\n                    if (DEBUG) {\n                        console.log(\"Found in quadtree\", u0);\n                    }\n                } else {\n                    if (DEBUG) {\n                        console.log(\"Not in quadtree\", u0, dataX.length);\n                    }\n                    ret = this.traceComponent(u0, 1);\n                    if (ret.length > 0) {\n                        // Add jump in curve\n                        if (num_components > 0) {\n                            dataX.push(NaN);\n                            dataY.push(NaN);\n                        }\n\n                        offset = dataX.length;\n                        le = ret[0].length;\n                        for (i = 1; i < le; i++) {\n                            this.qdt.insertItem({\n                                xlb: Math.min(ret[0][i - 1], ret[0][i]),\n                                xub: Math.max(ret[0][i - 1], ret[0][i]),\n                                ylb: Math.min(ret[1][i - 1], ret[1][i]),\n                                yub: Math.max(ret[1][i - 1], ret[1][i]),\n                                idx1: offset + i - 1,\n                                idx2: offset + i,\n                                comp: num_components\n                            });\n                        }\n\n                        num_components++;\n                        dataX = dataX.concat(ret[0]);\n                        dataY = dataY.concat(ret[1]);\n                    }\n                }\n\n                m = t - delta * 0.01;\n                if (m - b > delta) {\n                    ret = this.searchLine(\n                        fmi, fma, fix, [b, m], dir,\n                        num_components, dataX, dataY);\n                    if (ret !== false) {\n                        dataX = ret[0];\n                        dataY = ret[1];\n                        num_components = ret[2];\n                    }\n                }\n                m = t + delta * 0.01;\n                if (e - m > delta) {\n                    ret = this.searchLine(\n                        fmi, fma, fix, [m, e], dir,\n                        num_components, dataX, dataY);\n                    if (ret !== false) {\n                        dataX = ret[0];\n                        dataY = ret[1];\n                        num_components = ret[2];\n                    }\n                }\n\n                return [dataX, dataY, num_components];\n            }\n\n            return false;\n        },\n\n        /**\n         * Test if the data points contain a given coordinate, i.e. if the\n         * given coordinate is close enough to the polygonal chain\n         * through the data points.\n         *\n         * @param {Array} p Homogenous coordinates [1, x, y] of the coordinate point\n         * @param {Array} dataX x-coordinates of points so far\n         * @param {Array} dataY y-coordinates of points so far\n         * @param {Number} tol Maximal distance of p from the polygonal chain through the data points\n         * @param {Number} eps Helper tolerance used for the quadtree\n         * @returns Boolean\n         */\n        curveContainsPoint: function (p, dataX, dataY, tol, eps) {\n            var i, le, hits, d,\n                x = p[1],\n                y = p[2];\n\n            hits = this.qdt.find([x - eps, y + eps, x + eps, y - eps]);\n\n            le = hits.length;\n            for (i = 0; i < le; i++) {\n                d = Geometry.distPointSegment(\n                    p,\n                    [1, dataX[hits[i].idx1], dataY[hits[i].idx1]],\n                    [1, dataX[hits[i].idx2], dataY[hits[i].idx2]]\n                );\n                if (d < tol) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        /**\n         * Starting at an initial point the curve is traced with a Euler-Newton method.\n         * After tracing in one direction the algorithm stops if the component is a closed loop.\n         * Otherwise, the curved is traced in the opposite direction, starting from\n         * the same initial point. Finally, the two components are glued together.\n         *\n         * @param {Array} u0 Initial point in homogenous coordinates [1, x, y].\n         * @returns Array [dataX, dataY] containing a new component.\n         * @private\n         */\n        traceComponent: function (u0) {\n            var dataX = [],\n                dataY = [],\n                arr = [];\n\n            // Trace in first direction\n            // console.log(\"---- Start tracing forward ---------\")\n            arr = this.tracing(u0, 1);\n\n            if (arr.length === 0) {\n                // console.log(\"Could not start tracing due to singularity\")\n            } else {\n                // console.log(\"Trace from\", [arr[0][0], arr[1][0]], \"to\", [arr[0][arr[0].length - 1], arr[1][arr[1].length - 1]],\n                //     \"num points:\", arr[0].length);\n                dataX = arr[0];\n                dataY = arr[1];\n            }\n\n            // Trace in the other direction\n            if (!arr[2]) {\n                // No loop in the first tracing step,\n                // now explore the other direction.\n\n                // console.log(\"---- Start tracing backward ---------\")\n                arr = this.tracing(u0, -1);\n\n                if (arr.length === 0) {\n                    // console.log(\"Could not start backward tracing due to singularity\")\n                } else {\n                    // console.log(\"Trace backwards from\", [arr[0][0], arr[1][0]], \"to\",\n                    //     [arr[0][arr[0].length - 1], arr[1][arr[1].length - 1]], \"num points:\", arr[0].length);\n                    dataX = arr[0].reverse().concat(dataX.slice(1));\n                    dataY = arr[1].reverse().concat(dataY.slice(1));\n                }\n            }\n\n            if (dataX.length < 6) {\n                // Solitary point\n                dataX.push(dataX[dataX.length - 1]);\n                dataY.push(dataY[dataY.length - 1]);\n            }\n\n            return [dataX, dataY];\n        },\n\n        /**\n         * Starting at a point <i>u0</i>, this routine traces the curve <i>f(u)=0</i> until\n         * a loop is detected, a critical point is reached, the curve leaves the bounding box,\n         * or the maximum number of points is reached.\n         * <p>\n         * The method is a predictor / corrector method consisting of Euler and Newton steps\n         * together with step width adaption.\n         * <p>\n         * The algorithm is an adaption of the algorithm in\n         * Eugene L. Allgower, Kurt Georg: <i>Introduction to Numerical Continuation methods.</i>\n         *\n         * @param {Array} u0 Starting point in homogenous coordinates  [1, x, y].\n         * @param {Number} direction 1 or -1\n         * @returns Array [pathX, pathY, loop_closed] or []\n         * @private\n         */\n        tracing: function (u0, direction) {\n            var u = [],\n                v = [],\n                v_start = [],\n                w = [],\n                t_u, t_v, t_u_0,\n                A,\n                grad,\n                nrm,\n                dir,\n                steps = 0,\n                k = 0,\n                loop_closed = false,\n                k0, k1, denom, dist, progress,\n                kappa, delta, alpha,\n                factor,\n                point_added = false,\n\n                quasi = false,\n                cusp_or_bifurc = false,\n                kappa_0 = this.config.kappa_0,  // Inverse of planned number of Newton steps\n                delta_0 = this.config.delta_0,  // Distance of predictor point to curve\n                alpha_0 = this.config.alpha_0,  // Angle between two successive tangents\n                h = this.config.h_initial,\n                max_steps = this.config.max_steps,\n\n                omega = direction,\n                pathX = [],\n                pathY = [],\n\n                T = [],            // Gosper's loop detector table\n                n, m, i, e;\n\n            u = u0.slice(1);\n            pathX.push(u[0]);\n            pathY.push(u[1]);\n\n            t_u = this.tangent(u);\n            if (t_u === false) {\n                // We don't want to start at a singularity.\n                // Get out of here and search for another starting point.\n                return [];\n            }\n            A = [this.dfx(u[0], u[1]), this.dfy(u[0], u[1])];\n\n            do {\n\n                if (quasi) {\n                    t_u = this.tangent_A(A);\n                } else {\n                    t_u = this.tangent(u);\n                }\n                if (t_u === false) {\n                    u = v.slice();\n                    pathX.push(u[0]);\n                    pathY.push(u[1]);\n                    // console.log(\"-> Bail out: t_u undefined.\");\n                    break;\n                }\n\n                if (pathX.length === 1) {\n                    // Store first point\n                    t_u_0 = t_u.slice();\n                } else if (pathX.length === 2) {\n                    T.push(pathX.length - 1);       // Put first point into Gosper table T\n\n                } else if (point_added && pathX.length > 2 && !cusp_or_bifurc) {\n\n                    // Detect if loop has been closed\n                    dist = Geometry.distPointSegment(\n                        [1, u[0], u[1]],\n                        [1, pathX[0], pathY[0]],\n                        [1, pathX[1], pathY[1]]\n                    );\n\n                    if (dist < this.config.loop_dist * h &&\n                        Mat.innerProduct(t_u, t_u_0, 2) > this.config.loop_dir\n                    ) {\n\n                        // console.log(\"Loop detected after\", steps, \"steps\");\n                        // console.log(\"\\t\", \"v\", v, \"u0:\", u0)\n                        // console.log(\"\\t\", \"Dist(v, path0)\", dist, config.loop_dist * h)\n                        // console.log(\"\\t\", \"t_u\", t_u);\n                        // console.log(\"\\t\", \"inner:\", Mat.innerProduct(t_u, t_u_0, 2));\n                        // console.log(\"\\t\", \"h\", h);\n\n                        u = u0.slice(1);\n                        pathX.push(u[0]);\n                        pathY.push(u[1]);\n\n                        loop_closed = true;\n                        break;\n                    }\n\n                    // Gosper's loop detector\n                    if (this.config.loop_detection) {\n                        n = pathX.length - 1;\n                        // console.log(\"Check Gosper\", n);\n                        m = Math.floor(Mat.log2(n));\n\n                        for (i = 0; i <= m; i++) {\n                            dist = Geometry.distPointSegment(\n                                [1, u[0], u[1]],\n                                [1, pathX[T[i] - 1], pathY[T[i] - 1]],\n                                [1, pathX[T[i]], pathY[T[i]]]\n                            );\n\n                            if (dist < this.config.loop_dist * h) {\n                                // console.log(\"!!!!!!!!!!!!!!! GOSPER LOOP CLOSED !!!!\", i, n + 1,\n                                //     this.config.loop_dist * h\n                                // );\n\n                                t_v = this.tangent([pathX[T[i]], pathY[T[i]]]);\n                                if (Mat.innerProduct(t_u, t_v, 2) > this.config.loop_dir) {\n                                    // console.log(\"!!!!!!!!!!!!!!! angle is good enough\");\n                                    break;\n                                }\n                            }\n                        }\n                        if (i <= m) {\n                            loop_closed = true;\n                            break;\n                        }\n\n                        m = 1;\n                        e = 0;\n                        for (i = 0; i < 100; i++) {\n                            if ((n + 1) % m !== 0) {\n                                break;\n                            }\n                            m *= 2;\n                            e++;\n                        }\n                        // console.log(\"Add at e\", e);\n                        T[e] = n;\n                    }\n\n                }\n\n                // Predictor step\n                // if (true /*h < 2 * this.config.h_initial*/) {\n                // Euler\n                // console.log(\"euler\")\n                v[0] = u[0] + h * omega * t_u[0];\n                v[1] = u[1] + h * omega * t_u[1];\n                // } else {\n                //     // Heun\n                //     // console.log(\"heun\")\n                //     v[0] = u[0] + h * omega * t_u[0];\n                //     v[1] = u[1] + h * omega * t_u[1];\n\n                //     t_v = this.tangent(v);\n                //     v[0] = 0.5 * u[0] + 0.5 * (v[0] + h * omega * t_v[0]);\n                //     v[1] = 0.5 * u[1] + 0.5 * (v[1] + h * omega * t_v[1]);\n                // }\n                if (quasi) {\n                    A = this.updateA(A, u, v);\n                    v_start = v.slice();\n                }\n\n                // Corrector step: Newton\n                k = 0;\n                do {\n                    if (quasi) {\n                        grad = A;\n                    } else {\n                        grad = [this.dfx(v[0], v[1]), this.dfy(v[0], v[1])];\n                    }\n\n                    // Compute w = v - A(v) * f(v),\n                    // grad: row vector and A(v) is the Moore-Penrose inverse:\n                    // grad^T * (grad * grad^T)^(-1)\n                    denom = grad[0] * grad[0] + grad[1] * grad[1];\n                    nrm = this.f(v[0], v[1]) / denom;\n\n                    w[0] = v[0] - grad[0] * nrm;\n                    w[1] = v[1] - grad[1] * nrm;\n                    if (k === 0) {\n                        k0 = Math.abs(nrm) * Math.sqrt(denom);\n                    } else if (k === 1) {\n                        k1 = Math.abs(nrm) * Math.sqrt(denom);\n                    }\n\n                    v[0] = w[0];\n                    v[1] = w[1];\n                    k++;\n                } while (k < 20 &&\n                    Math.abs(this.f(v[0], v[1])) > this.config.tol_newton\n                );\n\n                delta = k0;\n                if (k > 1) {\n                    kappa = k1 / k0;\n                } else {\n                    kappa = 0.0;\n                }\n\n                if (quasi) {\n                    A = this.updateA(A, v_start, v);\n                    t_v = this.tangent_A(A);\n                } else {\n                    t_v = this.tangent(v);\n                }\n\n                dir = Mat.innerProduct(t_u, t_v, 2);\n                dir = Math.max(-1, Math.min(1, dir));\n                alpha = Math.acos(dir);\n\n                // Look for simple bifurcation points and cusps\n                cusp_or_bifurc = false;\n                progress = Geometry.distance(u, v, 2);\n                if (progress < this.config.tol_progress) {\n                    u = v.slice();\n                    pathX.push(u[0]);\n                    pathY.push(u[1]);\n                    // console.log(\"-> Bail out, no progress\", progress, steps);\n                    break;\n\n                } else if (dir < 0.0) {\n                    if (h > this.config.h_critical) {\n                        // console.log(\"Critical point at [\", u[0].toFixed(4), u[1].toFixed(4), \"], v: [\", v[0].toFixed(4), v[1].toFixed(4), \"], but large  h:\", h);\n\n                    } else {\n\n                        cusp_or_bifurc = true;\n                        if (this.isBifurcation(u, this.config.tol_cusp)) {\n                            // console.log(steps, \"bifurcation point between\", u, \"and\", v, \":\", dir, \"h\", h, \"alpha\", alpha);\n                            // A = [dfx(v[0], v[1]), dfy(v[0], v[1])];\n                            omega *= (-1);\n                            // If there is a bifurcation point, we\n                            // ignore the angle alpha for subsequent step length\n                            // adaption. Because then we might be able to\n                            // \"jump over the critical point\"\n                            alpha = 0;\n                        } else {\n                            // Cusp or something more weird\n                            u = v.slice();\n                            pathX.push(u[0]);\n                            pathY.push(u[1]);\n                            // console.log(\"-> Bail out, cusp\")\n                            break;\n                        }\n                    }\n                }\n\n                // Adapt stepwidth\n                if (!cusp_or_bifurc) {\n                    factor = Math.max(\n                        Math.sqrt(kappa / kappa_0),\n                        Math.sqrt(delta / delta_0),\n                        alpha / alpha_0\n                    );\n                    if (isNaN(factor)) {\n                        factor = 1;\n                    }\n                    factor = Math.max(Math.min(factor, 2), 0.5);\n                    h /= factor;\n                    h = Math.min(this.config.h_max, h);\n\n                    if (factor >= 2) {\n                        steps++;\n                        if (steps >= 3 * max_steps) {\n                            break;\n                        }\n\n                        point_added = false;\n                        continue;\n                    }\n                }\n\n                u = v.slice();\n                pathX.push(u[0]);\n                pathY.push(u[1]);\n                point_added = true;\n\n                steps++;\n            } while (\n                steps < max_steps &&\n                u[0] >= this.bbox[0] &&\n                u[1] <= this.bbox[1] &&\n                u[0] <= this.bbox[2] &&\n                u[1] >= this.bbox[3]\n            );\n\n            // if (!loop_closed) {\n            //     console.log(\"No loop\", steps);\n            // } else {\n            //     console.log(\"Loop\", steps);\n            // }\n\n            return [pathX, pathY, loop_closed];\n        },\n\n        /**\n         * If both eigenvalues of the Hessian are different from zero, the critical point at u\n         * is a simple bifurcation point.\n         *\n         * @param {Array} u Critical point [x, y]\n         * @param {Number} tol Tolerance of the eigenvalues to be zero.\n         * @returns Boolean True if the point is a simple bifurcation point.\n         * @private\n         */\n        isBifurcation: function (u, tol) {\n            // Former experiments:\n            // If the Hessian has exactly one zero eigenvalue,\n            // we claim that there is a cusp.\n            // Otherwise, we decide that there is a bifurcation point.\n            // In the latter case, if both eigenvalues are zero\n            // this is a somewhat crude decision.\n            //\n            var h = Mat.eps * Mat.eps * 100,\n                x, y, a, b, c, d, ad,\n                lbda1, lbda2,\n                dis;\n\n            x = u[0];\n            y = u[1];\n            a = 0.5 * (this.dfx(x + h, y) - this.dfx(x - h, y)) / h;\n            b = 0.5 * (this.dfx(x, y + h) - this.dfx(x, y - h)) / h;\n            c = 0.5 * (this.dfy(x + h, y) - this.dfy(x - h, y)) / h;\n            d = 0.5 * (this.dfy(x, y + h) - this.dfy(x, y - h)) / h;\n\n            // c = b\n            ad = a + d;\n            dis = ad * ad - 4 * (a * d - b * c);\n            lbda1 = 0.5 * (ad + Math.sqrt(dis));\n            lbda2 = 0.5 * (ad - Math.sqrt(dis));\n\n            // console.log(a, b, c, d)\n            // console.log(\"Eigenvals u:\", lbda1, lbda2, tol);\n\n            if (Math.abs(lbda1) > tol && Math.abs(lbda2) > tol) {\n                // if (lbda1 * lbda2 > 0) {\n                //     console.log(\"Seems to be isolated singularity at\", u);\n                // }\n                return true;\n            }\n\n            return false;\n        },\n\n        /**\n         * Search in an arc around a critical point for a further point on the curve.\n         * Unused for the moment.\n         *\n         * @param {Array} u Critical point [x, y]\n         * @param {Array} t_u Tangent at u\n         * @param {Number} r Radius\n         * @param {Number} omega angle\n         * @returns {Array} Coordinates [x, y] of a new point.\n         * @private\n         */\n        handleCriticalPoint: function (u, t_u, r, omega) {\n            var a = Math.atan2(omega * t_u[1], omega * t_u[0]),\n                // s = a - 0.75 * Math.PI,\n                // e = a + 0.75 * Math.PI,\n                f_circ = function (t) {\n                    var x = u[0] + r * Math.cos(t),\n                        y = u[1] + r * Math.sin(t);\n                    return this.f(x, y);\n                },\n                x, y, t0;\n\n            // t0 = Numerics.fzero(f_circ, [s, e]);\n            t0 = Numerics.root(f_circ, a);\n\n            x = u[0] + r * Math.cos(t0);\n            y = u[1] + r * Math.sin(t0);\n            // console.log(\"\\t\", \"result\", x, y, \"f\", f(x, y));\n\n            return [x, y];\n        },\n\n        /**\n         * Quasi-Newton update of the Moore-Penrose inverse.\n         * See (7.2.3) in Allgower, Georg.\n         *\n         * @param {Array} A\n         * @param {Array} u0\n         * @param {Array} u1\n         * @returns Array\n         * @private\n         */\n        updateA: function (A, u0, u1) {\n            var s = [u1[0] - u0[0], u1[1] - u0[1]],\n                y = this.f(u1[0], u1[1]) - this.f(u0[0], u0[1]),\n                nom, denom;\n\n            denom = s[0] * s[0] + s[1] * s[1];\n            nom = y - (A[0] * s[0] + A[1] * s[1]);\n            nom /= denom;\n            A[0] += nom * s[0];\n            A[1] += nom * s[1];\n\n            return A;\n        },\n\n        /**\n         * Approximate tangent (of norm 1) with Quasi-Newton method\n         * @param {Array} A\n         * @returns Array\n         * @private\n         */\n        tangent_A: function (A) {\n            var t = [-A[1], A[0]],\n                nrm = Mat.norm(t, 2);\n\n            if (nrm < Mat.eps) {\n                // console.log(\"Approx. Singularity\", t, \"is zero\", nrm);\n            }\n            return [t[0] / nrm, t[1] / nrm];\n        },\n\n        /**\n         * Tangent of norm 1 at point u.\n         * @param {Array} u Point [x, y]\n         * @returns Array\n         * @private\n         */\n        tangent: function (u) {\n            var t = [-this.dfy(u[0], u[1]), this.dfx(u[0], u[1])],\n                nrm = Mat.norm(t, 2);\n\n            if (nrm < Mat.eps * Mat.eps) {\n                // console.log(\"Singularity\", t, \"is zero\", \"at\", u, \":\", nrm);\n                return false;\n            }\n            return [t[0] / nrm, t[1] / nrm];\n        }\n    }\n\n);\n\nexport default Mat.ImplicitPlot;\n\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,OAAOA,IAAI,MAAM,eAAe;AAChC,OAAOC,GAAG,MAAM,QAAQ;AACxB,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,QAAQ,MAAM,QAAQ;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,GAAG,CAACI,YAAY,GAAG,UAAUC,IAAI,EAAEC,MAAM,EAAEC,CAAC,EAAEC,GAAG,EAAEC,GAAG,EAAE;EAEpD;EACA,IAAIC,WAAW,GAAG;IACdC,cAAc,EAAE,CAAC;IAAK;IACtBC,aAAa,EAAE,CAAC;IAAM;IACtBC,SAAS,EAAE,IAAI;IAAO;IACtBC,OAAO,EAAE,IAAI;IAAS;;IAEtBC,MAAM,EAAEf,GAAG,CAACgB,GAAG;IAAO;IACtBC,UAAU,EAAE,MAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}