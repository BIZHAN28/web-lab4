{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, document: true, Image: true, module: true, require: true */\n/*jslint nomen: true, plusplus: true, newcap:true*/\n\nimport JXG from \"../jxg\";\nimport AbstractRenderer from \"./abstract\";\nimport Const from \"../base/constants\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\nimport UUID from \"../utils/uuid\";\nimport Color from \"../utils/color\";\nimport Coords from \"../base/coords\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Numerics from \"../math/numerics\";\n// import $__canvas from \"canvas\";\n\n/**\n * Uses HTML Canvas to implement the rendering methods defined in {@link JXG.AbstractRenderer}.\n *\n * @class JXG.CanvasRenderer\n * @augments JXG.AbstractRenderer\n * @param {Node} container Reference to a DOM node containing the board.\n * @param {Object} dim The dimensions of the board\n * @param {Number} dim.width\n * @param {Number} dim.height\n * @see JXG.AbstractRenderer\n */\nJXG.CanvasRenderer = function (container, dim) {\n  this.type = \"canvas\";\n  this.canvasRoot = null;\n  this.suspendHandle = null;\n  this.canvasId = UUID.genUUID();\n  this.canvasNamespace = null;\n  if (Env.isBrowser) {\n    this.container = container;\n    this.container.style.MozUserSelect = \"none\";\n    this.container.style.userSelect = \"none\";\n    this.container.style.overflow = \"hidden\";\n    if (this.container.style.position === \"\") {\n      this.container.style.position = \"relative\";\n    }\n    this.container.innerHTML = ['<canvas id=\"', this.canvasId, '\" width=\"', dim.width, 'px\" height=\"', dim.height, 'px\"></canvas>'].join(\"\");\n    this.canvasRoot = this.container.ownerDocument.getElementById(this.canvasId);\n    this.canvasRoot.style.display = \"block\";\n    this.context = this.canvasRoot.getContext(\"2d\");\n  } else if (Env.isNode()) {\n    try {\n      this.canvasRoot = JXG.createCanvas(500, 500);\n      this.context = this.canvasRoot.getContext(\"2d\");\n    } catch (err) {\n      throw new Error('JXG.createCanvas not available.\\n' + 'Install the npm package `canvas`\\n' + 'and call:\\n' + '    import { createCanvas } from \"canvas\";\\n' + '    JXG.createCanvas = createCanvas;\\n');\n    }\n  }\n};\nJXG.CanvasRenderer.prototype = new AbstractRenderer();\nJXG.extend(JXG.CanvasRenderer.prototype, /** @lends JXG.CanvasRenderer.prototype */{\n  /* **************************\n   *   private methods only used\n   *   in this renderer. Should\n   *   not be called from outside.\n   * **************************/\n\n  /**\n   * Draws a filled polygon.\n   * @param {Array} shape A matrix presented by a two dimensional array of numbers.\n   * @see JXG.AbstractRenderer#drawArrows\n   * @private\n   */\n  _drawPolygon: function (shape, degree, doFill) {\n    var i,\n      len = shape.length,\n      context = this.context;\n    if (len > 0) {\n      if (doFill) {\n        context.lineWidth = 0;\n      }\n      context.beginPath();\n      context.moveTo(shape[0][0], shape[0][1]);\n      if (degree === 1) {\n        for (i = 1; i < len; i++) {\n          context.lineTo(shape[i][0], shape[i][1]);\n        }\n      } else {\n        for (i = 1; i < len; i += 3) {\n          context.bezierCurveTo(shape[i][0], shape[i][1], shape[i + 1][0], shape[i + 1][1], shape[i + 2][0], shape[i + 2][1]);\n        }\n      }\n      if (doFill) {\n        context.lineTo(shape[0][0], shape[0][1]);\n        context.closePath();\n        context.fill(\"evenodd\");\n      } else {\n        context.stroke();\n      }\n    }\n  },\n  /**\n   * Sets the fill color and fills an area.\n   * @param {JXG.GeometryElement} el An arbitrary JSXGraph element, preferably one with an area.\n   * @private\n   */\n  _fill: function (el) {\n    var context = this.context;\n    context.save();\n    if (this._setColor(el, \"fill\")) {\n      context.fill(\"evenodd\");\n    }\n    context.restore();\n  },\n  /**\n   * Rotates a point around <tt>(0, 0)</tt> by a given angle.\n   * @param {Number} angle An angle, given in rad.\n   * @param {Number} x X coordinate of the point.\n   * @param {Number} y Y coordinate of the point.\n   * @returns {Array} An array containing the x and y coordinate of the rotated point.\n   * @private\n   */\n  _rotatePoint: function (angle, x, y) {\n    return [x * Math.cos(angle) - y * Math.sin(angle), x * Math.sin(angle) + y * Math.cos(angle)];\n  },\n  /**\n   * Rotates an array of points around <tt>(0, 0)</tt>.\n   * @param {Array} shape An array of array of point coordinates.\n   * @param {Number} angle The angle in rad the points are rotated by.\n   * @returns {Array} Array of array of two dimensional point coordinates.\n   * @private\n   */\n  _rotateShape: function (shape, angle) {\n    var i,\n      rv = [],\n      len = shape.length;\n    if (len <= 0) {\n      return shape;\n    }\n    for (i = 0; i < len; i++) {\n      rv.push(this._rotatePoint(angle, shape[i][0], shape[i][1]));\n    }\n    return rv;\n  },\n  /**\n   * Set the gradient angle for linear color gradients.\n   *\n   * @private\n   * @param {JXG.GeometryElement} node An arbitrary JSXGraph element, preferably one with an area.\n   * @param {Number} radians angle value in radians. 0 is horizontal from left to right, Pi/4 is vertical from top to bottom.\n   */\n  updateGradientAngle: function (el, radians) {\n    // Angles:\n    // 0: ->\n    // 90: down\n    // 180: <-\n    // 90: up\n    var f = 1.0,\n      co = Math.cos(-radians),\n      si = Math.sin(-radians),\n      bb = el.getBoundingBox(),\n      c1,\n      c2,\n      x1,\n      x2,\n      y1,\n      y2,\n      x1s,\n      x2s,\n      y1s,\n      y2s,\n      dx,\n      dy;\n    if (Math.abs(co) > Math.abs(si)) {\n      f /= Math.abs(co);\n    } else {\n      f /= Math.abs(si);\n    }\n    if (co >= 0) {\n      x1 = 0;\n      x2 = co * f;\n    } else {\n      x1 = -co * f;\n      x2 = 0;\n    }\n    if (si >= 0) {\n      y1 = 0;\n      y2 = si * f;\n    } else {\n      y1 = -si * f;\n      y2 = 0;\n    }\n    c1 = new Coords(Const.COORDS_BY_USER, [bb[0], bb[1]], el.board);\n    c2 = new Coords(Const.COORDS_BY_USER, [bb[2], bb[3]], el.board);\n    dx = c2.scrCoords[1] - c1.scrCoords[1];\n    dy = c2.scrCoords[2] - c1.scrCoords[2];\n    x1s = c1.scrCoords[1] + dx * x1;\n    y1s = c1.scrCoords[2] + dy * y1;\n    x2s = c1.scrCoords[1] + dx * x2;\n    y2s = c1.scrCoords[2] + dy * y2;\n    return this.context.createLinearGradient(x1s, y1s, x2s, y2s);\n  },\n  /**\n   * Set circles for radial color gradients.\n   *\n   * @private\n   * @param {SVGnode} node SVG gradient node\n   * @param {Number} cx Canvas value x1 (but value between 0 and 1)\n   * @param {Number} cy  Canvas value y1 (but value between 0 and 1)\n   * @param {Number} r  Canvas value r1 (but value between 0 and 1)\n   * @param {Number} fx  Canvas value x0 (but value between 0 and 1)\n   * @param {Number} fy  Canvas value x1 (but value between 0 and 1)\n   * @param {Number} fr  Canvas value r0 (but value between 0 and 1)\n   */\n  updateGradientCircle: function (el, cx, cy, r, fx, fy, fr) {\n    var bb = el.getBoundingBox(),\n      c1,\n      c2,\n      cxs,\n      cys,\n      rs,\n      fxs,\n      fys,\n      frs,\n      dx,\n      dy;\n    c1 = new Coords(Const.COORDS_BY_USER, [bb[0], bb[1]], el.board);\n    c2 = new Coords(Const.COORDS_BY_USER, [bb[2], bb[3]], el.board);\n    dx = c2.scrCoords[1] - c1.scrCoords[1];\n    dy = c1.scrCoords[2] - c2.scrCoords[2];\n    cxs = c1.scrCoords[1] + dx * cx;\n    cys = c2.scrCoords[2] + dy * cy;\n    fxs = c1.scrCoords[1] + dx * fx;\n    fys = c2.scrCoords[2] + dy * fy;\n    rs = r * (dx + dy) * 0.5;\n    frs = fr * (dx + dy) * 0.5;\n    return this.context.createRadialGradient(fxs, fys, frs, cxs, cys, rs);\n  },\n  // documented in JXG.AbstractRenderer\n  updateGradient: function (el) {\n    var col,\n      // op,\n      ev_g = Type.evaluate(el.visProp.gradient),\n      gradient;\n\n    // op = Type.evaluate(el.visProp.fillopacity);\n    // op = op > 0 ? op : 0;\n    col = Type.evaluate(el.visProp.fillcolor);\n    if (ev_g === \"linear\") {\n      gradient = this.updateGradientAngle(el, Type.evaluate(el.visProp.gradientangle));\n    } else if (ev_g === \"radial\") {\n      gradient = this.updateGradientCircle(el, Type.evaluate(el.visProp.gradientcx), Type.evaluate(el.visProp.gradientcy), Type.evaluate(el.visProp.gradientr), Type.evaluate(el.visProp.gradientfx), Type.evaluate(el.visProp.gradientfy), Type.evaluate(el.visProp.gradientfr));\n    }\n    gradient.addColorStop(Type.evaluate(el.visProp.gradientstartoffset), col);\n    gradient.addColorStop(Type.evaluate(el.visProp.gradientendoffset), Type.evaluate(el.visProp.gradientsecondcolor));\n    return gradient;\n  },\n  /**\n   * Sets color and opacity for filling and stroking.\n   * type is the attribute from visProp and targetType the context[targetTypeStyle].\n   * This is necessary, because the fill style of a text is set by the stroke attributes of the text element.\n   * @param {JXG.GeometryElement} el Any JSXGraph element.\n   * @param {String} [type='stroke'] Either <em>fill</em> or <em>stroke</em>.\n   * @param {String} [targetType=type] (optional) Either <em>fill</em> or <em>stroke</em>.\n   * @returns {Boolean} If the color could be set, <tt>true</tt> is returned.\n   * @private\n   */\n  _setColor: function (el, type, targetType) {\n    var hasColor = true,\n      ev = el.visProp,\n      hl,\n      sw,\n      rgba,\n      rgbo,\n      c,\n      o,\n      oo,\n      grad;\n    type = type || \"stroke\";\n    targetType = targetType || type;\n    hl = this._getHighlighted(el);\n    grad = Type.evaluate(el.visProp.gradient);\n    if (grad === \"linear\" || grad === \"radial\") {\n      // TODO: opacity\n      this.context[targetType + \"Style\"] = this.updateGradient(el);\n      return hasColor;\n    }\n\n    // type is equal to 'fill' or 'stroke'\n    rgba = Type.evaluate(ev[hl + type + \"color\"]);\n    if (rgba !== \"none\" && rgba !== false) {\n      o = Type.evaluate(ev[hl + type + \"opacity\"]);\n      o = o > 0 ? o : 0;\n\n      // RGB, not RGBA\n      if (rgba.length !== 9) {\n        c = rgba;\n        oo = o;\n        // True RGBA, not RGB\n      } else {\n        rgbo = Color.rgba2rgbo(rgba);\n        c = rgbo[0];\n        oo = o * rgbo[1];\n      }\n      this.context.globalAlpha = oo;\n      this.context[targetType + \"Style\"] = c;\n    } else {\n      hasColor = false;\n    }\n    sw = parseFloat(Type.evaluate(ev[hl + \"strokewidth\"]));\n    if (type === \"stroke\" && !isNaN(sw)) {\n      if (sw === 0) {\n        this.context.globalAlpha = 0;\n      } else {\n        this.context.lineWidth = sw;\n      }\n    }\n    if (type === \"stroke\" && ev.linecap !== undefined && ev.linecap !== \"\") {\n      this.context.lineCap = ev.linecap;\n    }\n    return hasColor;\n  },\n  /**\n   * Sets color and opacity for drawing paths and lines and draws the paths and lines.\n   * @param {JXG.GeometryElement} el An JSXGraph element with a stroke.\n   * @private\n   */\n  _stroke: function (el) {\n    var context = this.context,\n      ev_dash = Type.evaluate(el.visProp.dash),\n      ds = Type.evaluate(el.visProp.dashscale),\n      sw = ds ? 0.5 * Type.evaluate(el.visProp.strokewidth) : 1;\n    context.save();\n    if (ev_dash > 0) {\n      if (context.setLineDash) {\n        context.setLineDash(\n        // sw could distinguish highlighting or not.\n        // But it seems to preferable to ignore this.\n        this.dashArray[ev_dash - 1].map(function (x) {\n          return x * sw;\n        }));\n      }\n    } else {\n      this.context.lineDashArray = [];\n    }\n    if (this._setColor(el, \"stroke\")) {\n      context.stroke();\n    }\n    context.restore();\n  },\n  /**\n   * Translates a set of points.\n   * @param {Array} shape An array of point coordinates.\n   * @param {Number} x Translation in X direction.\n   * @param {Number} y Translation in Y direction.\n   * @returns {Array} An array of translated point coordinates.\n   * @private\n   */\n  _translateShape: function (shape, x, y) {\n    var i,\n      rv = [],\n      len = shape.length;\n    if (len <= 0) {\n      return shape;\n    }\n    for (i = 0; i < len; i++) {\n      rv.push([shape[i][0] + x, shape[i][1] + y]);\n    }\n    return rv;\n  },\n  /* ******************************** *\n   *    Point drawing and updating    *\n   * ******************************** */\n\n  // documented in AbstractRenderer\n  drawPoint: function (el) {\n    var f = Type.evaluate(el.visProp.face),\n      size = Type.evaluate(el.visProp.size),\n      scr = el.coords.scrCoords,\n      sqrt32 = size * Math.sqrt(3) * 0.5,\n      s05 = size * 0.5,\n      stroke05 = parseFloat(Type.evaluate(el.visProp.strokewidth)) / 2.0,\n      context = this.context;\n    if (!el.visPropCalc.visible) {\n      return;\n    }\n    switch (f) {\n      case \"cross\": // x\n      case \"x\":\n        context.beginPath();\n        context.moveTo(scr[1] - size, scr[2] - size);\n        context.lineTo(scr[1] + size, scr[2] + size);\n        context.moveTo(scr[1] + size, scr[2] - size);\n        context.lineTo(scr[1] - size, scr[2] + size);\n        context.lineCap = \"round\";\n        context.lineJoin = \"round\";\n        context.closePath();\n        this._stroke(el);\n        break;\n      case \"circle\": // dot\n      case \"o\":\n        context.beginPath();\n        context.arc(scr[1], scr[2], size + 1 + stroke05, 0, 2 * Math.PI, false);\n        context.closePath();\n        this._fill(el);\n        this._stroke(el);\n        break;\n      case \"square\": // rectangle\n      case \"[]\":\n        if (size <= 0) {\n          break;\n        }\n        context.save();\n        if (this._setColor(el, \"stroke\", \"fill\")) {\n          context.fillRect(scr[1] - size - stroke05, scr[2] - size - stroke05, size * 2 + 3 * stroke05, size * 2 + 3 * stroke05);\n        }\n        context.restore();\n        context.save();\n        this._setColor(el, \"fill\");\n        context.fillRect(scr[1] - size + stroke05, scr[2] - size + stroke05, size * 2 - stroke05, size * 2 - stroke05);\n        context.restore();\n        break;\n      case \"plus\": // +\n      case \"+\":\n        context.beginPath();\n        context.moveTo(scr[1] - size, scr[2]);\n        context.lineTo(scr[1] + size, scr[2]);\n        context.moveTo(scr[1], scr[2] - size);\n        context.lineTo(scr[1], scr[2] + size);\n        context.lineCap = \"round\";\n        context.lineJoin = \"round\";\n        context.closePath();\n        this._stroke(el);\n        break;\n      case \"divide\":\n      case \"|\":\n        context.beginPath();\n        context.moveTo(scr[1], scr[2] - size);\n        context.lineTo(scr[1], scr[2] + size);\n        context.lineCap = \"round\";\n        context.lineJoin = \"round\";\n        context.closePath();\n        this._stroke(el);\n        break;\n      case \"minus\":\n      case \"-\":\n        context.beginPath();\n        context.moveTo(scr[1] - size, scr[2]);\n        context.lineTo(scr[1] + size, scr[2]);\n        context.lineCap = \"round\";\n        context.lineJoin = \"round\";\n        context.closePath();\n        this._stroke(el);\n        break;\n      /* eslint-disable no-fallthrough */\n      case \"diamond2\":\n      case \"<<>>\":\n        size *= 1.41;\n      case \"diamond\": // <>\n      case \"<>\":\n        context.beginPath();\n        context.moveTo(scr[1] - size, scr[2]);\n        context.lineTo(scr[1], scr[2] + size);\n        context.lineTo(scr[1] + size, scr[2]);\n        context.lineTo(scr[1], scr[2] - size);\n        context.closePath();\n        this._fill(el);\n        this._stroke(el);\n        break;\n      /* eslint-enable no-fallthrough */\n      case \"triangleup\":\n      case \"A\":\n      case \"a\":\n      case \"^\":\n        context.beginPath();\n        context.moveTo(scr[1], scr[2] - size);\n        context.lineTo(scr[1] - sqrt32, scr[2] + s05);\n        context.lineTo(scr[1] + sqrt32, scr[2] + s05);\n        context.closePath();\n        this._fill(el);\n        this._stroke(el);\n        break;\n      case \"triangledown\":\n      case \"v\":\n        context.beginPath();\n        context.moveTo(scr[1], scr[2] + size);\n        context.lineTo(scr[1] - sqrt32, scr[2] - s05);\n        context.lineTo(scr[1] + sqrt32, scr[2] - s05);\n        context.closePath();\n        this._fill(el);\n        this._stroke(el);\n        break;\n      case \"triangleleft\":\n      case \"<\":\n        context.beginPath();\n        context.moveTo(scr[1] - size, scr[2]);\n        context.lineTo(scr[1] + s05, scr[2] - sqrt32);\n        context.lineTo(scr[1] + s05, scr[2] + sqrt32);\n        context.closePath();\n        this._fill(el);\n        this._stroke(el);\n        break;\n      case \"triangleright\":\n      case \">\":\n        context.beginPath();\n        context.moveTo(scr[1] + size, scr[2]);\n        context.lineTo(scr[1] - s05, scr[2] - sqrt32);\n        context.lineTo(scr[1] - s05, scr[2] + sqrt32);\n        context.closePath();\n        this._fill(el);\n        this._stroke(el);\n        break;\n    }\n  },\n  // documented in AbstractRenderer\n  updatePoint: function (el) {\n    this.drawPoint(el);\n  },\n  /* ******************************** *\n   *           Lines                  *\n   * ******************************** */\n\n  /**\n   * Draws arrows of an element (usually a line) in canvas renderer.\n   * @param {JXG.GeometryElement} el Line to be drawn.\n   * @param {Array} scr1 Screen coordinates of the start position of the line or curve.\n   * @param {Array} scr2 Screen coordinates of the end position of the line or curve.\n   * @param {String} hl String which carries information if the element is highlighted. Used for getting the correct attribute.\n   * @private\n   */\n  drawArrows: function (el, scr1, scr2, hl, a) {\n    var x1,\n      y1,\n      x2,\n      y2,\n      w0,\n      w,\n      arrowHead,\n      arrowTail,\n      context = this.context,\n      size = 6,\n      type = 1,\n      type_fa,\n      type_la,\n      degree_fa = 1,\n      degree_la = 1,\n      doFill,\n      i,\n      len,\n      d1x,\n      d1y,\n      d2x,\n      d2y,\n      last,\n      ang1,\n      ang2,\n      ev_fa = a.evFirst,\n      ev_la = a.evLast;\n    if (Type.evaluate(el.visProp.strokecolor) !== \"none\" && (ev_fa || ev_la)) {\n      if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n        x1 = scr1.scrCoords[1];\n        y1 = scr1.scrCoords[2];\n        x2 = scr2.scrCoords[1];\n        y2 = scr2.scrCoords[2];\n        ang1 = ang2 = Math.atan2(y2 - y1, x2 - x1);\n      } else {\n        x1 = el.points[0].scrCoords[1];\n        y1 = el.points[0].scrCoords[2];\n        last = el.points.length - 1;\n        if (last < 1) {\n          // No arrows for curves consisting of 1 point\n          return;\n        }\n        x2 = el.points[el.points.length - 1].scrCoords[1];\n        y2 = el.points[el.points.length - 1].scrCoords[2];\n        d1x = el.points[1].scrCoords[1] - el.points[0].scrCoords[1];\n        d1y = el.points[1].scrCoords[2] - el.points[0].scrCoords[2];\n        d2x = el.points[last].scrCoords[1] - el.points[last - 1].scrCoords[1];\n        d2y = el.points[last].scrCoords[2] - el.points[last - 1].scrCoords[2];\n        if (ev_fa) {\n          ang1 = Math.atan2(d1y, d1x);\n        }\n        if (ev_la) {\n          ang2 = Math.atan2(d2y, d2x);\n        }\n      }\n      w0 = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n      if (ev_fa) {\n        size = a.sizeFirst;\n        w = w0 * size;\n        type = a.typeFirst;\n        type_fa = type;\n        if (type === 2) {\n          arrowTail = [[w, -w * 0.5], [0.0, 0.0], [w, w * 0.5], [w * 0.5, 0.0]];\n        } else if (type === 3) {\n          arrowTail = [[w / 3.0, -w * 0.5], [0.0, -w * 0.5], [0.0, w * 0.5], [w / 3.0, w * 0.5]];\n        } else if (type === 4) {\n          w /= 10;\n          degree_fa = 3;\n          arrowTail = [[10.0, 3.31], [6.47, 3.84], [2.87, 4.5], [0.0, 6.63], [0.67, 5.52], [1.33, 4.42], [2.0, 3.31], [1.33, 2.21], [0.67, 1.1], [0.0, 0.0], [2.87, 2.13], [6.47, 2.79], [10.0, 3.31]];\n          len = arrowTail.length;\n          for (i = 0; i < len; i++) {\n            arrowTail[i][0] *= -w;\n            arrowTail[i][1] *= w;\n            arrowTail[i][0] += 10 * w;\n            arrowTail[i][1] -= 3.31 * w;\n          }\n        } else if (type === 5) {\n          w /= 10;\n          degree_fa = 3;\n          arrowTail = [[10.0, 3.28], [6.61, 4.19], [3.19, 5.07], [0.0, 6.55], [0.62, 5.56], [1.0, 4.44], [1.0, 3.28], [1.0, 2.11], [0.62, 0.99], [0.0, 0.0], [3.19, 1.49], [6.61, 2.37], [10.0, 3.28]];\n          len = arrowTail.length;\n          for (i = 0; i < len; i++) {\n            arrowTail[i][0] *= -w;\n            arrowTail[i][1] *= w;\n            arrowTail[i][0] += 10 * w;\n            arrowTail[i][1] -= 3.28 * w;\n          }\n        } else if (type === 6) {\n          w /= 10;\n          degree_fa = 3;\n          arrowTail = [[10.0, 2.84], [6.61, 3.59], [3.21, 4.35], [0.0, 5.68], [0.33, 4.73], [0.67, 3.78], [1.0, 2.84], [0.67, 1.89], [0.33, 0.95], [0.0, 0.0], [3.21, 1.33], [6.61, 2.09], [10.0, 2.84]];\n          len = arrowTail.length;\n          for (i = 0; i < len; i++) {\n            arrowTail[i][0] *= -w;\n            arrowTail[i][1] *= w;\n            arrowTail[i][0] += 10 * w;\n            arrowTail[i][1] -= 2.84 * w;\n          }\n        } else if (type === 7) {\n          w = w0;\n          degree_fa = 3;\n          arrowTail = [[0.0, 10.39], [2.01, 6.92], [5.96, 5.2], [10.0, 5.2], [5.96, 5.2], [2.01, 3.47], [0.0, 0.0]];\n          len = arrowTail.length;\n          for (i = 0; i < len; i++) {\n            arrowTail[i][0] *= -w;\n            arrowTail[i][1] *= w;\n            arrowTail[i][0] += 10 * w;\n            arrowTail[i][1] -= 5.2 * w;\n          }\n        } else {\n          arrowTail = [[w, -w * 0.5], [0.0, 0.0], [w, w * 0.5]];\n        }\n      }\n      if (ev_la) {\n        size = a.sizeLast;\n        w = w0 * size;\n        type = a.typeLast;\n        type_la = type;\n        if (type === 2) {\n          arrowHead = [[-w, -w * 0.5], [0.0, 0.0], [-w, w * 0.5], [-w * 0.5, 0.0]];\n        } else if (type === 3) {\n          arrowHead = [[-w / 3.0, -w * 0.5], [0.0, -w * 0.5], [0.0, w * 0.5], [-w / 3.0, w * 0.5]];\n        } else if (type === 4) {\n          w /= 10;\n          degree_la = 3;\n          arrowHead = [[10.0, 3.31], [6.47, 3.84], [2.87, 4.5], [0.0, 6.63], [0.67, 5.52], [1.33, 4.42], [2.0, 3.31], [1.33, 2.21], [0.67, 1.1], [0.0, 0.0], [2.87, 2.13], [6.47, 2.79], [10.0, 3.31]];\n          len = arrowHead.length;\n          for (i = 0; i < len; i++) {\n            arrowHead[i][0] *= w;\n            arrowHead[i][1] *= w;\n            arrowHead[i][0] -= 10 * w;\n            arrowHead[i][1] -= 3.31 * w;\n          }\n        } else if (type === 5) {\n          w /= 10;\n          degree_la = 3;\n          arrowHead = [[10.0, 3.28], [6.61, 4.19], [3.19, 5.07], [0.0, 6.55], [0.62, 5.56], [1.0, 4.44], [1.0, 3.28], [1.0, 2.11], [0.62, 0.99], [0.0, 0.0], [3.19, 1.49], [6.61, 2.37], [10.0, 3.28]];\n          len = arrowHead.length;\n          for (i = 0; i < len; i++) {\n            arrowHead[i][0] *= w;\n            arrowHead[i][1] *= w;\n            arrowHead[i][0] -= 10 * w;\n            arrowHead[i][1] -= 3.28 * w;\n          }\n        } else if (type === 6) {\n          w /= 10;\n          degree_la = 3;\n          arrowHead = [[10.0, 2.84], [6.61, 3.59], [3.21, 4.35], [0.0, 5.68], [0.33, 4.73], [0.67, 3.78], [1.0, 2.84], [0.67, 1.89], [0.33, 0.95], [0.0, 0.0], [3.21, 1.33], [6.61, 2.09], [10.0, 2.84]];\n          len = arrowHead.length;\n          for (i = 0; i < len; i++) {\n            arrowHead[i][0] *= w;\n            arrowHead[i][1] *= w;\n            arrowHead[i][0] -= 10 * w;\n            arrowHead[i][1] -= 2.84 * w;\n          }\n        } else if (type === 7) {\n          w = w0;\n          degree_la = 3;\n          arrowHead = [[0.0, 10.39], [2.01, 6.92], [5.96, 5.2], [10.0, 5.2], [5.96, 5.2], [2.01, 3.47], [0.0, 0.0]];\n          len = arrowHead.length;\n          for (i = 0; i < len; i++) {\n            arrowHead[i][0] *= w;\n            arrowHead[i][1] *= w;\n            arrowHead[i][0] -= 10 * w;\n            arrowHead[i][1] -= 5.2 * w;\n          }\n        } else {\n          arrowHead = [[-w, -w * 0.5], [0.0, 0.0], [-w, w * 0.5]];\n        }\n      }\n      context.save();\n      if (this._setColor(el, \"stroke\", \"fill\")) {\n        this._setColor(el, \"stroke\");\n        if (ev_fa) {\n          if (type_fa === 7) {\n            doFill = false;\n          } else {\n            doFill = true;\n          }\n          this._drawPolygon(this._translateShape(this._rotateShape(arrowTail, ang1), x1, y1), degree_fa, doFill);\n        }\n        if (ev_la) {\n          if (type_la === 7) {\n            doFill = false;\n          } else {\n            doFill = true;\n          }\n          this._drawPolygon(this._translateShape(this._rotateShape(arrowHead, ang2), x2, y2), degree_la, doFill);\n        }\n      }\n      context.restore();\n    }\n  },\n  // documented in AbstractRenderer\n  drawLine: function (el) {\n    var c1_org,\n      c2_org,\n      c1 = new Coords(Const.COORDS_BY_USER, el.point1.coords.usrCoords, el.board),\n      c2 = new Coords(Const.COORDS_BY_USER, el.point2.coords.usrCoords, el.board),\n      margin = null,\n      hl,\n      w,\n      arrowData;\n    if (!el.visPropCalc.visible) {\n      return;\n    }\n    hl = this._getHighlighted(el);\n    w = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n    arrowData = this.getArrowHeadData(el, w, hl);\n    if (arrowData.evFirst || arrowData.evLast) {\n      margin = -4;\n    }\n    Geometry.calcStraight(el, c1, c2, margin);\n    this.handleTouchpoints(el, c1, c2, arrowData);\n    c1_org = new Coords(Const.COORDS_BY_USER, c1.usrCoords, el.board);\n    c2_org = new Coords(Const.COORDS_BY_USER, c2.usrCoords, el.board);\n    this.getPositionArrowHead(el, c1, c2, arrowData);\n    this.context.beginPath();\n    this.context.moveTo(c1.scrCoords[1], c1.scrCoords[2]);\n    this.context.lineTo(c2.scrCoords[1], c2.scrCoords[2]);\n    this._stroke(el);\n    if (arrowData.evFirst /* && obj.sFirst > 0*/ || arrowData.evLast /* && obj.sLast > 0*/) {\n      this.drawArrows(el, c1_org, c2_org, hl, arrowData);\n    }\n  },\n  // documented in AbstractRenderer\n  updateLine: function (el) {\n    this.drawLine(el);\n  },\n  // documented in AbstractRenderer\n  drawTicks: function () {\n    // this function is supposed to initialize the svg/vml nodes in the SVG/VMLRenderer.\n    // but in canvas there are no such nodes, hence we just do nothing and wait until\n    // updateTicks is called.\n  },\n  // documented in AbstractRenderer\n  updateTicks: function (ticks) {\n    var i,\n      c,\n      x,\n      y,\n      len = ticks.ticks.length,\n      len2,\n      j,\n      context = this.context;\n    context.beginPath();\n    for (i = 0; i < len; i++) {\n      c = ticks.ticks[i];\n      x = c[0];\n      y = c[1];\n\n      // context.moveTo(x[0], y[0]);\n      // context.lineTo(x[1], y[1]);\n      len2 = x.length;\n      context.moveTo(x[0], y[0]);\n      for (j = 1; j < len2; ++j) {\n        context.lineTo(x[j], y[j]);\n      }\n    }\n    // Labels\n    // for (i = 0; i < len; i++) {\n    //     c = ticks.ticks[i].scrCoords;\n    //     if (ticks.ticks[i].major &&\n    //             (ticks.board.needsFullUpdate || ticks.needsRegularUpdate) &&\n    //             ticks.labels[i] &&\n    //             ticks.labels[i].visPropCalc.visible) {\n    //         this.updateText(ticks.labels[i]);\n    //     }\n    // }\n    context.lineCap = \"round\";\n    this._stroke(ticks);\n  },\n  /* **************************\n   *    Curves\n   * **************************/\n\n  // documented in AbstractRenderer\n  drawCurve: function (el) {\n    var hl, w, arrowData;\n    if (Type.evaluate(el.visProp.handdrawing)) {\n      this.updatePathStringBezierPrim(el);\n    } else {\n      this.updatePathStringPrim(el);\n    }\n    if (el.numberPoints > 1) {\n      hl = this._getHighlighted(el);\n      w = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n      arrowData = this.getArrowHeadData(el, w, hl);\n      if (arrowData.evFirst /* && obj.sFirst > 0*/ || arrowData.evLast /* && obj.sLast > 0*/) {\n        this.drawArrows(el, null, null, hl, arrowData);\n      }\n    }\n  },\n  // documented in AbstractRenderer\n  updateCurve: function (el) {\n    this.drawCurve(el);\n  },\n  /* **************************\n   *    Circle related stuff\n   * **************************/\n\n  // documented in AbstractRenderer\n  drawEllipse: function (el) {\n    var m1 = el.center.coords.scrCoords[1],\n      m2 = el.center.coords.scrCoords[2],\n      sX = el.board.unitX,\n      sY = el.board.unitY,\n      rX = 2 * el.Radius(),\n      rY = 2 * el.Radius(),\n      aWidth = rX * sX,\n      aHeight = rY * sY,\n      aX = m1 - aWidth / 2,\n      aY = m2 - aHeight / 2,\n      hB = aWidth / 2 * 0.5522848,\n      vB = aHeight / 2 * 0.5522848,\n      eX = aX + aWidth,\n      eY = aY + aHeight,\n      mX = aX + aWidth / 2,\n      mY = aY + aHeight / 2,\n      context = this.context;\n    if (rX > 0.0 && rY > 0.0 && !isNaN(m1 + m2)) {\n      context.beginPath();\n      context.moveTo(aX, mY);\n      context.bezierCurveTo(aX, mY - vB, mX - hB, aY, mX, aY);\n      context.bezierCurveTo(mX + hB, aY, eX, mY - vB, eX, mY);\n      context.bezierCurveTo(eX, mY + vB, mX + hB, eY, mX, eY);\n      context.bezierCurveTo(mX - hB, eY, aX, mY + vB, aX, mY);\n      context.closePath();\n      this._fill(el);\n      this._stroke(el);\n    }\n  },\n  // documented in AbstractRenderer\n  updateEllipse: function (el) {\n    return this.drawEllipse(el);\n  },\n  /* **************************\n   *    Polygon\n   * **************************/\n\n  // nothing here, using AbstractRenderer implementations\n\n  /* **************************\n   *    Text related stuff\n   * **************************/\n\n  // Already documented in JXG.AbstractRenderer\n  displayCopyright: function (str, fontSize) {\n    var context = this.context;\n\n    // this should be called on EVERY update, otherwise it won't be shown after the first update\n    context.save();\n    context.font = fontSize + \"px Arial\";\n    context.fillStyle = \"#aaa\";\n    context.lineWidth = 0.5;\n    context.fillText(str, 10, 2 + fontSize);\n    context.restore();\n  },\n  // Already documented in JXG.AbstractRenderer\n  drawInternalText: function (el) {\n    var ev_fs = Type.evaluate(el.visProp.fontsize),\n      fontUnit = Type.evaluate(el.visProp.fontunit),\n      ev_ax = el.getAnchorX(),\n      ev_ay = el.getAnchorY(),\n      context = this.context;\n    context.save();\n    if (this._setColor(el, \"stroke\", \"fill\") && !isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])) {\n      context.font = (ev_fs > 0 ? ev_fs : 0) + fontUnit + \" Arial\";\n      this.transformImage(el, el.transformations);\n      if (ev_ax === \"left\") {\n        context.textAlign = \"left\";\n      } else if (ev_ax === \"right\") {\n        context.textAlign = \"right\";\n      } else if (ev_ax === \"middle\") {\n        context.textAlign = \"center\";\n      }\n      if (ev_ay === \"bottom\") {\n        context.textBaseline = \"bottom\";\n      } else if (ev_ay === \"top\") {\n        context.textBaseline = \"top\";\n      } else if (ev_ay === \"middle\") {\n        context.textBaseline = \"middle\";\n      }\n      context.fillText(el.plaintext, el.coords.scrCoords[1], el.coords.scrCoords[2]);\n    }\n    context.restore();\n    return null;\n  },\n  // Already documented in JXG.AbstractRenderer\n  updateInternalText: function (el) {\n    this.drawInternalText(el);\n  },\n  // documented in JXG.AbstractRenderer\n  // Only necessary for texts\n  setObjectStrokeColor: function (el, color, opacity) {\n    var rgba = Type.evaluate(color),\n      c,\n      rgbo,\n      o = Type.evaluate(opacity),\n      oo,\n      node;\n    o = o > 0 ? o : 0;\n    if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {\n      return;\n    }\n\n    // Check if this could be merged with _setColor\n\n    if (Type.exists(rgba) && rgba !== false) {\n      // RGB, not RGBA\n      if (rgba.length !== 9) {\n        c = rgba;\n        oo = o;\n        // True RGBA, not RGB\n      } else {\n        rgbo = Color.rgba2rgbo(rgba);\n        c = rgbo[0];\n        oo = o * rgbo[1];\n      }\n      node = el.rendNode;\n      if (el.elementClass === Const.OBJECT_CLASS_TEXT && Type.evaluate(el.visProp.display) === \"html\") {\n        node.style.color = c;\n        node.style.opacity = oo;\n      }\n    }\n    el.visPropOld.strokecolor = rgba;\n    el.visPropOld.strokeopacity = o;\n  },\n  /* **************************\n   *    Image related stuff\n   * **************************/\n\n  // Already documented in JXG.AbstractRenderer\n  drawImage: function (el) {\n    el.rendNode = new Image();\n    // Store the file name of the image.\n    // Before, this was done in el.rendNode.src\n    // But there, the file name is expanded to\n    // the full url. This may be different from\n    // the url computed in updateImageURL().\n    el._src = \"\";\n    this.updateImage(el);\n  },\n  // Already documented in JXG.AbstractRenderer\n  updateImage: function (el) {\n    var context = this.context,\n      o = Type.evaluate(el.visProp.fillopacity),\n      paintImg = Type.bind(function () {\n        el.imgIsLoaded = true;\n        if (el.size[0] <= 0 || el.size[1] <= 0) {\n          return;\n        }\n        context.save();\n        context.globalAlpha = o;\n        // If det(el.transformations)=0, FireFox 3.6. breaks down.\n        // This is tested in transformImage\n        this.transformImage(el, el.transformations);\n        context.drawImage(el.rendNode, el.coords.scrCoords[1], el.coords.scrCoords[2] - el.size[1], el.size[0], el.size[1]);\n        context.restore();\n      }, this);\n    if (this.updateImageURL(el)) {\n      el.rendNode.onload = paintImg;\n    } else {\n      if (el.imgIsLoaded) {\n        paintImg();\n      }\n    }\n  },\n  // Already documented in JXG.AbstractRenderer\n  transformImage: function (el, t) {\n    var m,\n      s,\n      cx,\n      cy,\n      node,\n      len = t.length,\n      ctx = this.context;\n    if (len > 0) {\n      m = this.joinTransforms(el, t);\n      if (el.elementClass === Const.OBJECT_CLASS_TEXT && el.visProp.display === 'html') {\n        s = \" matrix(\" + [m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]].join(\",\") + \") \";\n        if (s.indexOf('NaN') === -1) {\n          node = el.rendNode;\n          node.style.transform = s;\n          cx = -el.coords.scrCoords[1];\n          cy = -el.coords.scrCoords[2];\n          switch (Type.evaluate(el.visProp.anchorx)) {\n            case 'right':\n              cx += el.size[0];\n              break;\n            case 'middle':\n              cx += el.size[0] * 0.5;\n              break;\n          }\n          switch (Type.evaluate(el.visProp.anchory)) {\n            case 'bottom':\n              cy += el.size[1];\n              break;\n            case 'middle':\n              cy += el.size[1] * 0.5;\n              break;\n          }\n          node.style['transform-origin'] = cx + 'px ' + cy + 'px';\n        }\n      } else {\n        if (Math.abs(Numerics.det(m)) >= Mat.eps) {\n          ctx.transform(m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]);\n        }\n      }\n    }\n  },\n  // Already documented in JXG.AbstractRenderer\n  updateImageURL: function (el) {\n    var url;\n    url = Type.evaluate(el.url);\n    if (el._src !== url) {\n      el.imgIsLoaded = false;\n      el.rendNode.src = url;\n      el._src = url;\n      return true;\n    }\n    return false;\n  },\n  /* **************************\n   * Render primitive objects\n   * **************************/\n\n  // documented in AbstractRenderer\n  remove: function (shape) {\n    // sounds odd for a pixel based renderer but we need this for html texts\n    if (Type.exists(shape) && Type.exists(shape.parentNode)) {\n      shape.parentNode.removeChild(shape);\n    }\n  },\n  // documented in AbstractRenderer\n  updatePathStringPrim: function (el) {\n    var i,\n      scr,\n      scr1,\n      scr2,\n      len,\n      symbm = \"M\",\n      symbl = \"L\",\n      symbc = \"C\",\n      nextSymb = symbm,\n      maxSize = 5000.0,\n      context = this.context;\n    if (el.numberPoints <= 0) {\n      return;\n    }\n    len = Math.min(el.points.length, el.numberPoints);\n    context.beginPath();\n    if (el.bezierDegree === 1) {\n      /*\n      if (isNotPlot && el.board.options.curve.RDPsmoothing) {\n          el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);\n      }\n      */\n\n      for (i = 0; i < len; i++) {\n        scr = el.points[i].scrCoords;\n        if (isNaN(scr[1]) || isNaN(scr[2])) {\n          // PenUp\n          nextSymb = symbm;\n        } else {\n          // Chrome has problems with values  being too far away.\n          if (scr[1] > maxSize) {\n            scr[1] = maxSize;\n          } else if (scr[1] < -maxSize) {\n            scr[1] = -maxSize;\n          }\n          if (scr[2] > maxSize) {\n            scr[2] = maxSize;\n          } else if (scr[2] < -maxSize) {\n            scr[2] = -maxSize;\n          }\n          if (nextSymb === symbm) {\n            context.moveTo(scr[1], scr[2]);\n          } else {\n            context.lineTo(scr[1], scr[2]);\n          }\n          nextSymb = symbl;\n        }\n      }\n    } else if (el.bezierDegree === 3) {\n      i = 0;\n      while (i < len) {\n        scr = el.points[i].scrCoords;\n        if (isNaN(scr[1]) || isNaN(scr[2])) {\n          // PenUp\n          nextSymb = symbm;\n        } else {\n          if (nextSymb === symbm) {\n            context.moveTo(scr[1], scr[2]);\n          } else {\n            i += 1;\n            scr1 = el.points[i].scrCoords;\n            i += 1;\n            scr2 = el.points[i].scrCoords;\n            context.bezierCurveTo(scr[1], scr[2], scr1[1], scr1[2], scr2[1], scr2[2]);\n          }\n          nextSymb = symbc;\n        }\n        i += 1;\n      }\n    }\n    context.lineCap = \"round\";\n    this._fill(el);\n    this._stroke(el);\n  },\n  // Already documented in JXG.AbstractRenderer\n  updatePathStringBezierPrim: function (el) {\n    var i,\n      j,\n      k,\n      scr,\n      lx,\n      ly,\n      len,\n      symbm = \"M\",\n      symbl = \"C\",\n      nextSymb = symbm,\n      maxSize = 5000.0,\n      f = Type.evaluate(el.visProp.strokewidth),\n      isNoPlot = Type.evaluate(el.visProp.curvetype) !== \"plot\",\n      context = this.context;\n    if (el.numberPoints <= 0) {\n      return;\n    }\n    if (isNoPlot && el.board.options.curve.RDPsmoothing) {\n      el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);\n    }\n    len = Math.min(el.points.length, el.numberPoints);\n    context.beginPath();\n    for (j = 1; j < 3; j++) {\n      nextSymb = symbm;\n      for (i = 0; i < len; i++) {\n        scr = el.points[i].scrCoords;\n        if (isNaN(scr[1]) || isNaN(scr[2])) {\n          // PenUp\n          nextSymb = symbm;\n        } else {\n          // Chrome has problems with values being too far away.\n          if (scr[1] > maxSize) {\n            scr[1] = maxSize;\n          } else if (scr[1] < -maxSize) {\n            scr[1] = -maxSize;\n          }\n          if (scr[2] > maxSize) {\n            scr[2] = maxSize;\n          } else if (scr[2] < -maxSize) {\n            scr[2] = -maxSize;\n          }\n          if (nextSymb === symbm) {\n            context.moveTo(scr[1], scr[2]);\n          } else {\n            k = 2 * j;\n            context.bezierCurveTo(lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j), ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j), lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j), ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j), scr[1], scr[2]);\n          }\n          nextSymb = symbl;\n          lx = scr[1];\n          ly = scr[2];\n        }\n      }\n    }\n    context.lineCap = \"round\";\n    this._fill(el);\n    this._stroke(el);\n  },\n  // documented in AbstractRenderer\n  updatePolygonPrim: function (node, el) {\n    var scrCoords,\n      i,\n      j,\n      len = el.vertices.length,\n      context = this.context,\n      isReal = true;\n    if (len <= 0 || !el.visPropCalc.visible) {\n      return;\n    }\n    if (el.elType === \"polygonalchain\") {\n      len++;\n    }\n    context.beginPath();\n    i = 0;\n    while (!el.vertices[i].isReal && i < len - 1) {\n      i++;\n      isReal = false;\n    }\n    scrCoords = el.vertices[i].coords.scrCoords;\n    context.moveTo(scrCoords[1], scrCoords[2]);\n    for (j = i; j < len - 1; j++) {\n      if (!el.vertices[j].isReal) {\n        isReal = false;\n      }\n      scrCoords = el.vertices[j].coords.scrCoords;\n      context.lineTo(scrCoords[1], scrCoords[2]);\n    }\n    context.closePath();\n    if (isReal) {\n      this._fill(el); // The edges of a polygon are displayed separately (as segments).\n    }\n  },\n  // **************************  Set Attributes *************************\n\n  // Already documented in JXG.AbstractRenderer\n  display: function (el, val) {\n    if (el && el.rendNode) {\n      el.visPropOld.visible = val;\n      if (val) {\n        el.rendNode.style.visibility = \"inherit\";\n      } else {\n        el.rendNode.style.visibility = \"hidden\";\n      }\n    }\n  },\n  // documented in AbstractRenderer\n  show: function (el) {\n    JXG.deprecated(\"Board.renderer.show()\", \"Board.renderer.display()\");\n    if (Type.exists(el.rendNode)) {\n      el.rendNode.style.visibility = \"inherit\";\n    }\n  },\n  // documented in AbstractRenderer\n  hide: function (el) {\n    JXG.deprecated(\"Board.renderer.hide()\", \"Board.renderer.display()\");\n    if (Type.exists(el.rendNode)) {\n      el.rendNode.style.visibility = \"hidden\";\n    }\n  },\n  // documented in AbstractRenderer\n  setGradient: function (el) {\n    // var // col,\n    //     op;\n\n    // op = Type.evaluate(el.visProp.fillopacity);\n    // op = op > 0 ? op : 0;\n\n    // col = Type.evaluate(el.visProp.fillcolor);\n  },\n  // documented in AbstractRenderer\n  setShadow: function (el) {\n    if (el.visPropOld.shadow === el.visProp.shadow) {\n      return;\n    }\n\n    // not implemented yet\n    // we simply have to redraw the element\n    // probably the best way to do so would be to call el.updateRenderer(), i think.\n\n    el.visPropOld.shadow = el.visProp.shadow;\n  },\n  // documented in AbstractRenderer\n  highlight: function (obj) {\n    if (obj.elementClass === Const.OBJECT_CLASS_TEXT && Type.evaluate(obj.visProp.display) === \"html\") {\n      this.updateTextStyle(obj, true);\n    } else {\n      obj.board.prepareUpdate();\n      obj.board.renderer.suspendRedraw(obj.board);\n      obj.board.updateRenderer();\n      obj.board.renderer.unsuspendRedraw();\n    }\n    return this;\n  },\n  // documented in AbstractRenderer\n  noHighlight: function (obj) {\n    if (obj.elementClass === Const.OBJECT_CLASS_TEXT && Type.evaluate(obj.visProp.display) === \"html\") {\n      this.updateTextStyle(obj, false);\n    } else {\n      obj.board.prepareUpdate();\n      obj.board.renderer.suspendRedraw(obj.board);\n      obj.board.updateRenderer();\n      obj.board.renderer.unsuspendRedraw();\n    }\n    return this;\n  },\n  /* **************************\n   * renderer control\n   * **************************/\n\n  // documented in AbstractRenderer\n  suspendRedraw: function (board) {\n    this.context.save();\n    this.context.clearRect(0, 0, this.canvasRoot.width, this.canvasRoot.height);\n    if (board && board.attr.showcopyright) {\n      this.displayCopyright(JXG.licenseText, 12);\n    }\n  },\n  // documented in AbstractRenderer\n  unsuspendRedraw: function () {\n    this.context.restore();\n  },\n  // document in AbstractRenderer\n  resize: function (w, h) {\n    if (this.container) {\n      this.canvasRoot.style.width = parseFloat(w) + \"px\";\n      this.canvasRoot.style.height = parseFloat(h) + \"px\";\n      this.canvasRoot.setAttribute(\"width\", 2 * parseFloat(w) + \"px\");\n      this.canvasRoot.setAttribute(\"height\", 2 * parseFloat(h) + \"px\");\n    } else {\n      this.canvasRoot.width = 2 * parseFloat(w);\n      this.canvasRoot.height = 2 * parseFloat(h);\n    }\n    this.context = this.canvasRoot.getContext(\"2d\");\n    // The width and height of the canvas is set to twice the CSS values,\n    // followed by an appropriate scaling.\n    // See https://stackoverflow.com/questions/22416462/canvas-element-with-blurred-lines\n    this.context.scale(2, 2);\n  },\n  removeToInsertLater: function () {\n    return function () {};\n  }\n});\nexport default JXG.CanvasRenderer;","map":{"version":3,"names":["JXG","AbstractRenderer","Const","Env","Type","UUID","Color","Coords","Mat","Geometry","Numerics","CanvasRenderer","container","dim","type","canvasRoot","suspendHandle","canvasId","genUUID","canvasNamespace","isBrowser","style","MozUserSelect","userSelect","overflow","position","innerHTML","width","height","join","ownerDocument","getElementById","display","context","getContext","isNode","createCanvas","err","Error","prototype","extend","_drawPolygon","shape","degree","doFill","i","len","length","lineWidth","beginPath","moveTo","lineTo","bezierCurveTo","closePath","fill","stroke","_fill","el","save","_setColor","restore","_rotatePoint","angle","x","y","Math","cos","sin","_rotateShape","rv","push","updateGradientAngle","radians","f","co","si","bb","getBoundingBox","c1","c2","x1","x2","y1","y2","x1s","x2s","y1s","y2s","dx","dy","abs","COORDS_BY_USER","board","scrCoords","createLinearGradient","updateGradientCircle","cx","cy","r","fx","fy","fr","cxs","cys","rs","fxs","fys","frs","createRadialGradient","updateGradient","col","ev_g","evaluate","visProp","gradient","fillcolor","gradientangle","gradientcx","gradientcy","gradientr","gradientfx","gradientfy","gradientfr","addColorStop","gradientstartoffset","gradientendoffset","gradientsecondcolor","targetType","hasColor","ev","hl","sw","rgba","rgbo","c","o","oo","grad","_getHighlighted","rgba2rgbo","globalAlpha","parseFloat","isNaN","linecap","undefined","lineCap","_stroke","ev_dash","dash","ds","dashscale","strokewidth","setLineDash","dashArray","map","lineDashArray","_translateShape","drawPoint","face","size","scr","coords","sqrt32","sqrt","s05","stroke05","visPropCalc","visible","lineJoin","arc","PI","fillRect","updatePoint","drawArrows","scr1","scr2","a","w0","w","arrowHead","arrowTail","type_fa","type_la","degree_fa","degree_la","d1x","d1y","d2x","d2y","last","ang1","ang2","ev_fa","evFirst","ev_la","evLast","strokecolor","elementClass","OBJECT_CLASS_LINE","atan2","points","sizeFirst","typeFirst","sizeLast","typeLast","drawLine","c1_org","c2_org","point1","usrCoords","point2","margin","arrowData","getArrowHeadData","calcStraight","handleTouchpoints","getPositionArrowHead","updateLine","drawTicks","updateTicks","ticks","len2","j","drawCurve","handdrawing","updatePathStringBezierPrim","updatePathStringPrim","numberPoints","updateCurve","drawEllipse","m1","center","m2","sX","unitX","sY","unitY","rX","Radius","rY","aWidth","aHeight","aX","aY","hB","vB","eX","eY","mX","mY","updateEllipse","displayCopyright","str","fontSize","font","fillStyle","fillText","drawInternalText","ev_fs","fontsize","fontUnit","fontunit","ev_ax","getAnchorX","ev_ay","getAnchorY","transformImage","transformations","textAlign","textBaseline","plaintext","updateInternalText","setObjectStrokeColor","color","opacity","node","visPropOld","strokeopacity","exists","rendNode","OBJECT_CLASS_TEXT","drawImage","Image","_src","updateImage","fillopacity","paintImg","bind","imgIsLoaded","updateImageURL","onload","t","m","s","ctx","joinTransforms","indexOf","transform","anchorx","anchory","det","eps","url","src","remove","parentNode","removeChild","symbm","symbl","symbc","nextSymb","maxSize","min","bezierDegree","k","lx","ly","isNoPlot","curvetype","options","curve","RDPsmoothing","RamerDouglasPeucker","random","updatePolygonPrim","vertices","isReal","elType","val","visibility","show","deprecated","hide","setGradient","setShadow","shadow","highlight","obj","updateTextStyle","prepareUpdate","renderer","suspendRedraw","updateRenderer","unsuspendRedraw","noHighlight","clearRect","attr","showcopyright","licenseText","resize","h","setAttribute","scale","removeToInsertLater"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/renderer/canvas.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, document: true, Image: true, module: true, require: true */\n/*jslint nomen: true, plusplus: true, newcap:true*/\n\nimport JXG from \"../jxg\";\nimport AbstractRenderer from \"./abstract\";\nimport Const from \"../base/constants\";\nimport Env from \"../utils/env\";\nimport Type from \"../utils/type\";\nimport UUID from \"../utils/uuid\";\nimport Color from \"../utils/color\";\nimport Coords from \"../base/coords\";\nimport Mat from \"../math/math\";\nimport Geometry from \"../math/geometry\";\nimport Numerics from \"../math/numerics\";\n// import $__canvas from \"canvas\";\n\n/**\n * Uses HTML Canvas to implement the rendering methods defined in {@link JXG.AbstractRenderer}.\n *\n * @class JXG.CanvasRenderer\n * @augments JXG.AbstractRenderer\n * @param {Node} container Reference to a DOM node containing the board.\n * @param {Object} dim The dimensions of the board\n * @param {Number} dim.width\n * @param {Number} dim.height\n * @see JXG.AbstractRenderer\n */\nJXG.CanvasRenderer = function (container, dim) {\n    this.type = \"canvas\";\n\n    this.canvasRoot = null;\n    this.suspendHandle = null;\n    this.canvasId = UUID.genUUID();\n\n    this.canvasNamespace = null;\n\n    if (Env.isBrowser) {\n        this.container = container;\n        this.container.style.MozUserSelect = \"none\";\n        this.container.style.userSelect = \"none\";\n\n        this.container.style.overflow = \"hidden\";\n        if (this.container.style.position === \"\") {\n            this.container.style.position = \"relative\";\n        }\n\n        this.container.innerHTML = [\n            '<canvas id=\"', this.canvasId, '\" width=\"', dim.width, 'px\" height=\"', dim.height, 'px\"></canvas>'\n        ].join(\"\");\n        this.canvasRoot = this.container.ownerDocument.getElementById(this.canvasId);\n        this.canvasRoot.style.display = \"block\";\n        this.context = this.canvasRoot.getContext(\"2d\");\n    } else if (Env.isNode()) {\n        try {\n            this.canvasRoot = JXG.createCanvas(500, 500);\n            this.context = this.canvasRoot.getContext(\"2d\");\n        } catch (err) {\n            throw new Error('JXG.createCanvas not available.\\n' +\n                'Install the npm package `canvas`\\n' +\n                'and call:\\n' +\n                '    import { createCanvas } from \"canvas\";\\n' +\n                '    JXG.createCanvas = createCanvas;\\n');\n        }\n    }\n};\n\nJXG.CanvasRenderer.prototype = new AbstractRenderer();\n\nJXG.extend(\n    JXG.CanvasRenderer.prototype,\n    /** @lends JXG.CanvasRenderer.prototype */ {\n        /* **************************\n         *   private methods only used\n         *   in this renderer. Should\n         *   not be called from outside.\n         * **************************/\n\n        /**\n         * Draws a filled polygon.\n         * @param {Array} shape A matrix presented by a two dimensional array of numbers.\n         * @see JXG.AbstractRenderer#drawArrows\n         * @private\n         */\n        _drawPolygon: function (shape, degree, doFill) {\n            var i,\n                len = shape.length,\n                context = this.context;\n\n            if (len > 0) {\n                if (doFill) {\n                    context.lineWidth = 0;\n                }\n                context.beginPath();\n                context.moveTo(shape[0][0], shape[0][1]);\n                if (degree === 1) {\n                    for (i = 1; i < len; i++) {\n                        context.lineTo(shape[i][0], shape[i][1]);\n                    }\n                } else {\n                    for (i = 1; i < len; i += 3) {\n                        context.bezierCurveTo(\n                            shape[i][0],\n                            shape[i][1],\n                            shape[i + 1][0],\n                            shape[i + 1][1],\n                            shape[i + 2][0],\n                            shape[i + 2][1]\n                        );\n                    }\n                }\n                if (doFill) {\n                    context.lineTo(shape[0][0], shape[0][1]);\n                    context.closePath();\n                    context.fill(\"evenodd\");\n                } else {\n                    context.stroke();\n                }\n            }\n        },\n\n        /**\n         * Sets the fill color and fills an area.\n         * @param {JXG.GeometryElement} el An arbitrary JSXGraph element, preferably one with an area.\n         * @private\n         */\n        _fill: function (el) {\n            var context = this.context;\n\n            context.save();\n            if (this._setColor(el, \"fill\")) {\n                context.fill(\"evenodd\");\n            }\n            context.restore();\n        },\n\n        /**\n         * Rotates a point around <tt>(0, 0)</tt> by a given angle.\n         * @param {Number} angle An angle, given in rad.\n         * @param {Number} x X coordinate of the point.\n         * @param {Number} y Y coordinate of the point.\n         * @returns {Array} An array containing the x and y coordinate of the rotated point.\n         * @private\n         */\n        _rotatePoint: function (angle, x, y) {\n            return [\n                x * Math.cos(angle) - y * Math.sin(angle),\n                x * Math.sin(angle) + y * Math.cos(angle)\n            ];\n        },\n\n        /**\n         * Rotates an array of points around <tt>(0, 0)</tt>.\n         * @param {Array} shape An array of array of point coordinates.\n         * @param {Number} angle The angle in rad the points are rotated by.\n         * @returns {Array} Array of array of two dimensional point coordinates.\n         * @private\n         */\n        _rotateShape: function (shape, angle) {\n            var i,\n                rv = [],\n                len = shape.length;\n\n            if (len <= 0) {\n                return shape;\n            }\n\n            for (i = 0; i < len; i++) {\n                rv.push(this._rotatePoint(angle, shape[i][0], shape[i][1]));\n            }\n\n            return rv;\n        },\n\n        /**\n         * Set the gradient angle for linear color gradients.\n         *\n         * @private\n         * @param {JXG.GeometryElement} node An arbitrary JSXGraph element, preferably one with an area.\n         * @param {Number} radians angle value in radians. 0 is horizontal from left to right, Pi/4 is vertical from top to bottom.\n         */\n        updateGradientAngle: function (el, radians) {\n            // Angles:\n            // 0: ->\n            // 90: down\n            // 180: <-\n            // 90: up\n            var f = 1.0,\n                co = Math.cos(-radians),\n                si = Math.sin(-radians),\n                bb = el.getBoundingBox(),\n                c1,\n                c2,\n                x1,\n                x2,\n                y1,\n                y2,\n                x1s,\n                x2s,\n                y1s,\n                y2s,\n                dx,\n                dy;\n\n            if (Math.abs(co) > Math.abs(si)) {\n                f /= Math.abs(co);\n            } else {\n                f /= Math.abs(si);\n            }\n            if (co >= 0) {\n                x1 = 0;\n                x2 = co * f;\n            } else {\n                x1 = -co * f;\n                x2 = 0;\n            }\n            if (si >= 0) {\n                y1 = 0;\n                y2 = si * f;\n            } else {\n                y1 = -si * f;\n                y2 = 0;\n            }\n\n            c1 = new Coords(Const.COORDS_BY_USER, [bb[0], bb[1]], el.board);\n            c2 = new Coords(Const.COORDS_BY_USER, [bb[2], bb[3]], el.board);\n            dx = c2.scrCoords[1] - c1.scrCoords[1];\n            dy = c2.scrCoords[2] - c1.scrCoords[2];\n            x1s = c1.scrCoords[1] + dx * x1;\n            y1s = c1.scrCoords[2] + dy * y1;\n            x2s = c1.scrCoords[1] + dx * x2;\n            y2s = c1.scrCoords[2] + dy * y2;\n\n            return this.context.createLinearGradient(x1s, y1s, x2s, y2s);\n        },\n\n        /**\n         * Set circles for radial color gradients.\n         *\n         * @private\n         * @param {SVGnode} node SVG gradient node\n         * @param {Number} cx Canvas value x1 (but value between 0 and 1)\n         * @param {Number} cy  Canvas value y1 (but value between 0 and 1)\n         * @param {Number} r  Canvas value r1 (but value between 0 and 1)\n         * @param {Number} fx  Canvas value x0 (but value between 0 and 1)\n         * @param {Number} fy  Canvas value x1 (but value between 0 and 1)\n         * @param {Number} fr  Canvas value r0 (but value between 0 and 1)\n         */\n        updateGradientCircle: function (el, cx, cy, r, fx, fy, fr) {\n            var bb = el.getBoundingBox(),\n                c1,\n                c2,\n                cxs,\n                cys,\n                rs,\n                fxs,\n                fys,\n                frs,\n                dx,\n                dy;\n\n            c1 = new Coords(Const.COORDS_BY_USER, [bb[0], bb[1]], el.board);\n            c2 = new Coords(Const.COORDS_BY_USER, [bb[2], bb[3]], el.board);\n            dx = c2.scrCoords[1] - c1.scrCoords[1];\n            dy = c1.scrCoords[2] - c2.scrCoords[2];\n\n            cxs = c1.scrCoords[1] + dx * cx;\n            cys = c2.scrCoords[2] + dy * cy;\n            fxs = c1.scrCoords[1] + dx * fx;\n            fys = c2.scrCoords[2] + dy * fy;\n            rs = r * (dx + dy) * 0.5;\n            frs = fr * (dx + dy) * 0.5;\n\n            return this.context.createRadialGradient(fxs, fys, frs, cxs, cys, rs);\n        },\n\n        // documented in JXG.AbstractRenderer\n        updateGradient: function (el) {\n            var col,\n                // op,\n                ev_g = Type.evaluate(el.visProp.gradient),\n                gradient;\n\n            // op = Type.evaluate(el.visProp.fillopacity);\n            // op = op > 0 ? op : 0;\n            col = Type.evaluate(el.visProp.fillcolor);\n\n            if (ev_g === \"linear\") {\n                gradient = this.updateGradientAngle(\n                    el,\n                    Type.evaluate(el.visProp.gradientangle)\n                );\n            } else if (ev_g === \"radial\") {\n                gradient = this.updateGradientCircle(\n                    el,\n                    Type.evaluate(el.visProp.gradientcx),\n                    Type.evaluate(el.visProp.gradientcy),\n                    Type.evaluate(el.visProp.gradientr),\n                    Type.evaluate(el.visProp.gradientfx),\n                    Type.evaluate(el.visProp.gradientfy),\n                    Type.evaluate(el.visProp.gradientfr)\n                );\n            }\n            gradient.addColorStop(Type.evaluate(el.visProp.gradientstartoffset), col);\n            gradient.addColorStop(\n                Type.evaluate(el.visProp.gradientendoffset),\n                Type.evaluate(el.visProp.gradientsecondcolor)\n            );\n            return gradient;\n        },\n\n        /**\n         * Sets color and opacity for filling and stroking.\n         * type is the attribute from visProp and targetType the context[targetTypeStyle].\n         * This is necessary, because the fill style of a text is set by the stroke attributes of the text element.\n         * @param {JXG.GeometryElement} el Any JSXGraph element.\n         * @param {String} [type='stroke'] Either <em>fill</em> or <em>stroke</em>.\n         * @param {String} [targetType=type] (optional) Either <em>fill</em> or <em>stroke</em>.\n         * @returns {Boolean} If the color could be set, <tt>true</tt> is returned.\n         * @private\n         */\n        _setColor: function (el, type, targetType) {\n            var hasColor = true,\n                ev = el.visProp,\n                hl,\n                sw,\n                rgba,\n                rgbo,\n                c,\n                o,\n                oo,\n                grad;\n\n            type = type || \"stroke\";\n            targetType = targetType || type;\n\n            hl = this._getHighlighted(el);\n\n            grad = Type.evaluate(el.visProp.gradient);\n            if (grad === \"linear\" || grad === \"radial\") {\n                // TODO: opacity\n                this.context[targetType + \"Style\"] = this.updateGradient(el);\n                return hasColor;\n            }\n\n            // type is equal to 'fill' or 'stroke'\n            rgba = Type.evaluate(ev[hl + type + \"color\"]);\n            if (rgba !== \"none\" && rgba !== false) {\n                o = Type.evaluate(ev[hl + type + \"opacity\"]);\n                o = o > 0 ? o : 0;\n\n                // RGB, not RGBA\n                if (rgba.length !== 9) {\n                    c = rgba;\n                    oo = o;\n                    // True RGBA, not RGB\n                } else {\n                    rgbo = Color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n                this.context.globalAlpha = oo;\n\n                this.context[targetType + \"Style\"] = c;\n            } else {\n                hasColor = false;\n            }\n\n            sw = parseFloat(Type.evaluate(ev[hl + \"strokewidth\"]));\n            if (type === \"stroke\" && !isNaN(sw)) {\n                if (sw === 0) {\n                    this.context.globalAlpha = 0;\n                } else {\n                    this.context.lineWidth = sw;\n                }\n            }\n\n            if (type === \"stroke\" && ev.linecap !== undefined && ev.linecap !== \"\") {\n                this.context.lineCap = ev.linecap;\n            }\n\n            return hasColor;\n        },\n\n        /**\n         * Sets color and opacity for drawing paths and lines and draws the paths and lines.\n         * @param {JXG.GeometryElement} el An JSXGraph element with a stroke.\n         * @private\n         */\n        _stroke: function (el) {\n            var context = this.context,\n                ev_dash = Type.evaluate(el.visProp.dash),\n                ds = Type.evaluate(el.visProp.dashscale),\n                sw = ds ? 0.5 * Type.evaluate(el.visProp.strokewidth) : 1;\n\n            context.save();\n\n            if (ev_dash > 0) {\n                if (context.setLineDash) {\n                    context.setLineDash(\n                        // sw could distinguish highlighting or not.\n                        // But it seems to preferable to ignore this.\n                        this.dashArray[ev_dash - 1].map(function (x) { return x * sw; })\n                    );\n                }\n            } else {\n                this.context.lineDashArray = [];\n            }\n\n            if (this._setColor(el, \"stroke\")) {\n                context.stroke();\n            }\n\n            context.restore();\n        },\n\n        /**\n         * Translates a set of points.\n         * @param {Array} shape An array of point coordinates.\n         * @param {Number} x Translation in X direction.\n         * @param {Number} y Translation in Y direction.\n         * @returns {Array} An array of translated point coordinates.\n         * @private\n         */\n        _translateShape: function (shape, x, y) {\n            var i,\n                rv = [],\n                len = shape.length;\n\n            if (len <= 0) {\n                return shape;\n            }\n\n            for (i = 0; i < len; i++) {\n                rv.push([shape[i][0] + x, shape[i][1] + y]);\n            }\n\n            return rv;\n        },\n\n        /* ******************************** *\n         *    Point drawing and updating    *\n         * ******************************** */\n\n        // documented in AbstractRenderer\n        drawPoint: function (el) {\n            var f = Type.evaluate(el.visProp.face),\n                size = Type.evaluate(el.visProp.size),\n                scr = el.coords.scrCoords,\n                sqrt32 = size * Math.sqrt(3) * 0.5,\n                s05 = size * 0.5,\n                stroke05 = parseFloat(Type.evaluate(el.visProp.strokewidth)) / 2.0,\n                context = this.context;\n\n            if (!el.visPropCalc.visible) {\n                return;\n            }\n\n            switch (f) {\n                case \"cross\": // x\n                case \"x\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2] - size);\n                    context.lineTo(scr[1] + size, scr[2] + size);\n                    context.moveTo(scr[1] + size, scr[2] - size);\n                    context.lineTo(scr[1] - size, scr[2] + size);\n                    context.lineCap = \"round\";\n                    context.lineJoin = \"round\";\n                    context.closePath();\n                    this._stroke(el);\n                    break;\n                case \"circle\": // dot\n                case \"o\":\n                    context.beginPath();\n                    context.arc(scr[1], scr[2], size + 1 + stroke05, 0, 2 * Math.PI, false);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"square\": // rectangle\n                case \"[]\":\n                    if (size <= 0) {\n                        break;\n                    }\n\n                    context.save();\n                    if (this._setColor(el, \"stroke\", \"fill\")) {\n                        context.fillRect(\n                            scr[1] - size - stroke05,\n                            scr[2] - size - stroke05,\n                            size * 2 + 3 * stroke05,\n                            size * 2 + 3 * stroke05\n                        );\n                    }\n                    context.restore();\n                    context.save();\n                    this._setColor(el, \"fill\");\n                    context.fillRect(\n                        scr[1] - size + stroke05,\n                        scr[2] - size + stroke05,\n                        size * 2 - stroke05,\n                        size * 2 - stroke05\n                    );\n                    context.restore();\n                    break;\n                case \"plus\": // +\n                case \"+\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2]);\n                    context.lineTo(scr[1] + size, scr[2]);\n                    context.moveTo(scr[1], scr[2] - size);\n                    context.lineTo(scr[1], scr[2] + size);\n                    context.lineCap = \"round\";\n                    context.lineJoin = \"round\";\n                    context.closePath();\n                    this._stroke(el);\n                    break;\n                case \"divide\":\n                case \"|\":\n                    context.beginPath();\n                    context.moveTo(scr[1], scr[2] - size);\n                    context.lineTo(scr[1], scr[2] + size);\n                    context.lineCap = \"round\";\n                    context.lineJoin = \"round\";\n                    context.closePath();\n                    this._stroke(el);\n                    break;\n                case \"minus\":\n                case \"-\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2]);\n                    context.lineTo(scr[1] + size, scr[2]);\n                    context.lineCap = \"round\";\n                    context.lineJoin = \"round\";\n                    context.closePath();\n                    this._stroke(el);\n                    break;\n                /* eslint-disable no-fallthrough */\n                case \"diamond2\":\n                case \"<<>>\":\n                    size *= 1.41;\n                case \"diamond\": // <>\n                case \"<>\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2]);\n                    context.lineTo(scr[1], scr[2] + size);\n                    context.lineTo(scr[1] + size, scr[2]);\n                    context.lineTo(scr[1], scr[2] - size);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                /* eslint-enable no-fallthrough */\n                case \"triangleup\":\n                case \"A\":\n                case \"a\":\n                case \"^\":\n                    context.beginPath();\n                    context.moveTo(scr[1], scr[2] - size);\n                    context.lineTo(scr[1] - sqrt32, scr[2] + s05);\n                    context.lineTo(scr[1] + sqrt32, scr[2] + s05);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"triangledown\":\n                case \"v\":\n                    context.beginPath();\n                    context.moveTo(scr[1], scr[2] + size);\n                    context.lineTo(scr[1] - sqrt32, scr[2] - s05);\n                    context.lineTo(scr[1] + sqrt32, scr[2] - s05);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"triangleleft\":\n                case \"<\":\n                    context.beginPath();\n                    context.moveTo(scr[1] - size, scr[2]);\n                    context.lineTo(scr[1] + s05, scr[2] - sqrt32);\n                    context.lineTo(scr[1] + s05, scr[2] + sqrt32);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n                case \"triangleright\":\n                case \">\":\n                    context.beginPath();\n                    context.moveTo(scr[1] + size, scr[2]);\n                    context.lineTo(scr[1] - s05, scr[2] - sqrt32);\n                    context.lineTo(scr[1] - s05, scr[2] + sqrt32);\n                    context.closePath();\n                    this._fill(el);\n                    this._stroke(el);\n                    break;\n            }\n        },\n\n        // documented in AbstractRenderer\n        updatePoint: function (el) {\n            this.drawPoint(el);\n        },\n\n        /* ******************************** *\n         *           Lines                  *\n         * ******************************** */\n\n        /**\n         * Draws arrows of an element (usually a line) in canvas renderer.\n         * @param {JXG.GeometryElement} el Line to be drawn.\n         * @param {Array} scr1 Screen coordinates of the start position of the line or curve.\n         * @param {Array} scr2 Screen coordinates of the end position of the line or curve.\n         * @param {String} hl String which carries information if the element is highlighted. Used for getting the correct attribute.\n         * @private\n         */\n        drawArrows: function (el, scr1, scr2, hl, a) {\n            var x1,\n                y1,\n                x2,\n                y2,\n                w0,\n                w,\n                arrowHead,\n                arrowTail,\n                context = this.context,\n                size = 6,\n                type = 1,\n                type_fa,\n                type_la,\n                degree_fa = 1,\n                degree_la = 1,\n                doFill,\n                i,\n                len,\n                d1x,\n                d1y,\n                d2x,\n                d2y,\n                last,\n                ang1,\n                ang2,\n                ev_fa = a.evFirst,\n                ev_la = a.evLast;\n\n            if (Type.evaluate(el.visProp.strokecolor) !== \"none\" && (ev_fa || ev_la)) {\n                if (el.elementClass === Const.OBJECT_CLASS_LINE) {\n                    x1 = scr1.scrCoords[1];\n                    y1 = scr1.scrCoords[2];\n                    x2 = scr2.scrCoords[1];\n                    y2 = scr2.scrCoords[2];\n                    ang1 = ang2 = Math.atan2(y2 - y1, x2 - x1);\n                } else {\n                    x1 = el.points[0].scrCoords[1];\n                    y1 = el.points[0].scrCoords[2];\n\n                    last = el.points.length - 1;\n                    if (last < 1) {\n                        // No arrows for curves consisting of 1 point\n                        return;\n                    }\n                    x2 = el.points[el.points.length - 1].scrCoords[1];\n                    y2 = el.points[el.points.length - 1].scrCoords[2];\n\n                    d1x = el.points[1].scrCoords[1] - el.points[0].scrCoords[1];\n                    d1y = el.points[1].scrCoords[2] - el.points[0].scrCoords[2];\n                    d2x = el.points[last].scrCoords[1] - el.points[last - 1].scrCoords[1];\n                    d2y = el.points[last].scrCoords[2] - el.points[last - 1].scrCoords[2];\n                    if (ev_fa) {\n                        ang1 = Math.atan2(d1y, d1x);\n                    }\n                    if (ev_la) {\n                        ang2 = Math.atan2(d2y, d2x);\n                    }\n                }\n\n                w0 = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n\n                if (ev_fa) {\n                    size = a.sizeFirst;\n\n                    w = w0 * size;\n\n                    type = a.typeFirst;\n                    type_fa = type;\n\n                    if (type === 2) {\n                        arrowTail = [\n                            [w, -w * 0.5],\n                            [0.0, 0.0],\n                            [w, w * 0.5],\n                            [w * 0.5, 0.0]\n                        ];\n                    } else if (type === 3) {\n                        arrowTail = [\n                            [w / 3.0, -w * 0.5],\n                            [0.0, -w * 0.5],\n                            [0.0, w * 0.5],\n                            [w / 3.0, w * 0.5]\n                        ];\n                    } else if (type === 4) {\n                        w /= 10;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [10.0, 3.31],\n                            [6.47, 3.84],\n                            [2.87, 4.5],\n                            [0.0, 6.63],\n                            [0.67, 5.52],\n                            [1.33, 4.42],\n                            [2.0, 3.31],\n                            [1.33, 2.21],\n                            [0.67, 1.1],\n                            [0.0, 0.0],\n                            [2.87, 2.13],\n                            [6.47, 2.79],\n                            [10.0, 3.31]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 3.31 * w;\n                        }\n                    } else if (type === 5) {\n                        w /= 10;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [10.0, 3.28],\n                            [6.61, 4.19],\n                            [3.19, 5.07],\n                            [0.0, 6.55],\n                            [0.62, 5.56],\n                            [1.0, 4.44],\n                            [1.0, 3.28],\n                            [1.0, 2.11],\n                            [0.62, 0.99],\n                            [0.0, 0.0],\n                            [3.19, 1.49],\n                            [6.61, 2.37],\n                            [10.0, 3.28]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 3.28 * w;\n                        }\n                    } else if (type === 6) {\n                        w /= 10;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [10.0, 2.84],\n                            [6.61, 3.59],\n                            [3.21, 4.35],\n                            [0.0, 5.68],\n                            [0.33, 4.73],\n                            [0.67, 3.78],\n                            [1.0, 2.84],\n                            [0.67, 1.89],\n                            [0.33, 0.95],\n                            [0.0, 0.0],\n                            [3.21, 1.33],\n                            [6.61, 2.09],\n                            [10.0, 2.84]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 2.84 * w;\n                        }\n                    } else if (type === 7) {\n                        w = w0;\n                        degree_fa = 3;\n                        arrowTail = [\n                            [0.0, 10.39],\n                            [2.01, 6.92],\n                            [5.96, 5.2],\n                            [10.0, 5.2],\n                            [5.96, 5.2],\n                            [2.01, 3.47],\n                            [0.0, 0.0]\n                        ];\n                        len = arrowTail.length;\n                        for (i = 0; i < len; i++) {\n                            arrowTail[i][0] *= -w;\n                            arrowTail[i][1] *= w;\n                            arrowTail[i][0] += 10 * w;\n                            arrowTail[i][1] -= 5.2 * w;\n                        }\n                    } else {\n                        arrowTail = [\n                            [w, -w * 0.5],\n                            [0.0, 0.0],\n                            [w, w * 0.5]\n                        ];\n                    }\n                }\n\n                if (ev_la) {\n                    size = a.sizeLast;\n                    w = w0 * size;\n\n                    type = a.typeLast;\n                    type_la = type;\n                    if (type === 2) {\n                        arrowHead = [\n                            [-w, -w * 0.5],\n                            [0.0, 0.0],\n                            [-w, w * 0.5],\n                            [-w * 0.5, 0.0]\n                        ];\n                    } else if (type === 3) {\n                        arrowHead = [\n                            [-w / 3.0, -w * 0.5],\n                            [0.0, -w * 0.5],\n                            [0.0, w * 0.5],\n                            [-w / 3.0, w * 0.5]\n                        ];\n                    } else if (type === 4) {\n                        w /= 10;\n                        degree_la = 3;\n                        arrowHead = [\n                            [10.0, 3.31],\n                            [6.47, 3.84],\n                            [2.87, 4.5],\n                            [0.0, 6.63],\n                            [0.67, 5.52],\n                            [1.33, 4.42],\n                            [2.0, 3.31],\n                            [1.33, 2.21],\n                            [0.67, 1.1],\n                            [0.0, 0.0],\n                            [2.87, 2.13],\n                            [6.47, 2.79],\n                            [10.0, 3.31]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 3.31 * w;\n                        }\n                    } else if (type === 5) {\n                        w /= 10;\n                        degree_la = 3;\n                        arrowHead = [\n                            [10.0, 3.28],\n                            [6.61, 4.19],\n                            [3.19, 5.07],\n                            [0.0, 6.55],\n                            [0.62, 5.56],\n                            [1.0, 4.44],\n                            [1.0, 3.28],\n                            [1.0, 2.11],\n                            [0.62, 0.99],\n                            [0.0, 0.0],\n                            [3.19, 1.49],\n                            [6.61, 2.37],\n                            [10.0, 3.28]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 3.28 * w;\n                        }\n                    } else if (type === 6) {\n                        w /= 10;\n                        degree_la = 3;\n                        arrowHead = [\n                            [10.0, 2.84],\n                            [6.61, 3.59],\n                            [3.21, 4.35],\n                            [0.0, 5.68],\n                            [0.33, 4.73],\n                            [0.67, 3.78],\n                            [1.0, 2.84],\n                            [0.67, 1.89],\n                            [0.33, 0.95],\n                            [0.0, 0.0],\n                            [3.21, 1.33],\n                            [6.61, 2.09],\n                            [10.0, 2.84]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 2.84 * w;\n                        }\n                    } else if (type === 7) {\n                        w = w0;\n                        degree_la = 3;\n                        arrowHead = [\n                            [0.0, 10.39],\n                            [2.01, 6.92],\n                            [5.96, 5.2],\n                            [10.0, 5.2],\n                            [5.96, 5.2],\n                            [2.01, 3.47],\n                            [0.0, 0.0]\n                        ];\n                        len = arrowHead.length;\n                        for (i = 0; i < len; i++) {\n                            arrowHead[i][0] *= w;\n                            arrowHead[i][1] *= w;\n                            arrowHead[i][0] -= 10 * w;\n                            arrowHead[i][1] -= 5.2 * w;\n                        }\n                    } else {\n                        arrowHead = [\n                            [-w, -w * 0.5],\n                            [0.0, 0.0],\n                            [-w, w * 0.5]\n                        ];\n                    }\n                }\n\n                context.save();\n                if (this._setColor(el, \"stroke\", \"fill\")) {\n                    this._setColor(el, \"stroke\");\n                    if (ev_fa) {\n                        if (type_fa === 7) {\n                            doFill = false;\n                        } else {\n                            doFill = true;\n                        }\n                        this._drawPolygon(\n                            this._translateShape(this._rotateShape(arrowTail, ang1), x1, y1),\n                            degree_fa,\n                            doFill\n                        );\n                    }\n                    if (ev_la) {\n                        if (type_la === 7) {\n                            doFill = false;\n                        } else {\n                            doFill = true;\n                        }\n                        this._drawPolygon(\n                            this._translateShape(this._rotateShape(arrowHead, ang2), x2, y2),\n                            degree_la,\n                            doFill\n                        );\n                    }\n                }\n                context.restore();\n            }\n        },\n\n        // documented in AbstractRenderer\n        drawLine: function (el) {\n            var c1_org,\n                c2_org,\n                c1 = new Coords(Const.COORDS_BY_USER, el.point1.coords.usrCoords, el.board),\n                c2 = new Coords(Const.COORDS_BY_USER, el.point2.coords.usrCoords, el.board),\n                margin = null,\n                hl,\n                w,\n                arrowData;\n\n            if (!el.visPropCalc.visible) {\n                return;\n            }\n\n            hl = this._getHighlighted(el);\n            w = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n            arrowData = this.getArrowHeadData(el, w, hl);\n\n            if (arrowData.evFirst || arrowData.evLast) {\n                margin = -4;\n            }\n            Geometry.calcStraight(el, c1, c2, margin);\n            this.handleTouchpoints(el, c1, c2, arrowData);\n\n            c1_org = new Coords(Const.COORDS_BY_USER, c1.usrCoords, el.board);\n            c2_org = new Coords(Const.COORDS_BY_USER, c2.usrCoords, el.board);\n\n            this.getPositionArrowHead(el, c1, c2, arrowData);\n\n            this.context.beginPath();\n            this.context.moveTo(c1.scrCoords[1], c1.scrCoords[2]);\n            this.context.lineTo(c2.scrCoords[1], c2.scrCoords[2]);\n            this._stroke(el);\n\n            if (\n                arrowData.evFirst /* && obj.sFirst > 0*/ ||\n                arrowData.evLast /* && obj.sLast > 0*/\n            ) {\n                this.drawArrows(el, c1_org, c2_org, hl, arrowData);\n            }\n        },\n\n        // documented in AbstractRenderer\n        updateLine: function (el) {\n            this.drawLine(el);\n        },\n\n        // documented in AbstractRenderer\n        drawTicks: function () {\n            // this function is supposed to initialize the svg/vml nodes in the SVG/VMLRenderer.\n            // but in canvas there are no such nodes, hence we just do nothing and wait until\n            // updateTicks is called.\n        },\n\n        // documented in AbstractRenderer\n        updateTicks: function (ticks) {\n            var i,\n                c,\n                x,\n                y,\n                len = ticks.ticks.length,\n                len2,\n                j,\n                context = this.context;\n\n            context.beginPath();\n            for (i = 0; i < len; i++) {\n                c = ticks.ticks[i];\n                x = c[0];\n                y = c[1];\n\n                // context.moveTo(x[0], y[0]);\n                // context.lineTo(x[1], y[1]);\n                len2 = x.length;\n                context.moveTo(x[0], y[0]);\n                for (j = 1; j < len2; ++j) {\n                    context.lineTo(x[j], y[j]);\n                }\n            }\n            // Labels\n            // for (i = 0; i < len; i++) {\n            //     c = ticks.ticks[i].scrCoords;\n            //     if (ticks.ticks[i].major &&\n            //             (ticks.board.needsFullUpdate || ticks.needsRegularUpdate) &&\n            //             ticks.labels[i] &&\n            //             ticks.labels[i].visPropCalc.visible) {\n            //         this.updateText(ticks.labels[i]);\n            //     }\n            // }\n            context.lineCap = \"round\";\n            this._stroke(ticks);\n        },\n\n        /* **************************\n         *    Curves\n         * **************************/\n\n        // documented in AbstractRenderer\n        drawCurve: function (el) {\n            var hl, w, arrowData;\n\n            if (Type.evaluate(el.visProp.handdrawing)) {\n                this.updatePathStringBezierPrim(el);\n            } else {\n                this.updatePathStringPrim(el);\n            }\n            if (el.numberPoints > 1) {\n                hl = this._getHighlighted(el);\n                w = Type.evaluate(el.visProp[hl + \"strokewidth\"]);\n                arrowData = this.getArrowHeadData(el, w, hl);\n                if (\n                    arrowData.evFirst /* && obj.sFirst > 0*/ ||\n                    arrowData.evLast /* && obj.sLast > 0*/\n                ) {\n                    this.drawArrows(el, null, null, hl, arrowData);\n                }\n            }\n        },\n\n        // documented in AbstractRenderer\n        updateCurve: function (el) {\n            this.drawCurve(el);\n        },\n\n        /* **************************\n         *    Circle related stuff\n         * **************************/\n\n        // documented in AbstractRenderer\n        drawEllipse: function (el) {\n            var m1 = el.center.coords.scrCoords[1],\n                m2 = el.center.coords.scrCoords[2],\n                sX = el.board.unitX,\n                sY = el.board.unitY,\n                rX = 2 * el.Radius(),\n                rY = 2 * el.Radius(),\n                aWidth = rX * sX,\n                aHeight = rY * sY,\n                aX = m1 - aWidth / 2,\n                aY = m2 - aHeight / 2,\n                hB = (aWidth / 2) * 0.5522848,\n                vB = (aHeight / 2) * 0.5522848,\n                eX = aX + aWidth,\n                eY = aY + aHeight,\n                mX = aX + aWidth / 2,\n                mY = aY + aHeight / 2,\n                context = this.context;\n\n            if (rX > 0.0 && rY > 0.0 && !isNaN(m1 + m2)) {\n                context.beginPath();\n                context.moveTo(aX, mY);\n                context.bezierCurveTo(aX, mY - vB, mX - hB, aY, mX, aY);\n                context.bezierCurveTo(mX + hB, aY, eX, mY - vB, eX, mY);\n                context.bezierCurveTo(eX, mY + vB, mX + hB, eY, mX, eY);\n                context.bezierCurveTo(mX - hB, eY, aX, mY + vB, aX, mY);\n                context.closePath();\n                this._fill(el);\n                this._stroke(el);\n            }\n        },\n\n        // documented in AbstractRenderer\n        updateEllipse: function (el) {\n            return this.drawEllipse(el);\n        },\n\n        /* **************************\n         *    Polygon\n         * **************************/\n\n        // nothing here, using AbstractRenderer implementations\n\n        /* **************************\n         *    Text related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        displayCopyright: function (str, fontSize) {\n            var context = this.context;\n\n            // this should be called on EVERY update, otherwise it won't be shown after the first update\n            context.save();\n            context.font = fontSize + \"px Arial\";\n            context.fillStyle = \"#aaa\";\n            context.lineWidth = 0.5;\n            context.fillText(str, 10, 2 + fontSize);\n            context.restore();\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        drawInternalText: function (el) {\n            var ev_fs = Type.evaluate(el.visProp.fontsize),\n                fontUnit = Type.evaluate(el.visProp.fontunit),\n                ev_ax = el.getAnchorX(),\n                ev_ay = el.getAnchorY(),\n                context = this.context;\n\n            context.save();\n            if (\n                this._setColor(el, \"stroke\", \"fill\") &&\n                !isNaN(el.coords.scrCoords[1] + el.coords.scrCoords[2])\n            ) {\n                context.font = (ev_fs > 0 ? ev_fs : 0) + fontUnit + \" Arial\";\n\n                this.transformImage(el, el.transformations);\n                if (ev_ax === \"left\") {\n                    context.textAlign = \"left\";\n                } else if (ev_ax === \"right\") {\n                    context.textAlign = \"right\";\n                } else if (ev_ax === \"middle\") {\n                    context.textAlign = \"center\";\n                }\n                if (ev_ay === \"bottom\") {\n                    context.textBaseline = \"bottom\";\n                } else if (ev_ay === \"top\") {\n                    context.textBaseline = \"top\";\n                } else if (ev_ay === \"middle\") {\n                    context.textBaseline = \"middle\";\n                }\n                context.fillText(el.plaintext, el.coords.scrCoords[1], el.coords.scrCoords[2]);\n            }\n            context.restore();\n            return null;\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateInternalText: function (el) {\n            this.drawInternalText(el);\n        },\n\n        // documented in JXG.AbstractRenderer\n        // Only necessary for texts\n        setObjectStrokeColor: function (el, color, opacity) {\n            var rgba = Type.evaluate(color),\n                c,\n                rgbo,\n                o = Type.evaluate(opacity),\n                oo,\n                node;\n\n            o = o > 0 ? o : 0;\n\n            if (el.visPropOld.strokecolor === rgba && el.visPropOld.strokeopacity === o) {\n                return;\n            }\n\n            // Check if this could be merged with _setColor\n\n            if (Type.exists(rgba) && rgba !== false) {\n                // RGB, not RGBA\n                if (rgba.length !== 9) {\n                    c = rgba;\n                    oo = o;\n                    // True RGBA, not RGB\n                } else {\n                    rgbo = Color.rgba2rgbo(rgba);\n                    c = rgbo[0];\n                    oo = o * rgbo[1];\n                }\n                node = el.rendNode;\n                if (\n                    el.elementClass === Const.OBJECT_CLASS_TEXT &&\n                    Type.evaluate(el.visProp.display) === \"html\"\n                ) {\n                    node.style.color = c;\n                    node.style.opacity = oo;\n                }\n            }\n\n            el.visPropOld.strokecolor = rgba;\n            el.visPropOld.strokeopacity = o;\n        },\n\n        /* **************************\n         *    Image related stuff\n         * **************************/\n\n        // Already documented in JXG.AbstractRenderer\n        drawImage: function (el) {\n            el.rendNode = new Image();\n            // Store the file name of the image.\n            // Before, this was done in el.rendNode.src\n            // But there, the file name is expanded to\n            // the full url. This may be different from\n            // the url computed in updateImageURL().\n            el._src = \"\";\n            this.updateImage(el);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateImage: function (el) {\n            var context = this.context,\n                o = Type.evaluate(el.visProp.fillopacity),\n                paintImg = Type.bind(function () {\n                    el.imgIsLoaded = true;\n                    if (el.size[0] <= 0 || el.size[1] <= 0) {\n                        return;\n                    }\n                    context.save();\n                    context.globalAlpha = o;\n                    // If det(el.transformations)=0, FireFox 3.6. breaks down.\n                    // This is tested in transformImage\n                    this.transformImage(el, el.transformations);\n                    context.drawImage(\n                        el.rendNode,\n                        el.coords.scrCoords[1],\n                        el.coords.scrCoords[2] - el.size[1],\n                        el.size[0],\n                        el.size[1]\n                    );\n                    context.restore();\n                }, this);\n\n            if (this.updateImageURL(el)) {\n                el.rendNode.onload = paintImg;\n            } else {\n                if (el.imgIsLoaded) {\n                    paintImg();\n                }\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        transformImage: function (el, t) {\n            var m, s, cx, cy, node,\n                len = t.length,\n                ctx = this.context;\n\n            if (len > 0) {\n                m = this.joinTransforms(el, t);\n                if (el.elementClass === Const.OBJECT_CLASS_TEXT && el.visProp.display === 'html') {\n                    s = \" matrix(\" + [m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]].join(\",\") + \") \";\n                    if (s.indexOf('NaN') === -1) {\n                        node = el.rendNode;\n                        node.style.transform = s;\n                        cx = -el.coords.scrCoords[1];\n                        cy = -el.coords.scrCoords[2];\n                        switch (Type.evaluate(el.visProp.anchorx)) {\n                            case 'right': cx += el.size[0]; break;\n                            case 'middle': cx += el.size[0] * 0.5; break;\n                        }\n                        switch (Type.evaluate(el.visProp.anchory)) {\n                            case 'bottom': cy += el.size[1]; break;\n                            case 'middle': cy += el.size[1] * 0.5; break;\n                        }\n                        node.style['transform-origin'] = (cx) + 'px ' + (cy) + 'px';\n                    }\n                } else {\n                    if (Math.abs(Numerics.det(m)) >= Mat.eps) {\n                        ctx.transform(m[1][1], m[2][1], m[1][2], m[2][2], m[1][0], m[2][0]);\n                    }\n                }\n            }\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updateImageURL: function (el) {\n            var url;\n\n            url = Type.evaluate(el.url);\n            if (el._src !== url) {\n                el.imgIsLoaded = false;\n                el.rendNode.src = url;\n                el._src = url;\n                return true;\n            }\n\n            return false;\n        },\n\n        /* **************************\n         * Render primitive objects\n         * **************************/\n\n        // documented in AbstractRenderer\n        remove: function (shape) {\n            // sounds odd for a pixel based renderer but we need this for html texts\n            if (Type.exists(shape) && Type.exists(shape.parentNode)) {\n                shape.parentNode.removeChild(shape);\n            }\n        },\n\n        // documented in AbstractRenderer\n        updatePathStringPrim: function (el) {\n            var i,\n                scr,\n                scr1,\n                scr2,\n                len,\n                symbm = \"M\",\n                symbl = \"L\",\n                symbc = \"C\",\n                nextSymb = symbm,\n                maxSize = 5000.0,\n                context = this.context;\n\n            if (el.numberPoints <= 0) {\n                return;\n            }\n\n            len = Math.min(el.points.length, el.numberPoints);\n            context.beginPath();\n\n            if (el.bezierDegree === 1) {\n                /*\n                if (isNotPlot && el.board.options.curve.RDPsmoothing) {\n                    el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);\n                }\n                */\n\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // Chrome has problems with values  being too far away.\n                        if (scr[1] > maxSize) {\n                            scr[1] = maxSize;\n                        } else if (scr[1] < -maxSize) {\n                            scr[1] = -maxSize;\n                        }\n\n                        if (scr[2] > maxSize) {\n                            scr[2] = maxSize;\n                        } else if (scr[2] < -maxSize) {\n                            scr[2] = -maxSize;\n                        }\n\n                        if (nextSymb === symbm) {\n                            context.moveTo(scr[1], scr[2]);\n                        } else {\n                            context.lineTo(scr[1], scr[2]);\n                        }\n                        nextSymb = symbl;\n                    }\n                }\n            } else if (el.bezierDegree === 3) {\n                i = 0;\n                while (i < len) {\n                    scr = el.points[i].scrCoords;\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        if (nextSymb === symbm) {\n                            context.moveTo(scr[1], scr[2]);\n                        } else {\n                            i += 1;\n                            scr1 = el.points[i].scrCoords;\n                            i += 1;\n                            scr2 = el.points[i].scrCoords;\n                            context.bezierCurveTo(\n                                scr[1],\n                                scr[2],\n                                scr1[1],\n                                scr1[2],\n                                scr2[1],\n                                scr2[2]\n                            );\n                        }\n                        nextSymb = symbc;\n                    }\n                    i += 1;\n                }\n            }\n            context.lineCap = \"round\";\n            this._fill(el);\n            this._stroke(el);\n        },\n\n        // Already documented in JXG.AbstractRenderer\n        updatePathStringBezierPrim: function (el) {\n            var i,\n                j,\n                k,\n                scr,\n                lx,\n                ly,\n                len,\n                symbm = \"M\",\n                symbl = \"C\",\n                nextSymb = symbm,\n                maxSize = 5000.0,\n                f = Type.evaluate(el.visProp.strokewidth),\n                isNoPlot = Type.evaluate(el.visProp.curvetype) !== \"plot\",\n                context = this.context;\n\n            if (el.numberPoints <= 0) {\n                return;\n            }\n\n            if (isNoPlot && el.board.options.curve.RDPsmoothing) {\n                el.points = Numerics.RamerDouglasPeucker(el.points, 0.5);\n            }\n\n            len = Math.min(el.points.length, el.numberPoints);\n            context.beginPath();\n\n            for (j = 1; j < 3; j++) {\n                nextSymb = symbm;\n                for (i = 0; i < len; i++) {\n                    scr = el.points[i].scrCoords;\n\n                    if (isNaN(scr[1]) || isNaN(scr[2])) {\n                        // PenUp\n                        nextSymb = symbm;\n                    } else {\n                        // Chrome has problems with values being too far away.\n                        if (scr[1] > maxSize) {\n                            scr[1] = maxSize;\n                        } else if (scr[1] < -maxSize) {\n                            scr[1] = -maxSize;\n                        }\n\n                        if (scr[2] > maxSize) {\n                            scr[2] = maxSize;\n                        } else if (scr[2] < -maxSize) {\n                            scr[2] = -maxSize;\n                        }\n\n                        if (nextSymb === symbm) {\n                            context.moveTo(scr[1], scr[2]);\n                        } else {\n                            k = 2 * j;\n                            context.bezierCurveTo(\n                                lx + (scr[1] - lx) * 0.333 + f * (k * Math.random() - j),\n                                ly + (scr[2] - ly) * 0.333 + f * (k * Math.random() - j),\n                                lx + (scr[1] - lx) * 0.666 + f * (k * Math.random() - j),\n                                ly + (scr[2] - ly) * 0.666 + f * (k * Math.random() - j),\n                                scr[1],\n                                scr[2]\n                            );\n                        }\n                        nextSymb = symbl;\n                        lx = scr[1];\n                        ly = scr[2];\n                    }\n                }\n            }\n            context.lineCap = \"round\";\n            this._fill(el);\n            this._stroke(el);\n        },\n\n        // documented in AbstractRenderer\n        updatePolygonPrim: function (node, el) {\n            var scrCoords,\n                i,\n                j,\n                len = el.vertices.length,\n                context = this.context,\n                isReal = true;\n\n            if (len <= 0 || !el.visPropCalc.visible) {\n                return;\n            }\n            if (el.elType === \"polygonalchain\") {\n                len++;\n            }\n\n            context.beginPath();\n            i = 0;\n            while (!el.vertices[i].isReal && i < len - 1) {\n                i++;\n                isReal = false;\n            }\n            scrCoords = el.vertices[i].coords.scrCoords;\n            context.moveTo(scrCoords[1], scrCoords[2]);\n\n            for (j = i; j < len - 1; j++) {\n                if (!el.vertices[j].isReal) {\n                    isReal = false;\n                }\n                scrCoords = el.vertices[j].coords.scrCoords;\n                context.lineTo(scrCoords[1], scrCoords[2]);\n            }\n            context.closePath();\n\n            if (isReal) {\n                this._fill(el); // The edges of a polygon are displayed separately (as segments).\n            }\n        },\n\n        // **************************  Set Attributes *************************\n\n        // Already documented in JXG.AbstractRenderer\n        display: function (el, val) {\n            if (el && el.rendNode) {\n                el.visPropOld.visible = val;\n                if (val) {\n                    el.rendNode.style.visibility = \"inherit\";\n                } else {\n                    el.rendNode.style.visibility = \"hidden\";\n                }\n            }\n        },\n\n        // documented in AbstractRenderer\n        show: function (el) {\n            JXG.deprecated(\"Board.renderer.show()\", \"Board.renderer.display()\");\n\n            if (Type.exists(el.rendNode)) {\n                el.rendNode.style.visibility = \"inherit\";\n            }\n        },\n\n        // documented in AbstractRenderer\n        hide: function (el) {\n            JXG.deprecated(\"Board.renderer.hide()\", \"Board.renderer.display()\");\n\n            if (Type.exists(el.rendNode)) {\n                el.rendNode.style.visibility = \"hidden\";\n            }\n        },\n\n        // documented in AbstractRenderer\n        setGradient: function (el) {\n            // var // col,\n            //     op;\n\n            // op = Type.evaluate(el.visProp.fillopacity);\n            // op = op > 0 ? op : 0;\n\n            // col = Type.evaluate(el.visProp.fillcolor);\n        },\n\n        // documented in AbstractRenderer\n        setShadow: function (el) {\n            if (el.visPropOld.shadow === el.visProp.shadow) {\n                return;\n            }\n\n            // not implemented yet\n            // we simply have to redraw the element\n            // probably the best way to do so would be to call el.updateRenderer(), i think.\n\n            el.visPropOld.shadow = el.visProp.shadow;\n        },\n\n        // documented in AbstractRenderer\n        highlight: function (obj) {\n            if (\n                obj.elementClass === Const.OBJECT_CLASS_TEXT &&\n                Type.evaluate(obj.visProp.display) === \"html\"\n            ) {\n                this.updateTextStyle(obj, true);\n            } else {\n                obj.board.prepareUpdate();\n                obj.board.renderer.suspendRedraw(obj.board);\n                obj.board.updateRenderer();\n                obj.board.renderer.unsuspendRedraw();\n            }\n            return this;\n        },\n\n        // documented in AbstractRenderer\n        noHighlight: function (obj) {\n            if (\n                obj.elementClass === Const.OBJECT_CLASS_TEXT &&\n                Type.evaluate(obj.visProp.display) === \"html\"\n            ) {\n                this.updateTextStyle(obj, false);\n            } else {\n                obj.board.prepareUpdate();\n                obj.board.renderer.suspendRedraw(obj.board);\n                obj.board.updateRenderer();\n                obj.board.renderer.unsuspendRedraw();\n            }\n            return this;\n        },\n\n        /* **************************\n         * renderer control\n         * **************************/\n\n        // documented in AbstractRenderer\n        suspendRedraw: function (board) {\n            this.context.save();\n            this.context.clearRect(0, 0, this.canvasRoot.width, this.canvasRoot.height);\n\n            if (board && board.attr.showcopyright) {\n                this.displayCopyright(JXG.licenseText, 12);\n            }\n        },\n\n        // documented in AbstractRenderer\n        unsuspendRedraw: function () {\n            this.context.restore();\n        },\n\n        // document in AbstractRenderer\n        resize: function (w, h) {\n            if (this.container) {\n                this.canvasRoot.style.width = parseFloat(w) + \"px\";\n                this.canvasRoot.style.height = parseFloat(h) + \"px\";\n\n                this.canvasRoot.setAttribute(\"width\", 2 * parseFloat(w) + \"px\");\n                this.canvasRoot.setAttribute(\"height\", 2 * parseFloat(h) + \"px\");\n            } else {\n                this.canvasRoot.width = 2 * parseFloat(w);\n                this.canvasRoot.height = 2 * parseFloat(h);\n            }\n            this.context = this.canvasRoot.getContext(\"2d\");\n            // The width and height of the canvas is set to twice the CSS values,\n            // followed by an appropriate scaling.\n            // See https://stackoverflow.com/questions/22416462/canvas-element-with-blurred-lines\n            this.context.scale(2, 2);\n        },\n\n        removeToInsertLater: function () {\n            return function () { };\n        }\n    }\n);\n\nexport default JXG.CanvasRenderer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}