{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains the Math.Geometry namespace for calculating algebraic/geometric\n * stuff like intersection points, angles, midpoint, and so on.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Numerics from \"./numerics\";\nimport Type from \"../utils/type\";\nimport Expect from \"../utils/expect\";\n\n/**\n * Math.Geometry namespace definition. This namespace holds geometrical algorithms,\n * especially intersection algorithms.\n * @name JXG.Math.Geometry\n * @namespace\n */\nMat.Geometry = {};\n\n// the splitting is necessary due to the shortcut for the circumcircleMidpoint method to circumcenter.\n\nJXG.extend(Mat.Geometry, /** @lends JXG.Math.Geometry */{\n  /* ***************************************/\n  /* *** GENERAL GEOMETRIC CALCULATIONS ****/\n  /* ***************************************/\n\n  /**\n   * Calculates the angle defined by the points A, B, C.\n   * @param {JXG.Point|Array} A A point  or [x,y] array.\n   * @param {JXG.Point|Array} B Another point or [x,y] array.\n   * @param {JXG.Point|Array} C A circle - no, of course the third point or [x,y] array.\n   * @deprecated Use {@link JXG.Math.Geometry.rad} instead.\n   * @see #rad\n   * @see #trueAngle\n   * @returns {Number} The angle in radian measure.\n   */\n  angle: function (A, B, C) {\n    var u,\n      v,\n      s,\n      t,\n      a = [],\n      b = [],\n      c = [];\n    JXG.deprecated(\"Geometry.angle()\", \"Geometry.rad()\");\n    if (A.coords) {\n      a[0] = A.coords.usrCoords[1];\n      a[1] = A.coords.usrCoords[2];\n    } else {\n      a[0] = A[0];\n      a[1] = A[1];\n    }\n    if (B.coords) {\n      b[0] = B.coords.usrCoords[1];\n      b[1] = B.coords.usrCoords[2];\n    } else {\n      b[0] = B[0];\n      b[1] = B[1];\n    }\n    if (C.coords) {\n      c[0] = C.coords.usrCoords[1];\n      c[1] = C.coords.usrCoords[2];\n    } else {\n      c[0] = C[0];\n      c[1] = C[1];\n    }\n    u = a[0] - b[0];\n    v = a[1] - b[1];\n    s = c[0] - b[0];\n    t = c[1] - b[1];\n    return Math.atan2(u * t - v * s, u * s + v * t);\n  },\n  /**\n   * Calculates the angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.\n   * @param {JXG.Point|Array} A Point or [x,y] array\n   * @param {JXG.Point|Array} B Point or [x,y] array\n   * @param {JXG.Point|Array} C Point or [x,y] array\n   * @see #rad\n   * @returns {Number} The angle in degrees.\n   */\n  trueAngle: function (A, B, C) {\n    return this.rad(A, B, C) * 57.295779513082323; // *180.0/Math.PI;\n  },\n  /**\n   * Calculates the internal angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.\n   * @param {JXG.Point|Array} A Point or [x,y] array\n   * @param {JXG.Point|Array} B Point or [x,y] array\n   * @param {JXG.Point|Array} C Point or [x,y] array\n   * @see #trueAngle\n   * @returns {Number} Angle in radians.\n   */\n  rad: function (A, B, C) {\n    var ax, ay, bx, by, cx, cy, phi;\n    if (A.coords) {\n      ax = A.coords.usrCoords[1];\n      ay = A.coords.usrCoords[2];\n    } else {\n      ax = A[0];\n      ay = A[1];\n    }\n    if (B.coords) {\n      bx = B.coords.usrCoords[1];\n      by = B.coords.usrCoords[2];\n    } else {\n      bx = B[0];\n      by = B[1];\n    }\n    if (C.coords) {\n      cx = C.coords.usrCoords[1];\n      cy = C.coords.usrCoords[2];\n    } else {\n      cx = C[0];\n      cy = C[1];\n    }\n    phi = Math.atan2(cy - by, cx - bx) - Math.atan2(ay - by, ax - bx);\n    if (phi < 0) {\n      phi += 6.2831853071795862;\n    }\n    return phi;\n  },\n  /**\n   * Calculates a point on the bisection line between the three points A, B, C.\n   * As a result, the bisection line is defined by two points:\n   * Parameter B and the point with the coordinates calculated in this function.\n   * Does not work for ideal points.\n   * @param {JXG.Point} A Point\n   * @param {JXG.Point} B Point\n   * @param {JXG.Point} C Point\n   * @param [board=A.board] Reference to the board\n   * @returns {JXG.Coords} Coordinates of the second point defining the bisection.\n   */\n  angleBisector: function (A, B, C, board) {\n    var phiA,\n      phiC,\n      phi,\n      Ac = A.coords.usrCoords,\n      Bc = B.coords.usrCoords,\n      Cc = C.coords.usrCoords,\n      x,\n      y;\n    if (!Type.exists(board)) {\n      board = A.board;\n    }\n\n    // Parallel lines\n    if (Bc[0] === 0) {\n      return new Coords(Const.COORDS_BY_USER, [1, (Ac[1] + Cc[1]) * 0.5, (Ac[2] + Cc[2]) * 0.5], board);\n    }\n\n    // Non-parallel lines\n    x = Ac[1] - Bc[1];\n    y = Ac[2] - Bc[2];\n    phiA = Math.atan2(y, x);\n    x = Cc[1] - Bc[1];\n    y = Cc[2] - Bc[2];\n    phiC = Math.atan2(y, x);\n    phi = (phiA + phiC) * 0.5;\n    if (phiA > phiC) {\n      phi += Math.PI;\n    }\n    x = Math.cos(phi) + Bc[1];\n    y = Math.sin(phi) + Bc[2];\n    return new Coords(Const.COORDS_BY_USER, [1, x, y], board);\n  },\n  // /**\n  //  * Calculates a point on the m-section line between the three points A, B, C.\n  //  * As a result, the m-section line is defined by two points:\n  //  * Parameter B and the point with the coordinates calculated in this function.\n  //  * The m-section generalizes the bisector to any real number.\n  //  * For example, the trisectors of an angle are simply the 1/3-sector and the 2/3-sector.\n  //  * Does not work for ideal points.\n  //  * @param {JXG.Point} A Point\n  //  * @param {JXG.Point} B Point\n  //  * @param {JXG.Point} C Point\n  //  * @param {Number} m Number\n  //  * @param [board=A.board] Reference to the board\n  //  * @returns {JXG.Coords} Coordinates of the second point defining the bisection.\n  //  */\n  // angleMsector: function (A, B, C, m, board) {\n  //     var phiA, phiC, phi,\n  //         Ac = A.coords.usrCoords,\n  //         Bc = B.coords.usrCoords,\n  //         Cc = C.coords.usrCoords,\n  //         x, y;\n\n  //     if (!Type.exists(board)) {\n  //         board = A.board;\n  //     }\n\n  //     // Parallel lines\n  //     if (Bc[0] === 0) {\n  //         return new Coords(Const.COORDS_BY_USER,\n  //             [1, (Ac[1] + Cc[1]) * m, (Ac[2] + Cc[2]) * m], board);\n  //     }\n\n  //     // Non-parallel lines\n  //     x = Ac[1] - Bc[1];\n  //     y = Ac[2] - Bc[2];\n  //     phiA =  Math.atan2(y, x);\n\n  //     x = Cc[1] - Bc[1];\n  //     y = Cc[2] - Bc[2];\n  //     phiC =  Math.atan2(y, x);\n\n  //     phi = phiA + ((phiC - phiA) * m);\n\n  //     if (phiA - phiC > Math.PI) {\n  //         phi += 2*m*Math.PI;\n  //     }\n\n  //     x = Math.cos(phi) + Bc[1];\n  //     y = Math.sin(phi) + Bc[2];\n\n  //     return new Coords(Const.COORDS_BY_USER, [1, x, y], board);\n  // },\n\n  /**\n   * Reflects the point along the line.\n   * @param {JXG.Line} line Axis of reflection.\n   * @param {JXG.Point} point Point to reflect.\n   * @param [board=point.board] Reference to the board\n   * @returns {JXG.Coords} Coordinates of the reflected point.\n   */\n  reflection: function (line, point, board) {\n    // (v,w) defines the slope of the line\n    var x0,\n      y0,\n      x1,\n      y1,\n      v,\n      w,\n      mu,\n      pc = point.coords.usrCoords,\n      p1c = line.point1.coords.usrCoords,\n      p2c = line.point2.coords.usrCoords;\n    if (!Type.exists(board)) {\n      board = point.board;\n    }\n    v = p2c[1] - p1c[1];\n    w = p2c[2] - p1c[2];\n    x0 = pc[1] - p1c[1];\n    y0 = pc[2] - p1c[2];\n    mu = (v * y0 - w * x0) / (v * v + w * w);\n\n    // point + mu*(-y,x) is the perpendicular foot\n    x1 = pc[1] + 2 * mu * w;\n    y1 = pc[2] - 2 * mu * v;\n    return new Coords(Const.COORDS_BY_USER, [x1, y1], board);\n  },\n  /**\n   * Computes the new position of a point which is rotated\n   * around a second point (called rotpoint) by the angle phi.\n   * @param {JXG.Point} rotpoint Center of the rotation\n   * @param {JXG.Point} point point to be rotated\n   * @param {Number} phi rotation angle in arc length\n   * @param {JXG.Board} [board=point.board] Reference to the board\n   * @returns {JXG.Coords} Coordinates of the new position.\n   */\n  rotation: function (rotpoint, point, phi, board) {\n    var x0,\n      y0,\n      c,\n      s,\n      x1,\n      y1,\n      pc = point.coords.usrCoords,\n      rotpc = rotpoint.coords.usrCoords;\n    if (!Type.exists(board)) {\n      board = point.board;\n    }\n    x0 = pc[1] - rotpc[1];\n    y0 = pc[2] - rotpc[2];\n    c = Math.cos(phi);\n    s = Math.sin(phi);\n    x1 = x0 * c - y0 * s + rotpc[1];\n    y1 = x0 * s + y0 * c + rotpc[2];\n    return new Coords(Const.COORDS_BY_USER, [x1, y1], board);\n  },\n  /**\n   * Calculates the coordinates of a point on the perpendicular to the given line through\n   * the given point.\n   * @param {JXG.Line} line A line.\n   * @param {JXG.Point} point Point which is projected to the line.\n   * @param {JXG.Board} [board=point.board] Reference to the board\n   * @returns {Array} Array of length two containing coordinates of a point on the perpendicular to the given line\n   *                  through the given point and boolean flag \"change\".\n   */\n  perpendicular: function (line, point, board) {\n    var x,\n      y,\n      change,\n      c,\n      z,\n      A = line.point1.coords.usrCoords,\n      B = line.point2.coords.usrCoords,\n      C = point.coords.usrCoords;\n    if (!Type.exists(board)) {\n      board = point.board;\n    }\n\n    // special case: point is the first point of the line\n    if (point === line.point1) {\n      x = A[1] + B[2] - A[2];\n      y = A[2] - B[1] + A[1];\n      z = A[0] * B[0];\n      if (Math.abs(z) < Mat.eps) {\n        x = B[2];\n        y = -B[1];\n      }\n      c = [z, x, y];\n      change = true;\n\n      // special case: point is the second point of the line\n    } else if (point === line.point2) {\n      x = B[1] + A[2] - B[2];\n      y = B[2] - A[1] + B[1];\n      z = A[0] * B[0];\n      if (Math.abs(z) < Mat.eps) {\n        x = A[2];\n        y = -A[1];\n      }\n      c = [z, x, y];\n      change = false;\n\n      // special case: point lies somewhere else on the line\n    } else if (Math.abs(Mat.innerProduct(C, line.stdform, 3)) < Mat.eps) {\n      x = C[1] + B[2] - C[2];\n      y = C[2] - B[1] + C[1];\n      z = B[0];\n      if (Math.abs(z) < Mat.eps) {\n        x = B[2];\n        y = -B[1];\n      }\n      change = true;\n      if (Math.abs(z) > Mat.eps && Math.abs(x - C[1]) < Mat.eps && Math.abs(y - C[2]) < Mat.eps) {\n        x = C[1] + A[2] - C[2];\n        y = C[2] - A[1] + C[1];\n        change = false;\n      }\n      c = [z, x, y];\n\n      // general case: point does not lie on the line\n      // -> calculate the foot of the dropped perpendicular\n    } else {\n      c = [0, line.stdform[1], line.stdform[2]];\n      c = Mat.crossProduct(c, C); // perpendicuar to line\n      c = Mat.crossProduct(c, line.stdform); // intersection of line and perpendicular\n      change = true;\n    }\n    return [new Coords(Const.COORDS_BY_USER, c, board), change];\n  },\n  /**\n   * @deprecated Please use {@link JXG.Math.Geometry.circumcenter} instead.\n   */\n  circumcenterMidpoint: function () {\n    JXG.deprecated(\"Geometry.circumcenterMidpoint()\", \"Geometry.circumcenter()\");\n    this.circumcenter.apply(this, arguments);\n  },\n  /**\n   * Calculates the center of the circumcircle of the three given points.\n   * @param {JXG.Point} point1 Point\n   * @param {JXG.Point} point2 Point\n   * @param {JXG.Point} point3 Point\n   * @param {JXG.Board} [board=point1.board] Reference to the board\n   * @returns {JXG.Coords} Coordinates of the center of the circumcircle of the given points.\n   */\n  circumcenter: function (point1, point2, point3, board) {\n    var u,\n      v,\n      m1,\n      m2,\n      A = point1.coords.usrCoords,\n      B = point2.coords.usrCoords,\n      C = point3.coords.usrCoords;\n    if (!Type.exists(board)) {\n      board = point1.board;\n    }\n    u = [B[0] - A[0], -B[2] + A[2], B[1] - A[1]];\n    v = [(A[0] + B[0]) * 0.5, (A[1] + B[1]) * 0.5, (A[2] + B[2]) * 0.5];\n    m1 = Mat.crossProduct(u, v);\n    u = [C[0] - B[0], -C[2] + B[2], C[1] - B[1]];\n    v = [(B[0] + C[0]) * 0.5, (B[1] + C[1]) * 0.5, (B[2] + C[2]) * 0.5];\n    m2 = Mat.crossProduct(u, v);\n    return new Coords(Const.COORDS_BY_USER, Mat.crossProduct(m1, m2), board);\n  },\n  /**\n   * Calculates the Euclidean distance for two given arrays of the same length.\n   * @param {Array} array1 Array of Number\n   * @param {Array} array2 Array of Number\n   * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.\n   * @returns {Number} Euclidean distance of the given vectors.\n   */\n  distance: function (array1, array2, n) {\n    var i,\n      sum = 0;\n    if (!n) {\n      n = Math.min(array1.length, array2.length);\n    }\n    for (i = 0; i < n; i++) {\n      sum += (array1[i] - array2[i]) * (array1[i] - array2[i]);\n    }\n    return Math.sqrt(sum);\n  },\n  /**\n   * Calculates Euclidean distance for two given arrays of the same length.\n   * If one of the arrays contains a zero in the first coordinate, and the Euclidean distance\n   * is different from zero it is a point at infinity and we return Infinity.\n   * @param {Array} array1 Array containing elements of type number.\n   * @param {Array} array2 Array containing elements of type number.\n   * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.\n   * @returns {Number} Euclidean (affine) distance of the given vectors.\n   */\n  affineDistance: function (array1, array2, n) {\n    var d;\n    d = this.distance(array1, array2, n);\n    if (d > Mat.eps && (Math.abs(array1[0]) < Mat.eps || Math.abs(array2[0]) < Mat.eps)) {\n      return Infinity;\n    }\n    return d;\n  },\n  /**\n   * Affine ratio of three collinear points a, b, c: (c - a) / (b - a).\n   * If r > 1 or r < 0 then c is outside of the segment ab.\n   *\n   * @param {Array|JXG.Coords} a\n   * @param {Array|JXG.Coords} b\n   * @param {Array|JXG.Coords} c\n   * @returns {Number} affine ratio (c - a) / (b - a)\n   */\n  affineRatio: function (a, b, c) {\n    var r = 0.0,\n      dx;\n    if (Type.exists(a.usrCoords)) {\n      a = a.usrCoords;\n    }\n    if (Type.exists(b.usrCoords)) {\n      b = b.usrCoords;\n    }\n    if (Type.exists(c.usrCoords)) {\n      c = c.usrCoords;\n    }\n    dx = b[1] - a[1];\n    if (Math.abs(dx) > Mat.eps) {\n      r = (c[1] - a[1]) / dx;\n    } else {\n      r = (c[2] - a[2]) / (b[2] - a[2]);\n    }\n    return r;\n  },\n  /**\n   * Sort vertices counter clockwise starting with the first point.\n   *\n   * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n   *\n   * @returns {Array}\n   */\n  sortVertices: function (p) {\n    var ll,\n      ps = Expect.each(p, Expect.coordsArray),\n      N = ps.length,\n      lastPoint = null;\n\n    // If the last point equals the first point, we take the last point out of the array.\n    // It may be that the several points at the end of the array are equal to the first point.\n    // The polygonal chain is been closed by JSXGraph, but this may also have been done by the user.\n    // Therefore, we use a while lopp to pop the last points.\n    while (ps[0][0] === ps[N - 1][0] && ps[0][1] === ps[N - 1][1] && ps[0][2] === ps[N - 1][2]) {\n      lastPoint = ps.pop();\n      N--;\n    }\n    // Find the point with the lowest y value\n    // for (i = 1; i < N; i++) {\n    //     if ((ps[i][2] < ps[0][2]) ||\n    //         // if the current and the lowest point have the same y value, pick the one with\n    //         // the lowest x value.\n    //         (Math.abs(ps[i][2] - ps[0][2]) < Mat.eps && ps[i][1] < ps[0][1])) {\n    //         console.log(i, 0);\n    //         ps = Type.swap(ps, i, 0);\n    //     }\n    // }\n\n    ll = ps[0];\n    // Sort ps in increasing order of the angle between a point and the first point ll.\n    // If a point is equal to the first point ll, the angle is defined to be -Infinity.\n    // Otherwise, atan2 would return zero, which is a value which also attained by points\n    // on the same horizontal line.\n    ps.sort(function (a, b) {\n      var rad1 = a[2] === ll[2] && a[1] === ll[1] ? -Infinity : Math.atan2(a[2] - ll[2], a[1] - ll[1]),\n        rad2 = b[2] === ll[2] && b[1] === ll[1] ? -Infinity : Math.atan2(b[2] - ll[2], b[1] - ll[1]);\n      return rad1 - rad2;\n    });\n\n    // If the last point has been taken out of the array, we put it in again.\n    if (lastPoint !== null) {\n      ps.push(lastPoint);\n    }\n    return ps;\n  },\n  /**\n   * Signed triangle area of the three points given.\n   *\n   * @param {JXG.Point|JXG.Coords|Array} p1\n   * @param {JXG.Point|JXG.Coords|Array} p2\n   * @param {JXG.Point|JXG.Coords|Array} p3\n   *\n   * @returns {Number}\n   */\n  signedTriangle: function (p1, p2, p3) {\n    var A = Expect.coordsArray(p1),\n      B = Expect.coordsArray(p2),\n      C = Expect.coordsArray(p3);\n    return 0.5 * ((B[1] - A[1]) * (C[2] - A[2]) - (B[2] - A[2]) * (C[1] - A[1]));\n  },\n  /**\n   * Determine the signed area of a non-selfintersecting polygon.\n   * Surveyor's Formula\n   *\n   * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n   * @param {Boolean} [sort=true]\n   *\n   * @returns {Number}\n   */\n  signedPolygon: function (p, sort) {\n    var i,\n      N,\n      A = 0,\n      ps = Expect.each(p, Expect.coordsArray);\n    if (sort === undefined) {\n      sort = true;\n    }\n    if (!sort) {\n      ps = this.sortVertices(ps);\n    } else {\n      // Make sure the polygon is closed. If it is already closed this won't change the sum because the last\n      // summand will be 0.\n      ps.unshift(ps[ps.length - 1]);\n    }\n    N = ps.length;\n    for (i = 1; i < N; i++) {\n      A += ps[i - 1][1] * ps[i][2] - ps[i][1] * ps[i - 1][2];\n    }\n    return 0.5 * A;\n  },\n  /**\n   * Calculate the complex hull of a point cloud.\n   *\n   * @param {Array} points An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n   *\n   * @returns {Array}\n   */\n  GrahamScan: function (points) {\n    var i,\n      M = 1,\n      ps = Expect.each(points, Expect.coordsArray),\n      N = ps.length;\n    ps = this.sortVertices(ps);\n    N = ps.length;\n    for (i = 2; i < N; i++) {\n      while (this.signedTriangle(ps[M - 1], ps[M], ps[i]) <= 0) {\n        if (M > 1) {\n          M -= 1;\n        } else if (i === N - 1) {\n          break;\n        }\n        i += 1;\n      }\n      M += 1;\n      ps = Type.swap(ps, M, i);\n    }\n    return ps.slice(0, M);\n  },\n  /**\n   * A line can be a segment, a straight, or a ray. So it is not always delimited by point1 and point2\n   * calcStraight determines the visual start point and end point of the line. A segment is only drawn\n   * from start to end point, a straight line is drawn until it meets the boards boundaries.\n   * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.\n   * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and\n   * set by this method.\n   * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set\n   * by this method.\n   * @param {Number} margin Optional margin, to avoid the display of the small sides of lines.\n   * @returns null\n   * @see Line\n   * @see JXG.Line\n   */\n  calcStraight: function (el, point1, point2, margin) {\n    var takePoint1, takePoint2, intersection, intersect1, intersect2, straightFirst, straightLast, c, p1, p2;\n    if (!Type.exists(margin)) {\n      // Enlarge the drawable region slightly. This hides the small sides\n      // of thick lines in most cases.\n      margin = 10;\n    }\n    straightFirst = Type.evaluate(el.visProp.straightfirst);\n    straightLast = Type.evaluate(el.visProp.straightlast);\n\n    // If one of the point is an ideal point in homogeneous coordinates\n    // drawing of line segments or rays are not possible.\n    if (Math.abs(point1.scrCoords[0]) < Mat.eps) {\n      straightFirst = true;\n    }\n    if (Math.abs(point2.scrCoords[0]) < Mat.eps) {\n      straightLast = true;\n    }\n\n    // Do nothing in case of line segments (inside or outside of the board)\n    if (!straightFirst && !straightLast) {\n      return;\n    }\n\n    // Compute the stdform of the line in screen coordinates.\n    c = [];\n    c[0] = el.stdform[0] - el.stdform[1] * el.board.origin.scrCoords[1] / el.board.unitX + el.stdform[2] * el.board.origin.scrCoords[2] / el.board.unitY;\n    c[1] = el.stdform[1] / el.board.unitX;\n    c[2] = -el.stdform[2] / el.board.unitY;\n\n    // If p1=p2\n    if (isNaN(c[0] + c[1] + c[2])) {\n      return;\n    }\n    takePoint1 = false;\n    takePoint2 = false;\n\n    // Line starts at point1 and point1 is inside the board\n    takePoint1 = !straightFirst && Math.abs(point1.usrCoords[0]) >= Mat.eps && point1.scrCoords[1] >= 0.0 && point1.scrCoords[1] <= el.board.canvasWidth && point1.scrCoords[2] >= 0.0 && point1.scrCoords[2] <= el.board.canvasHeight;\n\n    // Line ends at point2 and point2 is inside the board\n    takePoint2 = !straightLast && Math.abs(point2.usrCoords[0]) >= Mat.eps && point2.scrCoords[1] >= 0.0 && point2.scrCoords[1] <= el.board.canvasWidth && point2.scrCoords[2] >= 0.0 && point2.scrCoords[2] <= el.board.canvasHeight;\n\n    // Intersect the line with the four borders of the board.\n    intersection = this.meetLineBoard(c, el.board, margin);\n    intersect1 = intersection[0];\n    intersect2 = intersection[1];\n\n    /**\n     * At this point we have four points:\n     * point1 and point2 are the first and the second defining point on the line,\n     * intersect1, intersect2 are the intersections of the line with border around the board.\n     */\n\n    /*\n     * Here we handle rays where both defining points are outside of the board.\n     */\n    // If both points are outside and the complete ray is outside we do nothing\n    if (!takePoint1 && !takePoint2) {\n      // Ray starting at point 1\n      if (!straightFirst && straightLast && !this.isSameDirection(point1, point2, intersect1) && !this.isSameDirection(point1, point2, intersect2)) {\n        return;\n      }\n\n      // Ray starting at point 2\n      if (straightFirst && !straightLast && !this.isSameDirection(point2, point1, intersect1) && !this.isSameDirection(point2, point1, intersect2)) {\n        return;\n      }\n    }\n\n    /*\n     * If at least one of the defining points is outside of the board\n     * we take intersect1 or intersect2 as one of the end points\n     * The order is also important for arrows of axes\n     */\n    if (!takePoint1) {\n      if (!takePoint2) {\n        // Two border intersection points are used\n        if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n          p1 = intersect1;\n          p2 = intersect2;\n        } else {\n          p2 = intersect1;\n          p1 = intersect2;\n        }\n      } else {\n        // One border intersection points is used\n        if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n          p1 = intersect1;\n        } else {\n          p1 = intersect2;\n        }\n      }\n    } else {\n      if (!takePoint2) {\n        // One border intersection points is used\n        if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n          p2 = intersect2;\n        } else {\n          p2 = intersect1;\n        }\n      }\n    }\n    if (p1) {\n      //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));\n      point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords);\n    }\n    if (p2) {\n      //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));\n      point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords);\n    }\n  },\n  /**\n   * A line can be a segment, a straight, or a ray. so it is not always delimited by point1 and point2.\n   *\n   * This method adjusts the line's delimiting points taking into account its nature, the viewport defined\n   * by the board.\n   *\n   * A segment is delimited by start and end point, a straight line or ray is delimited until it meets the\n   * boards boundaries. However, if the line has infinite ticks, it will be delimited by the projection of\n   * the boards vertices onto itself.\n   *\n   * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.\n   * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and\n   * set by this method.\n   * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set\n   * by this method.\n   * @see Line\n   * @see JXG.Line\n   */\n  calcLineDelimitingPoints: function (el, point1, point2) {\n    var distP1P2,\n      boundingBox,\n      lineSlope,\n      intersect1,\n      intersect2,\n      straightFirst,\n      straightLast,\n      c,\n      p1,\n      p2,\n      takePoint1 = false,\n      takePoint2 = false;\n    straightFirst = Type.evaluate(el.visProp.straightfirst);\n    straightLast = Type.evaluate(el.visProp.straightlast);\n\n    // If one of the point is an ideal point in homogeneous coordinates\n    // drawing of line segments or rays are not possible.\n    if (Math.abs(point1.scrCoords[0]) < Mat.eps) {\n      straightFirst = true;\n    }\n    if (Math.abs(point2.scrCoords[0]) < Mat.eps) {\n      straightLast = true;\n    }\n\n    // Compute the stdform of the line in screen coordinates.\n    c = [];\n    c[0] = el.stdform[0] - el.stdform[1] * el.board.origin.scrCoords[1] / el.board.unitX + el.stdform[2] * el.board.origin.scrCoords[2] / el.board.unitY;\n    c[1] = el.stdform[1] / el.board.unitX;\n    c[2] = -el.stdform[2] / el.board.unitY;\n\n    // p1=p2\n    if (isNaN(c[0] + c[1] + c[2])) {\n      return;\n    }\n    takePoint1 = !straightFirst;\n    takePoint2 = !straightLast;\n    // Intersect the board vertices on the line to establish the available visual space for the infinite ticks\n    // Based on the slope of the line we can optimise and only project the two outer vertices\n\n    // boundingBox = [x1, y1, x2, y2] upper left, lower right vertices\n    boundingBox = el.board.getBoundingBox();\n    lineSlope = el.getSlope();\n    if (lineSlope >= 0) {\n      // project vertices (x2,y1) (x1, y2)\n      intersect1 = this.projectPointToLine({\n        coords: {\n          usrCoords: [1, boundingBox[2], boundingBox[1]]\n        }\n      }, el, el.board);\n      intersect2 = this.projectPointToLine({\n        coords: {\n          usrCoords: [1, boundingBox[0], boundingBox[3]]\n        }\n      }, el, el.board);\n    } else {\n      // project vertices (x1, y1) (x2, y2)\n      intersect1 = this.projectPointToLine({\n        coords: {\n          usrCoords: [1, boundingBox[0], boundingBox[1]]\n        }\n      }, el, el.board);\n      intersect2 = this.projectPointToLine({\n        coords: {\n          usrCoords: [1, boundingBox[2], boundingBox[3]]\n        }\n      }, el, el.board);\n    }\n\n    /**\n     * we have four points:\n     * point1 and point2 are the first and the second defining point on the line,\n     * intersect1, intersect2 are the intersections of the line with border around the board.\n     */\n\n    /*\n     * Here we handle rays/segments where both defining points are outside of the board.\n     */\n    if (!takePoint1 && !takePoint2) {\n      // Segment, if segment does not cross the board, do nothing\n      if (!straightFirst && !straightLast) {\n        distP1P2 = point1.distance(Const.COORDS_BY_USER, point2);\n        // if  intersect1 not between point1 and point2\n        if (Math.abs(point1.distance(Const.COORDS_BY_USER, intersect1) + intersect1.distance(Const.COORDS_BY_USER, point2) - distP1P2) > Mat.eps) {\n          return;\n        }\n        // if insersect2 not between point1 and point2\n        if (Math.abs(point1.distance(Const.COORDS_BY_USER, intersect2) + intersect2.distance(Const.COORDS_BY_USER, point2) - distP1P2) > Mat.eps) {\n          return;\n        }\n      }\n\n      // If both points are outside and the complete ray is outside we do nothing\n      // Ray starting at point 1\n      if (!straightFirst && straightLast && !this.isSameDirection(point1, point2, intersect1) && !this.isSameDirection(point1, point2, intersect2)) {\n        return;\n      }\n\n      // Ray starting at point 2\n      if (straightFirst && !straightLast && !this.isSameDirection(point2, point1, intersect1) && !this.isSameDirection(point2, point1, intersect2)) {\n        return;\n      }\n    }\n\n    /*\n     * If at least one of the defining points is outside of the board\n     * we take intersect1 or intersect2 as one of the end points\n     * The order is also important for arrows of axes\n     */\n    if (!takePoint1) {\n      if (!takePoint2) {\n        // Two border intersection points are used\n        if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n          p1 = intersect1;\n          p2 = intersect2;\n        } else {\n          p2 = intersect1;\n          p1 = intersect2;\n        }\n      } else {\n        // One border intersection points is used\n        if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n          p1 = intersect1;\n        } else {\n          p1 = intersect2;\n        }\n      }\n    } else {\n      if (!takePoint2) {\n        // One border intersection points is used\n        if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n          p2 = intersect2;\n        } else {\n          p2 = intersect1;\n        }\n      }\n    }\n    if (p1) {\n      //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));\n      point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords);\n    }\n    if (p2) {\n      //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));\n      point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords);\n    }\n  },\n  /**\n   * Calculates the visProp.position corresponding to a given angle.\n   * @param {number} angle angle in radians. Must be in range (-2pi,2pi).\n   */\n  calcLabelQuadrant: function (angle) {\n    var q;\n    if (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n    q = Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;\n    return [\"rt\", \"urt\", \"top\", \"ulft\", \"lft\", \"llft\", \"lrt\"][q];\n  },\n  /**\n   * The vectors <tt>p2-p1</tt> and <tt>i2-i1</tt> are supposed to be collinear. If their cosine is positive\n   * they point into the same direction otherwise they point in opposite direction.\n   * @param {JXG.Coords} p1\n   * @param {JXG.Coords} p2\n   * @param {JXG.Coords} i1\n   * @param {JXG.Coords} i2\n   * @returns {Boolean} True, if <tt>p2-p1</tt> and <tt>i2-i1</tt> point into the same direction\n   */\n  isSameDir: function (p1, p2, i1, i2) {\n    var dpx = p2.usrCoords[1] - p1.usrCoords[1],\n      dpy = p2.usrCoords[2] - p1.usrCoords[2],\n      dix = i2.usrCoords[1] - i1.usrCoords[1],\n      diy = i2.usrCoords[2] - i1.usrCoords[2];\n    if (Math.abs(p2.usrCoords[0]) < Mat.eps) {\n      dpx = p2.usrCoords[1];\n      dpy = p2.usrCoords[2];\n    }\n    if (Math.abs(p1.usrCoords[0]) < Mat.eps) {\n      dpx = -p1.usrCoords[1];\n      dpy = -p1.usrCoords[2];\n    }\n    return dpx * dix + dpy * diy >= 0;\n  },\n  /**\n   * If you're looking from point \"start\" towards point \"s\" and you can see the point \"p\", return true.\n   * Otherwise return false.\n   * @param {JXG.Coords} start The point you're standing on.\n   * @param {JXG.Coords} p The point in which direction you're looking.\n   * @param {JXG.Coords} s The point that should be visible.\n   * @returns {Boolean} True, if from start the point p is in the same direction as s is, that means s-start = k*(p-start) with k>=0.\n   */\n  isSameDirection: function (start, p, s) {\n    var dx,\n      dy,\n      sx,\n      sy,\n      r = false;\n    dx = p.usrCoords[1] - start.usrCoords[1];\n    dy = p.usrCoords[2] - start.usrCoords[2];\n    sx = s.usrCoords[1] - start.usrCoords[1];\n    sy = s.usrCoords[2] - start.usrCoords[2];\n    if (Math.abs(dx) < Mat.eps) {\n      dx = 0;\n    }\n    if (Math.abs(dy) < Mat.eps) {\n      dy = 0;\n    }\n    if (Math.abs(sx) < Mat.eps) {\n      sx = 0;\n    }\n    if (Math.abs(sy) < Mat.eps) {\n      sy = 0;\n    }\n    if (dx >= 0 && sx >= 0) {\n      r = dy >= 0 && sy >= 0 || dy <= 0 && sy <= 0;\n    } else if (dx <= 0 && sx <= 0) {\n      r = dy >= 0 && sy >= 0 || dy <= 0 && sy <= 0;\n    }\n    return r;\n  },\n  /**\n   * Determinant of three points in the Euclidean plane.\n   * Zero, if the points are collinear. Used to determine of a point q is left or\n   * right to a segment defined by points p1 and p2.\n   *\n   * @param  {Array} p1 Coordinates of the first point of the segment. Array of length 3. First coordinate is equal to 1.\n   * @param  {Array} p2 Coordinates of the second point of the segment. Array of length 3. First coordinate is equal to 1.\n   * @param  {Array} q Coordinates of the point. Array of length 3. First coordinate is equal to 1.\n   * @return {Number} Signed area of the triangle formed by these three points.\n   *\n   * @see #windingNumber\n   */\n  det3p: function (p1, p2, q) {\n    return (p1[1] - q[1]) * (p2[2] - q[2]) - (p2[1] - q[1]) * (p1[2] - q[2]);\n  },\n  /**\n   * Winding number of a point in respect to a polygon path.\n   *\n   * The point is regarded outside if the winding number is zero,\n   * inside otherwise. The algorithm tries to find degenerate cases, i.e.\n   * if the point is on the path. This is regarded as \"outside\".\n   * If the point is a vertex of the path, it is regarded as \"inside\".\n   *\n   * Implementation of algorithm 7 from \"The point in polygon problem for\n   * arbitrary polygons\" by Kai Hormann and Alexander Agathos, Computational Geometry,\n   * Volume 20, Issue 3, November 2001, Pages 131-144.\n   *\n   * @param  {Array} usrCoords Homogenous coordinates of the point\n   * @param  {Array} path      Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements\n   * do not have to be full points, but have to have a subobject \"coords\" or should be of type JXG.Coords.\n   * @param  {Boolean} [doNotClosePath=false] If true the last point of the path is not connected to the first point.\n   * This is necessary if the path consists of two or more closed subpaths, e.g. if the figure has a hole.\n   *\n   * @return {Number}          Winding number of the point. The point is\n   *                           regarded outside if the winding number is zero,\n   *                           inside otherwise.\n   */\n  windingNumber: function (usrCoords, path, doNotClosePath) {\n    var wn = 0,\n      le = path.length,\n      x = usrCoords[1],\n      y = usrCoords[2],\n      p0,\n      p1,\n      p2,\n      d,\n      sign,\n      i,\n      off = 0;\n    if (le === 0) {\n      return 0;\n    }\n    doNotClosePath = doNotClosePath || false;\n    if (doNotClosePath) {\n      off = 1;\n    }\n\n    // Infinite points are declared outside\n    if (isNaN(x) || isNaN(y)) {\n      return 1;\n    }\n    if (Type.exists(path[0].coords)) {\n      p0 = path[0].coords;\n      p1 = path[le - 1].coords;\n    } else {\n      p0 = path[0];\n      p1 = path[le - 1];\n    }\n    // Handle the case if the point is the first vertex of the path, i.e. inside.\n    if (p0.usrCoords[1] === x && p0.usrCoords[2] === y) {\n      return 1;\n    }\n    for (i = 0; i < le - off; i++) {\n      // Consider the edge from p1 = path[i] to p2 = path[i+1]isClosedPath\n      if (Type.exists(path[i].coords)) {\n        p1 = path[i].coords.usrCoords;\n        p2 = path[(i + 1) % le].coords.usrCoords;\n      } else {\n        p1 = path[i].usrCoords;\n        p2 = path[(i + 1) % le].usrCoords;\n      }\n\n      // If one of the two points p1, p2 is undefined or infinite,\n      // move on.\n      if (p1[0] === 0 || p2[0] === 0 || isNaN(p1[1]) || isNaN(p2[1]) || isNaN(p1[2]) || isNaN(p2[2])) {\n        continue;\n      }\n      if (p2[2] === y) {\n        if (p2[1] === x) {\n          return 1;\n        }\n        if (p1[2] === y && p2[1] > x === p1[1] < x) {\n          return 0;\n        }\n      }\n      if (p1[2] < y !== p2[2] < y) {\n        // Crossing\n        sign = 2 * (p2[2] > p1[2] ? 1 : 0) - 1;\n        if (p1[1] >= x) {\n          if (p2[1] > x) {\n            wn += sign;\n          } else {\n            d = this.det3p(p1, p2, usrCoords);\n            if (d === 0) {\n              // Point is on line, i.e. outside\n              return 0;\n            }\n            if (d > 0 + Mat.eps === p2[2] > p1[2]) {\n              // Right crossing\n              wn += sign;\n            }\n          }\n        } else {\n          if (p2[1] > x) {\n            d = this.det3p(p1, p2, usrCoords);\n            if (d > 0 + Mat.eps === p2[2] > p1[2]) {\n              // Right crossing\n              wn += sign;\n            }\n          }\n        }\n      }\n    }\n    return wn;\n  },\n  /**\n   * Decides if a point (x,y) is inside of a path / polygon.\n   * Does not work correct if the path has hole. In this case, windingNumber is the preferred method.\n   * Implements W. Randolf Franklin's pnpoly method.\n   *\n   * See <a href=\"https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\">https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html</a>.\n   *\n   * @param {Number} x_in x-coordinate (screen or user coordinates)\n   * @param {Number} y_in y-coordinate (screen or user coordinates)\n   * @param  {Array} path  Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements\n   * do not have to be full points, but have to have a subobject \"coords\" or should be of type JXG.Coords.\n   * @param {Number} [coord_type=JXG.COORDS_BY_SCREEN] Type of coordinates used here.\n   *   Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.\n   *   Default value is JXG.COORDS_BY_SCREEN.\n   *\n   * @returns {Boolean} if (x_in, y_in) is inside of the polygon.\n   * @see JXG.Polygon.hasPoint\n   * @see JXG.Polygon.pnpoly\n   * @see #windingNumber\n   *\n   * @example\n   * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n   * var p = board.create('point', [4, 3]);\n   * var txt = board.create('text', [-1, 0.5, function() {\n   *   return 'Point A is inside of the polygon = ' +\n   *     JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);\n   * }]);\n   *\n   * </pre><div id=\"JXG4656ed42-f965-4e35-bb66-c334a4529683\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG4656ed42-f965-4e35-bb66-c334a4529683',\n   *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});\n   *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n   *     var p = board.create('point', [4, 3]);\n   *     var txt = board.create('text', [-1, 0.5, function() {\n   *     \t\treturn 'Point A is inside of the polygon = ' + JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);\n   *     }]);\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   */\n  pnpoly: function (x_in, y_in, path, coord_type) {\n    var i,\n      j,\n      len,\n      x,\n      y,\n      crds,\n      v = path,\n      vi,\n      vj,\n      isIn = false;\n    if (coord_type === Const.COORDS_BY_USER) {\n      crds = new Coords(Const.COORDS_BY_USER, [x_in, y_in], this.board);\n      x = crds.scrCoords[1];\n      y = crds.scrCoords[2];\n    } else {\n      x = x_in;\n      y = y_in;\n    }\n    len = path.length;\n    for (i = 0, j = len - 2; i < len - 1; j = i++) {\n      vi = Type.exists(v[i].coords) ? v[i].coords : v[i];\n      vj = Type.exists(v[j].coords) ? v[j].coords : v[j];\n      if (vi.scrCoords[2] > y !== vj.scrCoords[2] > y && x < (vj.scrCoords[1] - vi.scrCoords[1]) * (y - vi.scrCoords[2]) / (vj.scrCoords[2] - vi.scrCoords[2]) + vi.scrCoords[1]) {\n        isIn = !isIn;\n      }\n    }\n    return isIn;\n  },\n  /****************************************/\n  /****          INTERSECTIONS         ****/\n  /****************************************/\n\n  /**\n   * Generate the function which computes the coordinates of the intersection point.\n   * Primarily used in {@link JXG.Point#createIntersectionPoint}.\n   * @param {JXG.Board} board object\n   * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number|Function} el1,el2,i The result will be a intersection point on el1 and el2.\n   * i determines the intersection point if two points are available: <ul>\n   *   <li>i==0: use the positive square root,</li>\n   *   <li>i==1: use the negative square root.</li></ul>\n   * See further {@link JXG.Point#createIntersectionPoint}.\n   * @param {Boolean} alwaysintersect. Flag that determines if segments and arc can have an outer intersection point\n   * on their defining line or circle.\n   * @returns {Function} Function returning a {@link JXG.Coords} object that determines\n   * the intersection point.\n   */\n  intersectionFunction: function (board, el1, el2, i, j, alwaysintersect) {\n    var func,\n      that = this,\n      el1_isArcType = false,\n      el2_isArcType = false;\n    el1_isArcType = el1.elementClass === Const.OBJECT_CLASS_CURVE && (el1.type === Const.OBJECT_TYPE_ARC || el1.type === Const.OBJECT_TYPE_SECTOR) ? true : false;\n    el2_isArcType = el2.elementClass === Const.OBJECT_CLASS_CURVE && (el2.type === Const.OBJECT_TYPE_ARC || el2.type === Const.OBJECT_TYPE_SECTOR) ? true : false;\n    if ((el1.elementClass === Const.OBJECT_CLASS_CURVE || el2.elementClass === Const.OBJECT_CLASS_CURVE) && (el1.elementClass === Const.OBJECT_CLASS_CURVE || el1.elementClass === Const.OBJECT_CLASS_CIRCLE) && (el2.elementClass === Const.OBJECT_CLASS_CURVE || el2.elementClass === Const.OBJECT_CLASS_CIRCLE) /*&&\n                                                                                                                                                                                                                                                                                                                   !(el1_isArcType && el2_isArcType)*/) {\n      // curve - curve\n      // with the exception that both elements are arc types\n      /** @ignore */\n      func = function () {\n        return that.meetCurveCurve(el1, el2, i, j, el1.board);\n      };\n    } else if (el1.elementClass === Const.OBJECT_CLASS_CURVE && !el1_isArcType && el2.elementClass === Const.OBJECT_CLASS_LINE || el2.elementClass === Const.OBJECT_CLASS_CURVE && !el2_isArcType && el1.elementClass === Const.OBJECT_CLASS_LINE) {\n      // curve - line (this includes intersections between conic sections and lines)\n      // with the exception that the curve is of arc type\n      /** @ignore */\n      func = function () {\n        return that.meetCurveLine(el1, el2, i, el1.board, Type.evaluate(alwaysintersect));\n      };\n    } else if (el1.type === Const.OBJECT_TYPE_POLYGON || el2.type === Const.OBJECT_TYPE_POLYGON) {\n      // polygon - other\n      // Uses the Greiner-Hormann clipping algorithm\n      // Not implemented: polygon - point\n\n      if (el1.elementClass === Const.OBJECT_CLASS_LINE) {\n        // line - path\n        /** @ignore */\n        func = function () {\n          var first1 = Type.evaluate(el1.visProp.straightfirst),\n            last1 = Type.evaluate(el1.visProp.straightlast),\n            first2 = Type.evaluate(el2.visProp.straightfirst),\n            last2 = Type.evaluate(el2.visProp.straightlast),\n            a_not;\n          a_not = !Type.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2);\n          return that.meetPolygonLine(el2, el1, i, el1.board, a_not);\n        };\n      } else if (el2.elementClass === Const.OBJECT_CLASS_LINE) {\n        // path - line\n        func = function () {\n          var first1 = Type.evaluate(el1.visProp.straightfirst),\n            last1 = Type.evaluate(el1.visProp.straightlast),\n            first2 = Type.evaluate(el2.visProp.straightfirst),\n            last2 = Type.evaluate(el2.visProp.straightlast),\n            a_not;\n          a_not = !Type.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2);\n          return that.meetPolygonLine(el1, el2, i, el1.board, a_not);\n        };\n      } else {\n        // path - path\n        /** @ignore */\n        func = function () {\n          return that.meetPathPath(el1, el2, i, el1.board);\n        };\n      }\n    } else if (el1.elementClass === Const.OBJECT_CLASS_LINE && el2.elementClass === Const.OBJECT_CLASS_LINE) {\n      // line - line, lines may also be segments.\n      /** @ignore */\n      func = function () {\n        var res,\n          c,\n          first1 = Type.evaluate(el1.visProp.straightfirst),\n          last1 = Type.evaluate(el1.visProp.straightlast),\n          first2 = Type.evaluate(el2.visProp.straightfirst),\n          last2 = Type.evaluate(el2.visProp.straightlast);\n\n        /**\n         * If one of the lines is a segment or ray and\n         * the intersection point should disappear if outside\n         * of the segment or ray we call\n         * meetSegmentSegment\n         */\n        if (!Type.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2)) {\n          res = that.meetSegmentSegment(el1.point1.coords.usrCoords, el1.point2.coords.usrCoords, el2.point1.coords.usrCoords, el2.point2.coords.usrCoords);\n          if (!first1 && res[1] < 0 || !last1 && res[1] > 1 || !first2 && res[2] < 0 || !last2 && res[2] > 1) {\n            // Non-existent\n            c = [0, NaN, NaN];\n          } else {\n            c = res[0];\n          }\n          return new Coords(Const.COORDS_BY_USER, c, el1.board);\n        }\n        return that.meet(el1.stdform, el2.stdform, i, el1.board);\n      };\n    } else {\n      // All other combinations of circles and lines,\n      // Arc types are treated as circles.\n      /** @ignore */\n      func = function () {\n        var res = that.meet(el1.stdform, el2.stdform, i, el1.board),\n          has = true,\n          first,\n          last,\n          r;\n        if (Type.evaluate(alwaysintersect)) {\n          return res;\n        }\n        if (el1.elementClass === Const.OBJECT_CLASS_LINE) {\n          first = Type.evaluate(el1.visProp.straightfirst);\n          last = Type.evaluate(el1.visProp.straightlast);\n          if (!first || !last) {\n            r = that.affineRatio(el1.point1.coords, el1.point2.coords, res);\n            if (!last && r > 1 + Mat.eps || !first && r < 0 - Mat.eps) {\n              return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n            }\n          }\n        }\n        if (el2.elementClass === Const.OBJECT_CLASS_LINE) {\n          first = Type.evaluate(el2.visProp.straightfirst);\n          last = Type.evaluate(el2.visProp.straightlast);\n          if (!first || !last) {\n            r = that.affineRatio(el2.point1.coords, el2.point2.coords, res);\n            if (!last && r > 1 + Mat.eps || !first && r < 0 - Mat.eps) {\n              return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n            }\n          }\n        }\n        if (el1_isArcType) {\n          has = that.coordsOnArc(el1, res);\n          if (has && el2_isArcType) {\n            has = that.coordsOnArc(el2, res);\n          }\n          if (!has) {\n            return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n          }\n        }\n        return res;\n      };\n    }\n    return func;\n  },\n  /**\n   * Returns true if the coordinates are on the arc element,\n   * false otherwise. Usually, coords is an intersection\n   * on the circle line. Now it is decided if coords are on the\n   * circle restricted to the arc line.\n   * @param  {Arc} arc arc or sector element\n   * @param  {JXG.Coords} coords Coords object of an intersection\n   * @returns {Boolean}\n   * @private\n   */\n  coordsOnArc: function (arc, coords) {\n    var angle = this.rad(arc.radiuspoint, arc.center, coords.usrCoords.slice(1)),\n      alpha = 0.0,\n      beta = this.rad(arc.radiuspoint, arc.center, arc.anglepoint),\n      ev_s = Type.evaluate(arc.visProp.selection);\n    if (ev_s === \"minor\" && beta > Math.PI || ev_s === \"major\" && beta < Math.PI) {\n      alpha = beta;\n      beta = 2 * Math.PI;\n    }\n    if (angle < alpha || angle > beta) {\n      return false;\n    }\n    return true;\n  },\n  /**\n   * Computes the intersection of a pair of lines, circles or both.\n   * It uses the internal data array stdform of these elements.\n   * @param {Array} el1 stdform of the first element (line or circle)\n   * @param {Array} el2 stdform of the second element (line or circle)\n   * @param {Number|Function} i Index of the intersection point that should be returned.\n   * @param board Reference to the board.\n   * @returns {JXG.Coords} Coordinates of one of the possible two or more intersection points.\n   * Which point will be returned is determined by i.\n   */\n  meet: function (el1, el2, i, board) {\n    var result,\n      eps = Mat.eps;\n    if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) < eps) {\n      // line line\n      result = this.meetLineLine(el1, el2, i, board);\n    } else if (Math.abs(el1[3]) >= eps && Math.abs(el2[3]) < eps) {\n      // circle line\n      result = this.meetLineCircle(el2, el1, i, board);\n    } else if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) >= eps) {\n      // line circle\n      result = this.meetLineCircle(el1, el2, i, board);\n    } else {\n      // circle circle\n      result = this.meetCircleCircle(el1, el2, i, board);\n    }\n    return result;\n  },\n  /**\n   * Intersection of the line with the board\n   * @param  {Array}     line   stdform of the line in screen coordinates\n   * @param  {JXG.Board} board  reference to a board.\n   * @param  {Number}    margin optional margin, to avoid the display of the small sides of lines.\n   * @returns {Array}            [intersection coords 1, intersection coords 2]\n   */\n  meetLineBoard: function (line, board, margin) {\n    // Intersect the line with the four borders of the board.\n    var s = [],\n      intersect1,\n      intersect2,\n      i,\n      j;\n    if (!Type.exists(margin)) {\n      margin = 0;\n    }\n\n    // top\n    s[0] = Mat.crossProduct(line, [margin, 0, 1]);\n    // left\n    s[1] = Mat.crossProduct(line, [margin, 1, 0]);\n    // bottom\n    s[2] = Mat.crossProduct(line, [-margin - board.canvasHeight, 0, 1]);\n    // right\n    s[3] = Mat.crossProduct(line, [-margin - board.canvasWidth, 1, 0]);\n\n    // Normalize the intersections\n    for (i = 0; i < 4; i++) {\n      if (Math.abs(s[i][0]) > Mat.eps) {\n        for (j = 2; j > 0; j--) {\n          s[i][j] /= s[i][0];\n        }\n        s[i][0] = 1.0;\n      }\n    }\n\n    // line is parallel to \"left\", take \"top\" and \"bottom\"\n    if (Math.abs(s[1][0]) < Mat.eps) {\n      intersect1 = s[0]; // top\n      intersect2 = s[2]; // bottom\n      // line is parallel to \"top\", take \"left\" and \"right\"\n    } else if (Math.abs(s[0][0]) < Mat.eps) {\n      intersect1 = s[1]; // left\n      intersect2 = s[3]; // right\n      // left intersection out of board (above)\n    } else if (s[1][2] < 0) {\n      intersect1 = s[0]; // top\n\n      // right intersection out of board (below)\n      if (s[3][2] > board.canvasHeight) {\n        intersect2 = s[2]; // bottom\n      } else {\n        intersect2 = s[3]; // right\n      }\n      // left intersection out of board (below)\n    } else if (s[1][2] > board.canvasHeight) {\n      intersect1 = s[2]; // bottom\n\n      // right intersection out of board (above)\n      if (s[3][2] < 0) {\n        intersect2 = s[0]; // top\n      } else {\n        intersect2 = s[3]; // right\n      }\n    } else {\n      intersect1 = s[1]; // left\n\n      // right intersection out of board (above)\n      if (s[3][2] < 0) {\n        intersect2 = s[0]; // top\n        // right intersection out of board (below)\n      } else if (s[3][2] > board.canvasHeight) {\n        intersect2 = s[2]; // bottom\n      } else {\n        intersect2 = s[3]; // right\n      }\n    }\n    return [new Coords(Const.COORDS_BY_SCREEN, intersect1.slice(1), board), new Coords(Const.COORDS_BY_SCREEN, intersect2.slice(1), board)];\n  },\n  /**\n   * Intersection of two lines.\n   * @param {Array} l1 stdform of the first line\n   * @param {Array} l2 stdform of the second line\n   * @param {number} i unused\n   * @param {JXG.Board} board Reference to the board.\n   * @returns {JXG.Coords} Coordinates of the intersection point.\n   */\n  meetLineLine: function (l1, l2, i, board) {\n    var s = isNaN(l1[5] + l2[5]) ? [0, 0, 0] : Mat.crossProduct(l1, l2);\n\n    // Make intersection of parallel lines more robust:\n    if (Math.abs(s[0]) < 1.0e-14) {\n      s[0] = 0;\n    }\n    return new Coords(Const.COORDS_BY_USER, s, board);\n  },\n  /**\n   * Intersection of line and circle.\n   * @param {Array} lin stdform of the line\n   * @param {Array} circ stdform of the circle\n   * @param {number|function} i number of the returned intersection point.\n   *   i==0: use the positive square root,\n   *   i==1: use the negative square root.\n   * @param {JXG.Board} board Reference to a board.\n   * @returns {JXG.Coords} Coordinates of the intersection point\n   */\n  meetLineCircle: function (lin, circ, i, board) {\n    var a, b, c, d, n, A, B, C, k, t;\n\n    // Radius is zero, return center of circle\n    if (circ[4] < Mat.eps) {\n      if (Math.abs(Mat.innerProduct([1, circ[6], circ[7]], lin, 3)) < Mat.eps) {\n        return new Coords(Const.COORDS_BY_USER, circ.slice(6, 8), board);\n      }\n      return new Coords(Const.COORDS_BY_USER, [NaN, NaN], board);\n    }\n    c = circ[0];\n    b = circ.slice(1, 3);\n    a = circ[3];\n    d = lin[0];\n    n = lin.slice(1, 3);\n\n    // Line is assumed to be normalized. Therefore, nn==1 and we can skip some operations:\n    /*\n     var nn = n[0]*n[0]+n[1]*n[1];\n     A = a*nn;\n     B = (b[0]*n[1]-b[1]*n[0])*nn;\n     C = a*d*d - (b[0]*n[0]+b[1]*n[1])*d + c*nn;\n     */\n    A = a;\n    B = b[0] * n[1] - b[1] * n[0];\n    C = a * d * d - (b[0] * n[0] + b[1] * n[1]) * d + c;\n    k = B * B - 4 * A * C;\n    if (k > -Mat.eps * Mat.eps) {\n      k = Math.sqrt(Math.abs(k));\n      t = [(-B + k) / (2 * A), (-B - k) / (2 * A)];\n      return Type.evaluate(i) === 0 ? new Coords(Const.COORDS_BY_USER, [-t[0] * -n[1] - d * n[0], -t[0] * n[0] - d * n[1]], board) : new Coords(Const.COORDS_BY_USER, [-t[1] * -n[1] - d * n[0], -t[1] * n[0] - d * n[1]], board);\n    }\n    return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n  },\n  /**\n   * Intersection of two circles.\n   * @param {Array} circ1 stdform of the first circle\n   * @param {Array} circ2 stdform of the second circle\n   * @param {number|function} i number of the returned intersection point.\n   *   i==0: use the positive square root,\n   *   i==1: use the negative square root.\n   * @param {JXG.Board} board Reference to the board.\n   * @returns {JXG.Coords} Coordinates of the intersection point\n   */\n  meetCircleCircle: function (circ1, circ2, i, board) {\n    var radicalAxis;\n\n    // Radius is zero, return center of circle, if on other circle\n    if (circ1[4] < Mat.eps) {\n      if (Math.abs(this.distance(circ1.slice(6, 2), circ2.slice(6, 8)) - circ2[4]) < Mat.eps) {\n        return new Coords(Const.COORDS_BY_USER, circ1.slice(6, 8), board);\n      }\n      return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n    }\n\n    // Radius is zero, return center of circle, if on other circle\n    if (circ2[4] < Mat.eps) {\n      if (Math.abs(this.distance(circ2.slice(6, 2), circ1.slice(6, 8)) - circ1[4]) < Mat.eps) {\n        return new Coords(Const.COORDS_BY_USER, circ2.slice(6, 8), board);\n      }\n      return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n    }\n    radicalAxis = [circ2[3] * circ1[0] - circ1[3] * circ2[0], circ2[3] * circ1[1] - circ1[3] * circ2[1], circ2[3] * circ1[2] - circ1[3] * circ2[2], 0, 1, Infinity, Infinity, Infinity];\n    radicalAxis = Mat.normalize(radicalAxis);\n    return this.meetLineCircle(radicalAxis, circ1, i, board);\n  },\n  /**\n   * Compute an intersection of the curves c1 and c2.\n   * We want to find values t1, t2 such that\n   * c1(t1) = c2(t2), i.e. (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).\n   *\n   * Methods: segment-wise intersections (default) or generalized Newton method.\n   * @param {JXG.Curve} c1 Curve, Line or Circle\n   * @param {JXG.Curve} c2 Curve, Line or Circle\n   * @param {Number|Function} nr the nr-th intersection point will be returned.\n   * @param {Number} t2ini not longer used.\n   * @param {JXG.Board} [board=c1.board] Reference to a board object.\n   * @param {String} [method='segment'] Intersection method, possible values are 'newton' and 'segment'.\n   * @returns {JXG.Coords} intersection point\n   */\n  meetCurveCurve: function (c1, c2, nr, t2ini, board, method) {\n    var co;\n    if (Type.exists(method) && method === \"newton\") {\n      co = Numerics.generalizedNewton(c1, c2, Type.evaluate(nr), t2ini);\n    } else {\n      if (c1.bezierDegree === 3 || c2.bezierDegree === 3) {\n        co = this.meetBezierCurveRedBlueSegments(c1, c2, nr);\n      } else {\n        co = this.meetCurveRedBlueSegments(c1, c2, nr);\n      }\n    }\n    return new Coords(Const.COORDS_BY_USER, co, board);\n  },\n  /**\n   * Intersection of curve with line,\n   * Order of input does not matter for el1 and el2.\n   * From version 0.99.7 on this method calls\n   * {@link JXG.Math.Geometry.meetCurveLineDiscrete}.\n   * If higher precision is needed, {@link JXG.Math.Geometry.meetCurveLineContinuous}\n   * has to be used.\n   *\n   * @param {JXG.Curve|JXG.Line} el1 Curve or Line\n   * @param {JXG.Curve|JXG.Line} el2 Curve or Line\n   * @param {Number|Function} nr the nr-th intersection point will be returned.\n   * @param {JXG.Board} [board=el1.board] Reference to a board object.\n   * @param {Boolean} alwaysIntersect If false just the segment between the two defining points are tested for intersection\n   * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n   * the ideal point [0,1,0] is returned.\n   */\n  meetCurveLine: function (el1, el2, nr, board, alwaysIntersect) {\n    var v = [0, NaN, NaN],\n      cu,\n      li;\n    if (!Type.exists(board)) {\n      board = el1.board;\n    }\n    if (el1.elementClass === Const.OBJECT_CLASS_CURVE) {\n      cu = el1;\n      li = el2;\n    } else {\n      cu = el2;\n      li = el1;\n    }\n    v = this.meetCurveLineDiscrete(cu, li, nr, board, !alwaysIntersect);\n    return v;\n  },\n  /**\n   * Intersection of line and curve, continuous case.\n   * Finds the nr-the intersection point\n   * Uses {@link JXG.Math.Geometry.meetCurveLineDiscrete} as a first approximation.\n   * A more exact solution is then found with {@link JXG.Math.Numerics.root}.\n   *\n   * @param {JXG.Curve} cu Curve\n   * @param {JXG.Line} li Line\n   * @param {NumberFunction} nr Will return the nr-th intersection point.\n   * @param {JXG.Board} board\n   * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the\n   * line defined by the segment\n   * @returns {JXG.Coords} Coords object containing the intersection.\n   */\n  meetCurveLineContinuous: function (cu, li, nr, board, testSegment) {\n    var t,\n      func0,\n      func1,\n      v,\n      x,\n      y,\n      z,\n      eps = Mat.eps,\n      epsLow = Mat.eps,\n      steps,\n      delta,\n      tnew,\n      i,\n      tmin,\n      fmin,\n      ft;\n    v = this.meetCurveLineDiscrete(cu, li, nr, board, testSegment);\n    x = v.usrCoords[1];\n    y = v.usrCoords[2];\n    func0 = function (t) {\n      var c1, c2;\n      if (t > cu.maxX() || t < cu.minX()) {\n        return Infinity;\n      }\n      c1 = x - cu.X(t);\n      c2 = y - cu.Y(t);\n      return c1 * c1 + c2 * c2;\n    };\n    func1 = function (t) {\n      var v = li.stdform[0] + li.stdform[1] * cu.X(t) + li.stdform[2] * cu.Y(t);\n      return v * v;\n    };\n\n    // Find t\n    steps = 50;\n    delta = (cu.maxX() - cu.minX()) / steps;\n    tnew = cu.minX();\n    fmin = 0.0001; //eps;\n    tmin = NaN;\n    for (i = 0; i < steps; i++) {\n      t = Numerics.root(func0, [Math.max(tnew, cu.minX()), Math.min(tnew + delta, cu.maxX())]);\n      ft = Math.abs(func0(t));\n      if (ft <= fmin) {\n        fmin = ft;\n        tmin = t;\n        if (fmin < eps) {\n          break;\n        }\n      }\n      tnew += delta;\n    }\n    t = tmin;\n    // Compute \"exact\" t\n    t = Numerics.root(func1, [Math.max(t - delta, cu.minX()), Math.min(t + delta, cu.maxX())]);\n    ft = func1(t);\n    // Is the point on the line?\n    if (isNaN(ft) || Math.abs(ft) > epsLow) {\n      z = 0.0; //NaN;\n    } else {\n      z = 1.0;\n    }\n    return new Coords(Const.COORDS_BY_USER, [z, cu.X(t), cu.Y(t)], board);\n  },\n  /**\n   * Intersection of line and curve, discrete case.\n   * Segments are treated as lines.\n   * Finding the nr-th intersection point should work for all nr.\n   * @param {JXG.Curve} cu\n   * @param {JXG.Line} li\n   * @param {Number|Function} nr\n   * @param {JXG.Board} board\n   * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the\n   * line defined by the segment\n   *\n   * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n   * the ideal point [0,1,0] is returned.\n   */\n  meetCurveLineDiscrete: function (cu, li, nr, board, testSegment) {\n    var i,\n      j,\n      n = Type.evaluate(nr),\n      p1,\n      p2,\n      p,\n      q,\n      lip1 = li.point1.coords.usrCoords,\n      lip2 = li.point2.coords.usrCoords,\n      d,\n      res,\n      cnt = 0,\n      len = cu.numberPoints,\n      ev_sf = Type.evaluate(li.visProp.straightfirst),\n      ev_sl = Type.evaluate(li.visProp.straightlast);\n\n    // In case, no intersection will be found we will take this\n    q = new Coords(Const.COORDS_BY_USER, [0, NaN, NaN], board);\n    if (lip1[0] === 0.0) {\n      lip1 = [1, lip2[1] + li.stdform[2], lip2[2] - li.stdform[1]];\n    } else if (lip2[0] === 0.0) {\n      lip2 = [1, lip1[1] + li.stdform[2], lip1[2] - li.stdform[1]];\n    }\n    p2 = cu.points[0].usrCoords;\n    for (i = 1; i < len; i += cu.bezierDegree) {\n      p1 = p2.slice(0);\n      p2 = cu.points[i].usrCoords;\n      d = this.distance(p1, p2);\n\n      // The defining points are not identical\n      if (d > Mat.eps) {\n        if (cu.bezierDegree === 3) {\n          res = this.meetBeziersegmentBeziersegment([cu.points[i - 1].usrCoords.slice(1), cu.points[i].usrCoords.slice(1), cu.points[i + 1].usrCoords.slice(1), cu.points[i + 2].usrCoords.slice(1)], [lip1.slice(1), lip2.slice(1)], testSegment);\n        } else {\n          res = [this.meetSegmentSegment(p1, p2, lip1, lip2)];\n        }\n        for (j = 0; j < res.length; j++) {\n          p = res[j];\n          if (0 <= p[1] && p[1] <= 1) {\n            if (cnt === n) {\n              /**\n               * If the intersection point is not part of the segment,\n               * this intersection point is set to non-existent.\n               * This prevents jumping behavior of the intersection points.\n               * But it may be discussed if it is the desired behavior.\n               */\n              if (testSegment && (!ev_sf && p[2] < 0 || !ev_sl && p[2] > 1)) {\n                return q; // break;\n              }\n              q = new Coords(Const.COORDS_BY_USER, p[0], board);\n              return q; // break;\n            }\n            cnt += 1;\n          }\n        }\n      }\n    }\n    return q;\n  },\n  /**\n   * Find the n-th intersection point of two curves named red (first parameter) and blue (second parameter).\n   * We go through each segment of the red curve and search if there is an intersection with a segemnt of the blue curve.\n   * This double loop, i.e. the outer loop runs along the red curve and the inner loop runs along the blue curve, defines\n   * the n-th intersection point. The segments are either line segments or Bezier curves of degree 3. This depends on\n   * the property bezierDegree of the curves.\n   * <p>\n   * This method works also for transformed curves, since only the already\n   * transformed points are used.\n   *\n   * @param {JXG.Curve} red\n   * @param {JXG.Curve} blue\n   * @param {Number|Function} nr\n   */\n  meetCurveRedBlueSegments: function (red, blue, nr) {\n    var i,\n      j,\n      n = Type.evaluate(nr),\n      red1,\n      red2,\n      blue1,\n      blue2,\n      m,\n      minX,\n      maxX,\n      iFound = 0,\n      lenBlue = blue.numberPoints,\n      //points.length,\n      lenRed = red.numberPoints; //points.length;\n\n    if (lenBlue <= 1 || lenRed <= 1) {\n      return [0, NaN, NaN];\n    }\n    for (i = 1; i < lenRed; i++) {\n      red1 = red.points[i - 1].usrCoords;\n      red2 = red.points[i].usrCoords;\n      minX = Math.min(red1[1], red2[1]);\n      maxX = Math.max(red1[1], red2[1]);\n      blue2 = blue.points[0].usrCoords;\n      for (j = 1; j < lenBlue; j++) {\n        blue1 = blue2;\n        blue2 = blue.points[j].usrCoords;\n        if (Math.min(blue1[1], blue2[1]) < maxX && Math.max(blue1[1], blue2[1]) > minX) {\n          m = this.meetSegmentSegment(red1, red2, blue1, blue2);\n          if (m[1] >= 0.0 && m[2] >= 0.0 && (\n          // The two segments meet in the interior or at the start points\n          m[1] < 1.0 && m[2] < 1.0 ||\n          // One of the curve is intersected in the very last point\n          i === lenRed - 1 && m[1] === 1.0 || j === lenBlue - 1 && m[2] === 1.0)) {\n            if (iFound === n) {\n              return m[0];\n            }\n            iFound++;\n          }\n        }\n      }\n    }\n    return [0, NaN, NaN];\n  },\n  /**\n   * (Virtual) Intersection of two segments.\n   * @param {Array} p1 First point of segment 1 using normalized homogeneous coordinates [1,x,y]\n   * @param {Array} p2 Second point or direction of segment 1 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively\n   * @param {Array} q1 First point of segment 2 using normalized homogeneous coordinates [1,x,y]\n   * @param {Array} q2 Second point or direction of segment 2 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively\n   * @returns {Array} [Intersection point, t, u] The first entry contains the homogeneous coordinates\n   * of the intersection point. The second and third entry give the position of the intersection with respect\n   * to the definiting parameters. For example, the second entry t is defined by: intersection point = p1 + t * deltaP, where\n   * deltaP = (p2 - p1) when both parameters are coordinates, and deltaP = p2 if p2 is a point at infinity.\n   * If the two segments are collinear, [[0,0,0], Infinity, Infinity] is returned.\n   **/\n  meetSegmentSegment: function (p1, p2, q1, q2) {\n    var t,\n      u,\n      i,\n      d,\n      li1 = Mat.crossProduct(p1, p2),\n      li2 = Mat.crossProduct(q1, q2),\n      c = Mat.crossProduct(li1, li2);\n    if (Math.abs(c[0]) < Mat.eps) {\n      return [c, Infinity, Infinity];\n    }\n\n    // Normalize the intersection coordinates\n    c[1] /= c[0];\n    c[2] /= c[0];\n    c[0] /= c[0];\n\n    // Now compute in principle:\n    //    t = dist(c - p1) / dist(p2 - p1) and\n    //    u = dist(c - q1) / dist(q2 - q1)\n    // However: the points q1, q2, p1, p2 might be ideal points - or in general - the\n    // coordinates might be not normalized.\n    // Note that the z-coordinates of p2 and q2 are used to determine whether it should be interpreted\n    // as a segment coordinate or a direction.\n    i = Math.abs(p2[1] - p2[0] * p1[1]) < Mat.eps ? 2 : 1;\n    d = p1[i] / p1[0];\n    t = (c[i] - d) / (p2[0] !== 0 ? p2[i] / p2[0] - d : p2[i]);\n    i = Math.abs(q2[1] - q2[0] * q1[1]) < Mat.eps ? 2 : 1;\n    d = q1[i] / q1[0];\n    u = (c[i] - d) / (q2[0] !== 0 ? q2[i] / q2[0] - d : q2[i]);\n    return [c, t, u];\n  },\n  /**\n   * Find the n-th intersection point of two pathes, usually given by polygons. Uses parts of the\n   * Greiner-Hormann algorithm in JXG.Math.Clip.\n   *\n   * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path1\n   * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path2\n   * @param {Number|Function} n\n   * @param {JXG.Board} board\n   *\n   * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n   * the ideal point [0,0,0] is returned.\n   *\n   */\n  meetPathPath: function (path1, path2, nr, board) {\n    var S,\n      C,\n      len,\n      intersections,\n      n = Type.evaluate(nr);\n    S = JXG.Math.Clip._getPath(path1, board);\n    len = S.length;\n    if (len > 0 && this.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < Mat.eps) {\n      S.pop();\n    }\n    C = JXG.Math.Clip._getPath(path2, board);\n    len = C.length;\n    if (len > 0 && this.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) < Mat.eps * Mat.eps) {\n      C.pop();\n    }\n\n    // Handle cases where at least one of the paths is empty\n    if (nr < 0 || JXG.Math.Clip.isEmptyCase(S, C, \"intersection\")) {\n      return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n    }\n    JXG.Math.Clip.makeDoublyLinkedList(S);\n    JXG.Math.Clip.makeDoublyLinkedList(C);\n    intersections = JXG.Math.Clip.findIntersections(S, C, board)[0];\n    if (n < intersections.length) {\n      return intersections[n].coords;\n    }\n    return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n  },\n  /**\n   * Find the n-th intersection point between a polygon and a line.\n   * @param {JXG.Polygon} path\n   * @param {JXG.Line} line\n   * @param {Number|Function} nr\n   * @param {JXG.Board} board\n   * @param {Boolean} alwaysIntersect If false just the segment between the two defining points of the line are tested for intersection.\n   *\n   * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n   * the ideal point [0,0,0] is returned.\n   */\n  meetPolygonLine: function (path, line, nr, board, alwaysIntersect) {\n    var i,\n      n = Type.evaluate(nr),\n      res,\n      border,\n      crds = [0, 0, 0],\n      len = path.borders.length,\n      intersections = [];\n    for (i = 0; i < len; i++) {\n      border = path.borders[i];\n      res = this.meetSegmentSegment(border.point1.coords.usrCoords, border.point2.coords.usrCoords, line.point1.coords.usrCoords, line.point2.coords.usrCoords);\n      if ((!alwaysIntersect || res[2] >= 0 && res[2] < 1) && res[1] >= 0 && res[1] < 1) {\n        intersections.push(res[0]);\n      }\n    }\n    if (n >= 0 && n < intersections.length) {\n      crds = intersections[n];\n    }\n    return new Coords(Const.COORDS_BY_USER, crds, board);\n  },\n  /****************************************/\n  /****   BEZIER CURVE ALGORITHMS      ****/\n  /****************************************/\n\n  /**\n   * Splits a Bezier curve segment defined by four points into\n   * two Bezier curve segments. Dissection point is t=1/2.\n   * @param {Array} curve Array of four coordinate arrays of length 2 defining a\n   * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n   * @returns {Array} Array consisting of two coordinate arrays for Bezier curves.\n   */\n  _bezierSplit: function (curve) {\n    var p0, p1, p2, p00, p22, p000;\n    p0 = [(curve[0][0] + curve[1][0]) * 0.5, (curve[0][1] + curve[1][1]) * 0.5];\n    p1 = [(curve[1][0] + curve[2][0]) * 0.5, (curve[1][1] + curve[2][1]) * 0.5];\n    p2 = [(curve[2][0] + curve[3][0]) * 0.5, (curve[2][1] + curve[3][1]) * 0.5];\n    p00 = [(p0[0] + p1[0]) * 0.5, (p0[1] + p1[1]) * 0.5];\n    p22 = [(p1[0] + p2[0]) * 0.5, (p1[1] + p2[1]) * 0.5];\n    p000 = [(p00[0] + p22[0]) * 0.5, (p00[1] + p22[1]) * 0.5];\n    return [[curve[0], p0, p00, p000], [p000, p22, p2, curve[3]]];\n  },\n  /**\n   * Computes the bounding box [minX, maxY, maxX, minY] of a Bezier curve segment\n   * from its control points.\n   * @param {Array} curve Array of four coordinate arrays of length 2 defining a\n   * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n   * @returns {Array} Bounding box [minX, maxY, maxX, minY]\n   */\n  _bezierBbox: function (curve) {\n    var bb = [];\n    if (curve.length === 4) {\n      // bezierDegree == 3\n      bb[0] = Math.min(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // minX\n      bb[1] = Math.max(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // maxY\n      bb[2] = Math.max(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // maxX\n      bb[3] = Math.min(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // minY\n    } else {\n      // bezierDegree == 1\n      bb[0] = Math.min(curve[0][0], curve[1][0]); // minX\n      bb[1] = Math.max(curve[0][1], curve[1][1]); // maxY\n      bb[2] = Math.max(curve[0][0], curve[1][0]); // maxX\n      bb[3] = Math.min(curve[0][1], curve[1][1]); // minY\n    }\n    return bb;\n  },\n  /**\n   * Decide if two Bezier curve segments overlap by comparing their bounding boxes.\n   * @param {Array} bb1 Bounding box of the first Bezier curve segment\n   * @param {Array} bb2 Bounding box of the second Bezier curve segment\n   * @returns {Boolean} true if the bounding boxes overlap, false otherwise.\n   */\n  _bezierOverlap: function (bb1, bb2) {\n    return bb1[2] >= bb2[0] && bb1[0] <= bb2[2] && bb1[1] >= bb2[3] && bb1[3] <= bb2[1];\n  },\n  /**\n   * Append list of intersection points to a list.\n   * @private\n   */\n  _bezierListConcat: function (L, Lnew, t1, t2) {\n    var i,\n      t2exists = Type.exists(t2),\n      start = 0,\n      len = Lnew.length,\n      le = L.length;\n    if (le > 0 && len > 0 && (L[le - 1][1] === 1 && Lnew[0][1] === 0 || t2exists && L[le - 1][2] === 1 && Lnew[0][2] === 0)) {\n      start = 1;\n    }\n    for (i = start; i < len; i++) {\n      if (t2exists) {\n        Lnew[i][2] *= 0.5;\n        Lnew[i][2] += t2;\n      }\n      Lnew[i][1] *= 0.5;\n      Lnew[i][1] += t1;\n      L.push(Lnew[i]);\n    }\n  },\n  /**\n   * Find intersections of two Bezier curve segments by recursive subdivision.\n   * Below maxlevel determine intersections by intersection line segments.\n   * @param {Array} red Array of four coordinate arrays of length 2 defining the first\n   * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n   * @param {Array} blue Array of four coordinate arrays of length 2 defining the second\n   * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n   * @param {Number} level Recursion level\n   * @returns {Array} List of intersection points (up to nine). Each intersection point is an\n   * array of length three (homogeneous coordinates) plus preimages.\n   */\n  _bezierMeetSubdivision: function (red, blue, level) {\n    var bbb,\n      bbr,\n      ar,\n      b0,\n      b1,\n      r0,\n      r1,\n      m,\n      p0,\n      p1,\n      q0,\n      q1,\n      L = [],\n      maxLev = 5; // Maximum recursion level\n\n    bbr = this._bezierBbox(blue);\n    bbb = this._bezierBbox(red);\n    if (!this._bezierOverlap(bbr, bbb)) {\n      return [];\n    }\n    if (level < maxLev) {\n      ar = this._bezierSplit(red);\n      r0 = ar[0];\n      r1 = ar[1];\n      ar = this._bezierSplit(blue);\n      b0 = ar[0];\n      b1 = ar[1];\n      this._bezierListConcat(L, this._bezierMeetSubdivision(r0, b0, level + 1), 0.0, 0.0);\n      this._bezierListConcat(L, this._bezierMeetSubdivision(r0, b1, level + 1), 0, 0.5);\n      this._bezierListConcat(L, this._bezierMeetSubdivision(r1, b0, level + 1), 0.5, 0.0);\n      this._bezierListConcat(L, this._bezierMeetSubdivision(r1, b1, level + 1), 0.5, 0.5);\n      return L;\n    }\n\n    // Make homogeneous coordinates\n    q0 = [1].concat(red[0]);\n    q1 = [1].concat(red[3]);\n    p0 = [1].concat(blue[0]);\n    p1 = [1].concat(blue[3]);\n    m = this.meetSegmentSegment(q0, q1, p0, p1);\n    if (m[1] >= 0.0 && m[2] >= 0.0 && m[1] <= 1.0 && m[2] <= 1.0) {\n      return [m];\n    }\n    return [];\n  },\n  /**\n   * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment\n   */\n  _bezierLineMeetSubdivision: function (red, blue, level, testSegment) {\n    var bbb,\n      bbr,\n      ar,\n      r0,\n      r1,\n      m,\n      p0,\n      p1,\n      q0,\n      q1,\n      L = [],\n      maxLev = 5; // Maximum recursion level\n\n    bbb = this._bezierBbox(blue);\n    bbr = this._bezierBbox(red);\n    if (testSegment && !this._bezierOverlap(bbr, bbb)) {\n      return [];\n    }\n    if (level < maxLev) {\n      ar = this._bezierSplit(red);\n      r0 = ar[0];\n      r1 = ar[1];\n      this._bezierListConcat(L, this._bezierLineMeetSubdivision(r0, blue, level + 1), 0.0);\n      this._bezierListConcat(L, this._bezierLineMeetSubdivision(r1, blue, level + 1), 0.5);\n      return L;\n    }\n\n    // Make homogeneous coordinates\n    q0 = [1].concat(red[0]);\n    q1 = [1].concat(red[3]);\n    p0 = [1].concat(blue[0]);\n    p1 = [1].concat(blue[1]);\n    m = this.meetSegmentSegment(q0, q1, p0, p1);\n    if (m[1] >= 0.0 && m[1] <= 1.0) {\n      if (!testSegment || m[2] >= 0.0 && m[2] <= 1.0) {\n        return [m];\n      }\n    }\n    return [];\n  },\n  /**\n   * Find the nr-th intersection point of two Bezier curve segments.\n   * @param {Array} red Array of four coordinate arrays of length 2 defining the first\n   * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n   * @param {Array} blue Array of four coordinate arrays of length 2 defining the second\n   * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n   * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment\n   * @returns {Array} Array containing the list of all intersection points as homogeneous coordinate arrays plus\n   * preimages [x,y], t_1, t_2] of the two Bezier curve segments.\n   *\n   */\n  meetBeziersegmentBeziersegment: function (red, blue, testSegment) {\n    var L, L2, i;\n    if (red.length === 4 && blue.length === 4) {\n      L = this._bezierMeetSubdivision(red, blue, 0);\n    } else {\n      L = this._bezierLineMeetSubdivision(red, blue, 0, testSegment);\n    }\n    L.sort(function (a, b) {\n      return (a[1] - b[1]) * 10000000.0 + (a[2] - b[2]);\n    });\n    L2 = [];\n    for (i = 0; i < L.length; i++) {\n      // Only push entries different from their predecessor\n      if (i === 0 || L[i][1] !== L[i - 1][1] || L[i][2] !== L[i - 1][2]) {\n        L2.push(L[i]);\n      }\n    }\n    return L2;\n  },\n  /**\n   * Find the nr-th intersection point of two Bezier curves, i.e. curves with bezierDegree == 3.\n   * @param {JXG.Curve} red Curve with bezierDegree == 3\n   * @param {JXG.Curve} blue Curve with bezierDegree == 3\n   * @param {Number|Function} nr The number of the intersection point which should be returned.\n   * @returns {Array} The homogeneous coordinates of the nr-th intersection point.\n   */\n  meetBezierCurveRedBlueSegments: function (red, blue, nr) {\n    var p,\n      i,\n      j,\n      k,\n      n = Type.evaluate(nr),\n      po,\n      tmp,\n      redArr,\n      blueArr,\n      bbr,\n      bbb,\n      intersections,\n      startRed = 0,\n      startBlue = 0,\n      lenBlue,\n      lenRed,\n      L = [];\n    if (blue.numberPoints < blue.bezierDegree + 1 || red.numberPoints < red.bezierDegree + 1) {\n      return [0, NaN, NaN];\n    }\n    if (red.bezierDegree === 1 && blue.bezierDegree === 3) {\n      tmp = red;\n      red = blue;\n      blue = tmp;\n    }\n    lenBlue = blue.numberPoints - blue.bezierDegree;\n    lenRed = red.numberPoints - red.bezierDegree;\n\n    // For sectors, we ignore the \"legs\"\n    if (red.type === Const.OBJECT_TYPE_SECTOR) {\n      startRed = 3;\n      lenRed -= 3;\n    }\n    if (blue.type === Const.OBJECT_TYPE_SECTOR) {\n      startBlue = 3;\n      lenBlue -= 3;\n    }\n    for (i = startRed; i < lenRed; i += red.bezierDegree) {\n      p = red.points;\n      redArr = [p[i].usrCoords.slice(1), p[i + 1].usrCoords.slice(1)];\n      if (red.bezierDegree === 3) {\n        redArr[2] = p[i + 2].usrCoords.slice(1);\n        redArr[3] = p[i + 3].usrCoords.slice(1);\n      }\n      bbr = this._bezierBbox(redArr);\n      for (j = startBlue; j < lenBlue; j += blue.bezierDegree) {\n        p = blue.points;\n        blueArr = [p[j].usrCoords.slice(1), p[j + 1].usrCoords.slice(1)];\n        if (blue.bezierDegree === 3) {\n          blueArr[2] = p[j + 2].usrCoords.slice(1);\n          blueArr[3] = p[j + 3].usrCoords.slice(1);\n        }\n        bbb = this._bezierBbox(blueArr);\n        if (this._bezierOverlap(bbr, bbb)) {\n          intersections = this.meetBeziersegmentBeziersegment(redArr, blueArr);\n          if (intersections.length === 0) {\n            continue;\n          }\n          for (k = 0; k < intersections.length; k++) {\n            po = intersections[k];\n            if (po[1] < -Mat.eps || po[1] > 1 + Mat.eps || po[2] < -Mat.eps || po[2] > 1 + Mat.eps) {\n              continue;\n            }\n            L.push(po);\n          }\n          if (L.length > n) {\n            return L[n][0];\n          }\n        }\n      }\n    }\n    if (L.length > n) {\n      return L[n][0];\n    }\n    return [0, NaN, NaN];\n  },\n  bezierSegmentEval: function (t, curve) {\n    var f,\n      x,\n      y,\n      t1 = 1.0 - t;\n    x = 0;\n    y = 0;\n    f = t1 * t1 * t1;\n    x += f * curve[0][0];\n    y += f * curve[0][1];\n    f = 3.0 * t * t1 * t1;\n    x += f * curve[1][0];\n    y += f * curve[1][1];\n    f = 3.0 * t * t * t1;\n    x += f * curve[2][0];\n    y += f * curve[2][1];\n    f = t * t * t;\n    x += f * curve[3][0];\n    y += f * curve[3][1];\n    return [1.0, x, y];\n  },\n  /**\n   * Generate the defining points of a 3rd degree bezier curve that approximates\n   * a circle sector defined by three coordinate points A, B, C, each defined by an array of length three.\n   * The coordinate arrays are given in homogeneous coordinates.\n   * @param {Array} A First point\n   * @param {Array} B Second point (intersection point)\n   * @param {Array} C Third point\n   * @param {Boolean} withLegs Flag. If true the legs to the intersection point are part of the curve.\n   * @param {Number} sgn Wither 1 or -1. Needed for minor and major arcs. In case of doubt, use 1.\n   */\n  bezierArc: function (A, B, C, withLegs, sgn) {\n    var p1,\n      p2,\n      p3,\n      p4,\n      r,\n      phi,\n      beta,\n      PI2 = Math.PI * 0.5,\n      x = B[1],\n      y = B[2],\n      z = B[0],\n      dataX = [],\n      dataY = [],\n      co,\n      si,\n      ax,\n      ay,\n      bx,\n      by,\n      k,\n      v,\n      d,\n      matrix;\n    r = this.distance(B, A);\n\n    // x,y, z is intersection point. Normalize it.\n    x /= z;\n    y /= z;\n    phi = this.rad(A.slice(1), B.slice(1), C.slice(1));\n    if (sgn === -1) {\n      phi = 2 * Math.PI - phi;\n    }\n    p1 = A;\n    p1[1] /= p1[0];\n    p1[2] /= p1[0];\n    p1[0] /= p1[0];\n    p4 = p1.slice(0);\n    if (withLegs) {\n      dataX = [x, x + 0.333 * (p1[1] - x), x + 0.666 * (p1[1] - x), p1[1]];\n      dataY = [y, y + 0.333 * (p1[2] - y), y + 0.666 * (p1[2] - y), p1[2]];\n    } else {\n      dataX = [p1[1]];\n      dataY = [p1[2]];\n    }\n    while (phi > Mat.eps) {\n      if (phi > PI2) {\n        beta = PI2;\n        phi -= PI2;\n      } else {\n        beta = phi;\n        phi = 0;\n      }\n      co = Math.cos(sgn * beta);\n      si = Math.sin(sgn * beta);\n      matrix = [[1, 0, 0], [x * (1 - co) + y * si, co, -si], [y * (1 - co) - x * si, si, co]];\n      v = Mat.matVecMult(matrix, p1);\n      p4 = [v[0] / v[0], v[1] / v[0], v[2] / v[0]];\n      ax = p1[1] - x;\n      ay = p1[2] - y;\n      bx = p4[1] - x;\n      by = p4[2] - y;\n      d = Mat.hypot(ax + bx, ay + by);\n      if (Math.abs(by - ay) > Mat.eps) {\n        k = (ax + bx) * (r / d - 0.5) / (by - ay) * 8 / 3;\n      } else {\n        k = (ay + by) * (r / d - 0.5) / (ax - bx) * 8 / 3;\n      }\n      p2 = [1, p1[1] - k * ay, p1[2] + k * ax];\n      p3 = [1, p4[1] + k * by, p4[2] - k * bx];\n      dataX = dataX.concat([p2[1], p3[1], p4[1]]);\n      dataY = dataY.concat([p2[2], p3[2], p4[2]]);\n      p1 = p4.slice(0);\n    }\n    if (withLegs) {\n      dataX = dataX.concat([p4[1] + 0.333 * (x - p4[1]), p4[1] + 0.666 * (x - p4[1]), x]);\n      dataY = dataY.concat([p4[2] + 0.333 * (y - p4[2]), p4[2] + 0.666 * (y - p4[2]), y]);\n    }\n    return [dataX, dataY];\n  },\n  /****************************************/\n  /****           PROJECTIONS          ****/\n  /****************************************/\n\n  /**\n   * Calculates the coordinates of the projection of a given point on a given circle. I.o.w. the\n   * nearest one of the two intersection points of the line through the given point and the circles\n   * center.\n   * @param {JXG.Point|JXG.Coords} point Point to project or coords object to project.\n   * @param {JXG.Circle} circle Circle on that the point is projected.\n   * @param {JXG.Board} [board=point.board] Reference to the board\n   * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.\n   */\n  projectPointToCircle: function (point, circle, board) {\n    var dist,\n      P,\n      x,\n      y,\n      factor,\n      M = circle.center.coords.usrCoords;\n    if (!Type.exists(board)) {\n      board = point.board;\n    }\n\n    // gave us a point\n    if (Type.isPoint(point)) {\n      dist = point.coords.distance(Const.COORDS_BY_USER, circle.center.coords);\n      P = point.coords.usrCoords;\n      // gave us coords\n    } else {\n      dist = point.distance(Const.COORDS_BY_USER, circle.center.coords);\n      P = point.usrCoords;\n    }\n    if (Math.abs(dist) < Mat.eps) {\n      dist = Mat.eps;\n    }\n    factor = circle.Radius() / dist;\n    x = M[1] + factor * (P[1] - M[1]);\n    y = M[2] + factor * (P[2] - M[2]);\n    return new Coords(Const.COORDS_BY_USER, [x, y], board);\n  },\n  /**\n   * Calculates the coordinates of the orthogonal projection of a given point on a given line. I.o.w. the\n   * intersection point of the given line and its perpendicular through the given point.\n   * @param {JXG.Point|JXG.Coords} point Point to project.\n   * @param {JXG.Line} line Line on that the point is projected.\n   * @param {JXG.Board} [board=point.board|board=line.board] Reference to a board.\n   * @returns {JXG.Coords} The coordinates of the projection of the given point on the given line.\n   */\n  projectPointToLine: function (point, line, board) {\n    var v = [0, line.stdform[1], line.stdform[2]],\n      coords;\n    if (!Type.exists(board)) {\n      if (Type.exists(point.coords)) {\n        board = point.board;\n      } else {\n        board = line.board;\n      }\n    }\n    if (Type.exists(point.coords)) {\n      coords = point.coords.usrCoords;\n    } else {\n      coords = point.usrCoords;\n    }\n    v = Mat.crossProduct(v, coords);\n    return new Coords(Const.COORDS_BY_USER, Mat.crossProduct(v, line.stdform), board);\n  },\n  /**\n   * Calculates the coordinates of the orthogonal projection of a given coordinate array on a given line\n   * segment defined by two coordinate arrays.\n   * @param {Array} p Point to project.\n   * @param {Array} q1 Start point of the line segment on that the point is projected.\n   * @param {Array} q2 End point of the line segment on that the point is projected.\n   * @returns {Array} The coordinates of the projection of the given point on the given segment\n   * and the factor that determines the projected point as a convex combination of the\n   * two endpoints q1 and q2 of the segment.\n   */\n  projectCoordsToSegment: function (p, q1, q2) {\n    var t,\n      denom,\n      s = [q2[1] - q1[1], q2[2] - q1[2]],\n      v = [p[1] - q1[1], p[2] - q1[2]];\n\n    /**\n     * If the segment has length 0, i.e. is a point,\n     * the projection is equal to that point.\n     */\n    if (Math.abs(s[0]) < Mat.eps && Math.abs(s[1]) < Mat.eps) {\n      return [q1, 0];\n    }\n    t = Mat.innerProduct(v, s);\n    denom = Mat.innerProduct(s, s);\n    t /= denom;\n    return [[1, t * s[0] + q1[1], t * s[1] + q1[2]], t];\n  },\n  /**\n   * Finds the coordinates of the closest point on a Bezier segment of a\n   * {@link JXG.Curve} to a given coordinate array.\n   * @param {Array} pos Point to project in homogeneous coordinates.\n   * @param {JXG.Curve} curve Curve of type \"plot\" having Bezier degree 3.\n   * @param {Number} start Number of the Bezier segment of the curve.\n   * @returns {Array} The coordinates of the projection of the given point\n   * on the given Bezier segment and the preimage of the curve which\n   * determines the closest point.\n   */\n  projectCoordsToBeziersegment: function (pos, curve, start) {\n    var t0,\n      /** @ignore */\n      minfunc = function (t) {\n        var z = [1, curve.X(start + t), curve.Y(start + t)];\n        z[1] -= pos[1];\n        z[2] -= pos[2];\n        return z[1] * z[1] + z[2] * z[2];\n      };\n    t0 = JXG.Math.Numerics.fminbr(minfunc, [0.0, 1.0]);\n    return [[1, curve.X(t0 + start), curve.Y(t0 + start)], t0];\n  },\n  /**\n   * Calculates the coordinates of the projection of a given point on a given curve.\n   * Uses {@link JXG.Math.Geometry.projectCoordsToCurve}.\n   *\n   * @param {JXG.Point} point Point to project.\n   * @param {JXG.Curve} curve Curve on that the point is projected.\n   * @param {JXG.Board} [board=point.board] Reference to a board.\n   * @see #projectCoordsToCurve\n   * @returns {Array} [JXG.Coords, position] The coordinates of the projection of the given\n   * point on the given graph and the relative position on the curve (real number).\n   */\n  projectPointToCurve: function (point, curve, board) {\n    if (!Type.exists(board)) {\n      board = point.board;\n    }\n    var x = point.X(),\n      y = point.Y(),\n      t = point.position || 0.0,\n      result = this.projectCoordsToCurve(x, y, t, curve, board);\n\n    // point.position = result[1];\n\n    return result;\n  },\n  /**\n   * Calculates the coordinates of the projection of a coordinates pair on a given curve. In case of\n   * function graphs this is the\n   * intersection point of the curve and the parallel to y-axis through the given point.\n   * @param {Number} x coordinate to project.\n   * @param {Number} y coordinate to project.\n   * @param {Number} t start value for newtons method\n   * @param {JXG.Curve} curve Curve on that the point is projected.\n   * @param {JXG.Board} [board=curve.board] Reference to a board.\n   * @see #projectPointToCurve\n   * @returns {JXG.Coords} Array containing the coordinates of the projection of the given point on the given curve and\n   * the position on the curve.\n   */\n  projectCoordsToCurve: function (x, y, t, curve, board) {\n    var newCoords,\n      newCoordsObj,\n      i,\n      j,\n      mindist,\n      dist,\n      lbda,\n      v,\n      coords,\n      d,\n      p1,\n      p2,\n      res,\n      minfunc,\n      t_new,\n      f_new,\n      f_old,\n      delta,\n      delta1,\n      delta2,\n      steps,\n      minX,\n      maxX,\n      infty = Number.POSITIVE_INFINITY;\n    if (!Type.exists(board)) {\n      board = curve.board;\n    }\n    if (Type.evaluate(curve.visProp.curvetype) === \"plot\") {\n      t = 0;\n      mindist = infty;\n      if (curve.numberPoints === 0) {\n        newCoords = [0, 1, 1];\n      } else {\n        newCoords = [curve.Z(0), curve.X(0), curve.Y(0)];\n      }\n      if (curve.numberPoints > 1) {\n        v = [1, x, y];\n        if (curve.bezierDegree === 3) {\n          j = 0;\n        } else {\n          p1 = [curve.Z(0), curve.X(0), curve.Y(0)];\n        }\n        for (i = 0; i < curve.numberPoints - 1; i++) {\n          if (curve.bezierDegree === 3) {\n            res = this.projectCoordsToBeziersegment(v, curve, j);\n          } else {\n            p2 = [curve.Z(i + 1), curve.X(i + 1), curve.Y(i + 1)];\n            res = this.projectCoordsToSegment(v, p1, p2);\n          }\n          lbda = res[1];\n          coords = res[0];\n          if (0.0 <= lbda && lbda <= 1.0) {\n            dist = this.distance(coords, v);\n            d = i + lbda;\n          } else if (lbda < 0.0) {\n            coords = p1;\n            dist = this.distance(p1, v);\n            d = i;\n          } else if (lbda > 1.0 && i === curve.numberPoints - 2) {\n            coords = p2;\n            dist = this.distance(coords, v);\n            d = curve.numberPoints - 1;\n          }\n          if (dist < mindist) {\n            mindist = dist;\n            t = d;\n            newCoords = coords;\n          }\n          if (curve.bezierDegree === 3) {\n            j++;\n            i += 2;\n          } else {\n            p1 = p2;\n          }\n        }\n      }\n      newCoordsObj = new Coords(Const.COORDS_BY_USER, newCoords, board);\n    } else {\n      // 'parameter', 'polar', 'functiongraph'\n      /** @ignore */\n      minfunc = function (t) {\n        var dx, dy;\n        if (t < curve.minX() || t > curve.maxX()) {\n          return Infinity;\n        }\n        dx = x - curve.X(t);\n        dy = y - curve.Y(t);\n        return dx * dx + dy * dy;\n      };\n      f_old = minfunc(t);\n      steps = 50;\n      minX = curve.minX();\n      maxX = curve.maxX();\n      delta = (maxX - minX) / steps;\n      t_new = minX;\n      for (i = 0; i < steps; i++) {\n        f_new = minfunc(t_new);\n        if (f_new < f_old || f_old === Infinity || isNaN(f_old)) {\n          t = t_new;\n          f_old = f_new;\n        }\n        t_new += delta;\n      }\n\n      // t = Numerics.root(Numerics.D(minfunc), t);\n      // Ensure that minfunc is defined on the\n      // enclsoing interval [t-delta1, t+delta2]\n      delta1 = delta;\n      for (i = 0; i < 20 && isNaN(minfunc(t - delta1)); i++, delta1 *= 0.5);\n      if (isNaN(minfunc(t - delta1))) {\n        delta1 = 0.0;\n      }\n      delta2 = delta;\n      for (i = 0; i < 20 && isNaN(minfunc(t + delta2)); i++, delta2 *= 0.5);\n      if (isNaN(minfunc(t + delta2))) {\n        delta2 = 0.0;\n      }\n      t = Numerics.fminbr(minfunc, [Math.max(t - delta1, minX), Math.min(t + delta2, maxX)]);\n\n      // Distinction between closed and open curves is not necessary.\n      // If closed, the cyclic projection shift will work anyhow\n      // if (Math.abs(curve.X(minX) - curve.X(maxX)) < Mat.eps &&\n      //     Math.abs(curve.Y(minX) - curve.Y(maxX)) < Mat.eps) {\n      //     // Cyclically\n      //     if (t < minX) {console.log(t)\n      //         t = maxX + t - minX;\n      //     }\n      //     if (t > maxX) {\n      //         t = minX + t - maxX;\n      //     }\n      // } else {\n      t = t < minX ? minX : t;\n      t = t > maxX ? maxX : t;\n      // }\n\n      newCoordsObj = new Coords(Const.COORDS_BY_USER, [curve.X(t), curve.Y(t)], board);\n    }\n    return [curve.updateTransform(newCoordsObj), t];\n  },\n  /**\n   * Calculates the coordinates of the closest orthogonal projection of a given coordinate array onto the\n   * border of a polygon.\n   * @param {Array} p Point to project.\n   * @param {JXG.Polygon} pol Polygon element\n   * @returns {Array} The coordinates of the closest projection of the given point to the border of the polygon.\n   */\n  projectCoordsToPolygon: function (p, pol) {\n    var i,\n      len = pol.vertices.length,\n      d_best = Infinity,\n      d,\n      projection,\n      proj,\n      bestprojection;\n    for (i = 0; i < len - 1; i++) {\n      projection = JXG.Math.Geometry.projectCoordsToSegment(p, pol.vertices[i].coords.usrCoords, pol.vertices[i + 1].coords.usrCoords);\n      if (0 <= projection[1] && projection[1] <= 1) {\n        d = JXG.Math.Geometry.distance(projection[0], p, 3);\n        proj = projection[0];\n      } else if (projection[1] < 0) {\n        d = JXG.Math.Geometry.distance(pol.vertices[i].coords.usrCoords, p, 3);\n        proj = pol.vertices[i].coords.usrCoords;\n      } else {\n        d = JXG.Math.Geometry.distance(pol.vertices[i + 1].coords.usrCoords, p, 3);\n        proj = pol.vertices[i + 1].coords.usrCoords;\n      }\n      if (d < d_best) {\n        bestprojection = proj.slice(0);\n        d_best = d;\n      }\n    }\n    return bestprojection;\n  },\n  /**\n   * Calculates the coordinates of the projection of a given point on a given turtle. A turtle consists of\n   * one or more curves of curveType 'plot'. Uses {@link JXG.Math.Geometry.projectPointToCurve}.\n   * @param {JXG.Point} point Point to project.\n   * @param {JXG.Turtle} turtle on that the point is projected.\n   * @param {JXG.Board} [board=point.board] Reference to a board.\n   * @returns {Array} [JXG.Coords, position] Array containing the coordinates of the projection of the given point on the turtle and\n   * the position on the turtle.\n   */\n  projectPointToTurtle: function (point, turtle, board) {\n    var newCoords,\n      t,\n      x,\n      y,\n      i,\n      dist,\n      el,\n      minEl,\n      res,\n      newPos,\n      np = 0,\n      npmin = 0,\n      mindist = Number.POSITIVE_INFINITY,\n      len = turtle.objects.length;\n    if (!Type.exists(board)) {\n      board = point.board;\n    }\n\n    // run through all curves of this turtle\n    for (i = 0; i < len; i++) {\n      el = turtle.objects[i];\n      if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n        res = this.projectPointToCurve(point, el);\n        newCoords = res[0];\n        newPos = res[1];\n        dist = this.distance(newCoords.usrCoords, point.coords.usrCoords);\n        if (dist < mindist) {\n          x = newCoords.usrCoords[1];\n          y = newCoords.usrCoords[2];\n          t = newPos;\n          mindist = dist;\n          minEl = el;\n          npmin = np;\n        }\n        np += el.numberPoints;\n      }\n    }\n    newCoords = new Coords(Const.COORDS_BY_USER, [x, y], board);\n    // point.position = t + npmin;\n    // return minEl.updateTransform(newCoords);\n    return [minEl.updateTransform(newCoords), t + npmin];\n  },\n  /**\n   * Trivial projection of a point to another point.\n   * @param {JXG.Point} point Point to project (not used).\n   * @param {JXG.Point} dest Point on that the point is projected.\n   * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.\n   */\n  projectPointToPoint: function (point, dest) {\n    return dest.coords;\n  },\n  /**\n   *\n   * @param {JXG.Point|JXG.Coords} point\n   * @param {JXG.Board} [board]\n   */\n  projectPointToBoard: function (point, board) {\n    var i,\n      l,\n      c,\n      brd = board || point.board,\n      // comparison factor, point coord idx, bbox idx, 1st bbox corner x & y idx, 2nd bbox corner x & y idx\n      config = [\n      // left\n      [1, 1, 0, 0, 3, 0, 1],\n      // top\n      [-1, 2, 1, 0, 1, 2, 1],\n      // right\n      [-1, 1, 2, 2, 1, 2, 3],\n      // bottom\n      [1, 2, 3, 0, 3, 2, 3]],\n      coords = point.coords || point,\n      bbox = brd.getBoundingBox();\n    for (i = 0; i < 4; i++) {\n      c = config[i];\n      if (c[0] * coords.usrCoords[c[1]] < c[0] * bbox[c[2]]) {\n        // define border\n        l = Mat.crossProduct([1, bbox[c[3]], bbox[c[4]]], [1, bbox[c[5]], bbox[c[6]]]);\n        l[3] = 0;\n        l = Mat.normalize(l);\n\n        // project point\n        coords = this.projectPointToLine({\n          coords: coords\n        }, {\n          stdform: l\n        }, brd);\n      }\n    }\n    return coords;\n  },\n  /**\n   * Calculates the distance of a point to a line. The point and the line are given by homogeneous\n   * coordinates. For lines this can be line.stdform.\n   * @param {Array} point Homogeneous coordinates of a point.\n   * @param {Array} line Homogeneous coordinates of a line ([C,A,B] where A*x+B*y+C*z=0).\n   * @returns {Number} Distance of the point to the line.\n   */\n  distPointLine: function (point, line) {\n    var a = line[1],\n      b = line[2],\n      c = line[0],\n      nom;\n    if (Math.abs(a) + Math.abs(b) < Mat.eps) {\n      return Number.POSITIVE_INFINITY;\n    }\n    nom = a * point[1] + b * point[2] + c;\n    a *= a;\n    b *= b;\n    return Math.abs(nom) / Math.sqrt(a + b);\n  },\n  /**\n   * Determine the (Euclidean) distance between a point q and a line segment\n   * defined by two points p1 and p2. In case p1 equals p2, the distance to this\n   * point is returned.\n   *\n   * @param {Array} q Homogeneous coordinates of q\n   * @param {Array} p1 Homogeneous coordinates of p1\n   * @param {Array} p2 Homogeneous coordinates of p2\n   * @returns {Number} Distance of q to line segment [p1, p2]\n   */\n  distPointSegment: function (q, p1, p2) {\n    var x,\n      y,\n      dx,\n      dy,\n      den,\n      lbda,\n      eps = Mat.eps * Mat.eps,\n      huge = 1000000;\n\n    // Difference q - p1\n    x = q[1] - p1[1];\n    y = q[2] - p1[2];\n    x = x === Infinity ? huge : x === -Infinity ? -huge : x;\n    y = y === Infinity ? huge : y === -Infinity ? -huge : y;\n\n    // Difference p2 - p1\n    dx = p2[1] - p1[1];\n    dy = p2[2] - p1[2];\n    dx = dx === Infinity ? huge : dx === -Infinity ? -huge : dx;\n    dy = dy === Infinity ? huge : dy === -Infinity ? -huge : dy;\n\n    // If den==0 then p1 and p2 are identical\n    // In this case the distance to p1 is returned\n    den = dx * dx + dy * dy;\n    if (den > eps) {\n      lbda = (x * dx + y * dy) / den;\n      if (lbda < 0.0) {\n        lbda = 0.0;\n      } else if (lbda > 1.0) {\n        lbda = 1.0;\n      }\n      x -= lbda * dx;\n      y -= lbda * dy;\n    }\n    return Mat.hypot(x, y);\n  },\n  /**\n   * Helper function to create curve which displays a Reuleaux polygons.\n   * @param {Array} points Array of points which should be the vertices of the Reuleaux polygon. Typically,\n   * these point list is the array vertices of a regular polygon.\n   * @param {Number} nr Number of vertices\n   * @returns {Array} An array containing the two functions defining the Reuleaux polygon and the two values\n   * for the start and the end of the paramtric curve. array may be used as parent array of a\n   * {@link JXG.Curve}.\n   *\n   * @example\n   * var A = brd.create('point',[-2,-2]);\n   * var B = brd.create('point',[0,1]);\n   * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});\n   * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),\n   *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});\n   *\n   * </pre><div class=\"jxgbox\" id=\"JXG2543a843-46a9-4372-abc1-94d9ad2db7ac\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   * var brd = JXG.JSXGraph.initBoard('JXG2543a843-46a9-4372-abc1-94d9ad2db7ac', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});\n   * var A = brd.create('point',[-2,-2]);\n   * var B = brd.create('point',[0,1]);\n   * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});\n   * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),\n   *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});\n   * </script><pre>\n   */\n  reuleauxPolygon: function (points, nr) {\n    var beta,\n      pi2 = Math.PI * 2,\n      pi2_n = pi2 / nr,\n      diag = (nr - 1) / 2,\n      d = 0,\n      makeFct = function (which, trig) {\n        return function (t, suspendUpdate) {\n          var t1 = (t % pi2 + pi2) % pi2,\n            j = Math.floor(t1 / pi2_n) % nr;\n          if (!suspendUpdate) {\n            d = points[0].Dist(points[diag]);\n            beta = Mat.Geometry.rad([points[0].X() + 1, points[0].Y()], points[0], points[diag % nr]);\n          }\n          if (isNaN(j)) {\n            return j;\n          }\n          t1 = t1 * 0.5 + j * pi2_n * 0.5 + beta;\n          return points[j][which]() + d * Math[trig](t1);\n        };\n      };\n    return [makeFct(\"X\", \"cos\"), makeFct(\"Y\", \"sin\"), 0, pi2];\n  },\n  meet3Planes: function (n1, d1, n2, d2, n3, d3) {\n    var p = [0, 0, 0],\n      n31,\n      n12,\n      n23,\n      denom,\n      i;\n    n31 = Mat.crossProduct(n3, n1);\n    n12 = Mat.crossProduct(n1, n2);\n    n23 = Mat.crossProduct(n2, n3);\n    denom = Mat.innerProduct(n1, n23, 3);\n    for (i = 0; i < 3; i++) {\n      p[i] = (d1 * n23[i] + d2 * n31[i] + d3 * n12[i]) / denom;\n    }\n    return p;\n  },\n  meetPlanePlane: function (v11, v12, v21, v22) {\n    var i,\n      no1,\n      no2,\n      v = [0, 0, 0],\n      w = [0, 0, 0];\n    for (i = 0; i < 3; i++) {\n      v[i] = Type.evaluate(v11[i]);\n      w[i] = Type.evaluate(v12[i]);\n    }\n    no1 = Mat.crossProduct(v, w);\n    for (i = 0; i < 3; i++) {\n      v[i] = Type.evaluate(v21[i]);\n      w[i] = Type.evaluate(v22[i]);\n    }\n    no2 = Mat.crossProduct(v, w);\n    return Mat.crossProduct(no1, no2);\n  },\n  project3DTo3DPlane: function (point, normal, foot) {\n    // TODO: homogeneous 3D coordinates\n    var sol = [0, 0, 0],\n      le,\n      d1,\n      d2,\n      lbda;\n    foot = foot || [0, 0, 0];\n    le = Mat.norm(normal);\n    d1 = Mat.innerProduct(point, normal, 3);\n    d2 = Mat.innerProduct(foot, normal, 3);\n    // (point - lbda * normal / le) * normal / le == foot * normal / le\n    // => (point * normal - foot * normal) ==  lbda * le\n    lbda = (d1 - d2) / le;\n    sol = Mat.axpy(-lbda, normal, point);\n    return sol;\n  },\n  getPlaneBounds: function (v1, v2, q, s, e) {\n    var s1, s2, e1, e2, mat, rhs, sol;\n    if (v1[2] + v2[0] !== 0) {\n      mat = [[v1[0], v2[0]], [v1[1], v2[1]]];\n      rhs = [s - q[0], s - q[1]];\n      sol = Numerics.Gauss(mat, rhs);\n      s1 = sol[0];\n      s2 = sol[1];\n      rhs = [e - q[0], e - q[1]];\n      sol = Numerics.Gauss(mat, rhs);\n      e1 = sol[0];\n      e2 = sol[1];\n      return [s1, e1, s2, e2];\n    }\n    return null;\n  }\n});\nexport default Mat.Geometry;","map":{"version":3,"names":["JXG","Const","Coords","Mat","Numerics","Type","Expect","Geometry","extend","angle","A","B","C","u","v","s","t","a","b","c","deprecated","coords","usrCoords","Math","atan2","trueAngle","rad","ax","ay","bx","by","cx","cy","phi","angleBisector","board","phiA","phiC","Ac","Bc","Cc","x","y","exists","COORDS_BY_USER","PI","cos","sin","reflection","line","point","x0","y0","x1","y1","w","mu","pc","p1c","point1","p2c","point2","rotation","rotpoint","rotpc","perpendicular","change","z","abs","eps","innerProduct","stdform","crossProduct","circumcenterMidpoint","circumcenter","apply","arguments","point3","m1","m2","distance","array1","array2","n","i","sum","min","length","sqrt","affineDistance","d","Infinity","affineRatio","r","dx","sortVertices","p","ll","ps","each","coordsArray","N","lastPoint","pop","sort","rad1","rad2","push","signedTriangle","p1","p2","p3","signedPolygon","undefined","unshift","GrahamScan","points","M","swap","slice","calcStraight","el","margin","takePoint1","takePoint2","intersection","intersect1","intersect2","straightFirst","straightLast","evaluate","visProp","straightfirst","straightlast","scrCoords","origin","unitX","unitY","isNaN","canvasWidth","canvasHeight","meetLineBoard","isSameDirection","isSameDir","setCoordinates","calcLineDelimitingPoints","distP1P2","boundingBox","lineSlope","getBoundingBox","getSlope","projectPointToLine","calcLabelQuadrant","q","floor","i1","i2","dpx","dpy","dix","diy","start","dy","sx","sy","det3p","windingNumber","path","doNotClosePath","wn","le","p0","sign","off","pnpoly","x_in","y_in","coord_type","j","len","crds","vi","vj","isIn","intersectionFunction","el1","el2","alwaysintersect","func","that","el1_isArcType","el2_isArcType","elementClass","OBJECT_CLASS_CURVE","type","OBJECT_TYPE_ARC","OBJECT_TYPE_SECTOR","OBJECT_CLASS_CIRCLE","meetCurveCurve","OBJECT_CLASS_LINE","meetCurveLine","OBJECT_TYPE_POLYGON","first1","last1","first2","last2","a_not","meetPolygonLine","meetPathPath","res","meetSegmentSegment","NaN","meet","has","first","last","coordsOnArc","arc","radiuspoint","center","alpha","beta","anglepoint","ev_s","selection","result","meetLineLine","meetLineCircle","meetCircleCircle","COORDS_BY_SCREEN","l1","l2","lin","circ","k","circ1","circ2","radicalAxis","normalize","c1","c2","nr","t2ini","method","co","generalizedNewton","bezierDegree","meetBezierCurveRedBlueSegments","meetCurveRedBlueSegments","alwaysIntersect","cu","li","meetCurveLineDiscrete","meetCurveLineContinuous","testSegment","func0","func1","epsLow","steps","delta","tnew","tmin","fmin","ft","maxX","minX","X","Y","root","max","lip1","lip2","cnt","numberPoints","ev_sf","ev_sl","meetBeziersegmentBeziersegment","red","blue","red1","red2","blue1","blue2","m","iFound","lenBlue","lenRed","q1","q2","li1","li2","path1","path2","S","intersections","Clip","_getPath","isEmptyCase","makeDoublyLinkedList","findIntersections","border","borders","_bezierSplit","curve","p00","p22","p000","_bezierBbox","bb","_bezierOverlap","bb1","bb2","_bezierListConcat","L","Lnew","t1","t2","t2exists","_bezierMeetSubdivision","level","bbb","bbr","ar","b0","b1","r0","r1","q0","maxLev","concat","_bezierLineMeetSubdivision","L2","po","tmp","redArr","blueArr","startRed","startBlue","bezierSegmentEval","f","bezierArc","withLegs","sgn","p4","PI2","dataX","dataY","si","matrix","matVecMult","hypot","projectPointToCircle","circle","dist","P","factor","isPoint","Radius","projectCoordsToSegment","denom","projectCoordsToBeziersegment","pos","t0","minfunc","fminbr","projectPointToCurve","position","projectCoordsToCurve","newCoords","newCoordsObj","mindist","lbda","t_new","f_new","f_old","delta1","delta2","infty","Number","POSITIVE_INFINITY","curvetype","Z","updateTransform","projectCoordsToPolygon","pol","vertices","d_best","projection","proj","bestprojection","projectPointToTurtle","turtle","minEl","newPos","np","npmin","objects","projectPointToPoint","dest","projectPointToBoard","l","brd","config","bbox","distPointLine","nom","distPointSegment","den","huge","reuleauxPolygon","pi2","pi2_n","diag","makeFct","which","trig","suspendUpdate","Dist","meet3Planes","n1","d1","n2","d2","n3","d3","n31","n12","n23","meetPlanePlane","v11","v12","v21","v22","no1","no2","project3DTo3DPlane","normal","foot","sol","norm","axpy","getPlaneBounds","v1","v2","e","s1","s2","e1","e2","mat","rhs","Gauss"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/math/geometry.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Andreas Walter,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains the Math.Geometry namespace for calculating algebraic/geometric\n * stuff like intersection points, angles, midpoint, and so on.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Numerics from \"./numerics\";\nimport Type from \"../utils/type\";\nimport Expect from \"../utils/expect\";\n\n/**\n * Math.Geometry namespace definition. This namespace holds geometrical algorithms,\n * especially intersection algorithms.\n * @name JXG.Math.Geometry\n * @namespace\n */\nMat.Geometry = {};\n\n// the splitting is necessary due to the shortcut for the circumcircleMidpoint method to circumcenter.\n\nJXG.extend(\n    Mat.Geometry,\n    /** @lends JXG.Math.Geometry */ {\n        /* ***************************************/\n        /* *** GENERAL GEOMETRIC CALCULATIONS ****/\n        /* ***************************************/\n\n        /**\n         * Calculates the angle defined by the points A, B, C.\n         * @param {JXG.Point|Array} A A point  or [x,y] array.\n         * @param {JXG.Point|Array} B Another point or [x,y] array.\n         * @param {JXG.Point|Array} C A circle - no, of course the third point or [x,y] array.\n         * @deprecated Use {@link JXG.Math.Geometry.rad} instead.\n         * @see #rad\n         * @see #trueAngle\n         * @returns {Number} The angle in radian measure.\n         */\n        angle: function (A, B, C) {\n            var u,\n                v,\n                s,\n                t,\n                a = [],\n                b = [],\n                c = [];\n\n            JXG.deprecated(\"Geometry.angle()\", \"Geometry.rad()\");\n            if (A.coords) {\n                a[0] = A.coords.usrCoords[1];\n                a[1] = A.coords.usrCoords[2];\n            } else {\n                a[0] = A[0];\n                a[1] = A[1];\n            }\n\n            if (B.coords) {\n                b[0] = B.coords.usrCoords[1];\n                b[1] = B.coords.usrCoords[2];\n            } else {\n                b[0] = B[0];\n                b[1] = B[1];\n            }\n\n            if (C.coords) {\n                c[0] = C.coords.usrCoords[1];\n                c[1] = C.coords.usrCoords[2];\n            } else {\n                c[0] = C[0];\n                c[1] = C[1];\n            }\n\n            u = a[0] - b[0];\n            v = a[1] - b[1];\n            s = c[0] - b[0];\n            t = c[1] - b[1];\n\n            return Math.atan2(u * t - v * s, u * s + v * t);\n        },\n\n        /**\n         * Calculates the angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.\n         * @param {JXG.Point|Array} A Point or [x,y] array\n         * @param {JXG.Point|Array} B Point or [x,y] array\n         * @param {JXG.Point|Array} C Point or [x,y] array\n         * @see #rad\n         * @returns {Number} The angle in degrees.\n         */\n        trueAngle: function (A, B, C) {\n            return this.rad(A, B, C) * 57.295779513082323; // *180.0/Math.PI;\n        },\n\n        /**\n         * Calculates the internal angle defined by the three points A, B, C if you're going from A to C around B counterclockwise.\n         * @param {JXG.Point|Array} A Point or [x,y] array\n         * @param {JXG.Point|Array} B Point or [x,y] array\n         * @param {JXG.Point|Array} C Point or [x,y] array\n         * @see #trueAngle\n         * @returns {Number} Angle in radians.\n         */\n        rad: function (A, B, C) {\n            var ax, ay, bx, by, cx, cy, phi;\n\n            if (A.coords) {\n                ax = A.coords.usrCoords[1];\n                ay = A.coords.usrCoords[2];\n            } else {\n                ax = A[0];\n                ay = A[1];\n            }\n\n            if (B.coords) {\n                bx = B.coords.usrCoords[1];\n                by = B.coords.usrCoords[2];\n            } else {\n                bx = B[0];\n                by = B[1];\n            }\n\n            if (C.coords) {\n                cx = C.coords.usrCoords[1];\n                cy = C.coords.usrCoords[2];\n            } else {\n                cx = C[0];\n                cy = C[1];\n            }\n\n            phi = Math.atan2(cy - by, cx - bx) - Math.atan2(ay - by, ax - bx);\n\n            if (phi < 0) {\n                phi += 6.2831853071795862;\n            }\n\n            return phi;\n        },\n\n        /**\n         * Calculates a point on the bisection line between the three points A, B, C.\n         * As a result, the bisection line is defined by two points:\n         * Parameter B and the point with the coordinates calculated in this function.\n         * Does not work for ideal points.\n         * @param {JXG.Point} A Point\n         * @param {JXG.Point} B Point\n         * @param {JXG.Point} C Point\n         * @param [board=A.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the second point defining the bisection.\n         */\n        angleBisector: function (A, B, C, board) {\n            var phiA,\n                phiC,\n                phi,\n                Ac = A.coords.usrCoords,\n                Bc = B.coords.usrCoords,\n                Cc = C.coords.usrCoords,\n                x,\n                y;\n\n            if (!Type.exists(board)) {\n                board = A.board;\n            }\n\n            // Parallel lines\n            if (Bc[0] === 0) {\n                return new Coords(\n                    Const.COORDS_BY_USER,\n                    [1, (Ac[1] + Cc[1]) * 0.5, (Ac[2] + Cc[2]) * 0.5],\n                    board\n                );\n            }\n\n            // Non-parallel lines\n            x = Ac[1] - Bc[1];\n            y = Ac[2] - Bc[2];\n            phiA = Math.atan2(y, x);\n\n            x = Cc[1] - Bc[1];\n            y = Cc[2] - Bc[2];\n            phiC = Math.atan2(y, x);\n\n            phi = (phiA + phiC) * 0.5;\n\n            if (phiA > phiC) {\n                phi += Math.PI;\n            }\n\n            x = Math.cos(phi) + Bc[1];\n            y = Math.sin(phi) + Bc[2];\n\n            return new Coords(Const.COORDS_BY_USER, [1, x, y], board);\n        },\n\n        // /**\n        //  * Calculates a point on the m-section line between the three points A, B, C.\n        //  * As a result, the m-section line is defined by two points:\n        //  * Parameter B and the point with the coordinates calculated in this function.\n        //  * The m-section generalizes the bisector to any real number.\n        //  * For example, the trisectors of an angle are simply the 1/3-sector and the 2/3-sector.\n        //  * Does not work for ideal points.\n        //  * @param {JXG.Point} A Point\n        //  * @param {JXG.Point} B Point\n        //  * @param {JXG.Point} C Point\n        //  * @param {Number} m Number\n        //  * @param [board=A.board] Reference to the board\n        //  * @returns {JXG.Coords} Coordinates of the second point defining the bisection.\n        //  */\n        // angleMsector: function (A, B, C, m, board) {\n        //     var phiA, phiC, phi,\n        //         Ac = A.coords.usrCoords,\n        //         Bc = B.coords.usrCoords,\n        //         Cc = C.coords.usrCoords,\n        //         x, y;\n\n        //     if (!Type.exists(board)) {\n        //         board = A.board;\n        //     }\n\n        //     // Parallel lines\n        //     if (Bc[0] === 0) {\n        //         return new Coords(Const.COORDS_BY_USER,\n        //             [1, (Ac[1] + Cc[1]) * m, (Ac[2] + Cc[2]) * m], board);\n        //     }\n\n        //     // Non-parallel lines\n        //     x = Ac[1] - Bc[1];\n        //     y = Ac[2] - Bc[2];\n        //     phiA =  Math.atan2(y, x);\n\n        //     x = Cc[1] - Bc[1];\n        //     y = Cc[2] - Bc[2];\n        //     phiC =  Math.atan2(y, x);\n\n        //     phi = phiA + ((phiC - phiA) * m);\n\n        //     if (phiA - phiC > Math.PI) {\n        //         phi += 2*m*Math.PI;\n        //     }\n\n        //     x = Math.cos(phi) + Bc[1];\n        //     y = Math.sin(phi) + Bc[2];\n\n        //     return new Coords(Const.COORDS_BY_USER, [1, x, y], board);\n        // },\n\n        /**\n         * Reflects the point along the line.\n         * @param {JXG.Line} line Axis of reflection.\n         * @param {JXG.Point} point Point to reflect.\n         * @param [board=point.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the reflected point.\n         */\n        reflection: function (line, point, board) {\n            // (v,w) defines the slope of the line\n            var x0,\n                y0,\n                x1,\n                y1,\n                v,\n                w,\n                mu,\n                pc = point.coords.usrCoords,\n                p1c = line.point1.coords.usrCoords,\n                p2c = line.point2.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            v = p2c[1] - p1c[1];\n            w = p2c[2] - p1c[2];\n\n            x0 = pc[1] - p1c[1];\n            y0 = pc[2] - p1c[2];\n\n            mu = (v * y0 - w * x0) / (v * v + w * w);\n\n            // point + mu*(-y,x) is the perpendicular foot\n            x1 = pc[1] + 2 * mu * w;\n            y1 = pc[2] - 2 * mu * v;\n\n            return new Coords(Const.COORDS_BY_USER, [x1, y1], board);\n        },\n\n        /**\n         * Computes the new position of a point which is rotated\n         * around a second point (called rotpoint) by the angle phi.\n         * @param {JXG.Point} rotpoint Center of the rotation\n         * @param {JXG.Point} point point to be rotated\n         * @param {Number} phi rotation angle in arc length\n         * @param {JXG.Board} [board=point.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the new position.\n         */\n        rotation: function (rotpoint, point, phi, board) {\n            var x0,\n                y0,\n                c,\n                s,\n                x1,\n                y1,\n                pc = point.coords.usrCoords,\n                rotpc = rotpoint.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            x0 = pc[1] - rotpc[1];\n            y0 = pc[2] - rotpc[2];\n\n            c = Math.cos(phi);\n            s = Math.sin(phi);\n\n            x1 = x0 * c - y0 * s + rotpc[1];\n            y1 = x0 * s + y0 * c + rotpc[2];\n\n            return new Coords(Const.COORDS_BY_USER, [x1, y1], board);\n        },\n\n        /**\n         * Calculates the coordinates of a point on the perpendicular to the given line through\n         * the given point.\n         * @param {JXG.Line} line A line.\n         * @param {JXG.Point} point Point which is projected to the line.\n         * @param {JXG.Board} [board=point.board] Reference to the board\n         * @returns {Array} Array of length two containing coordinates of a point on the perpendicular to the given line\n         *                  through the given point and boolean flag \"change\".\n         */\n        perpendicular: function (line, point, board) {\n            var x,\n                y,\n                change,\n                c,\n                z,\n                A = line.point1.coords.usrCoords,\n                B = line.point2.coords.usrCoords,\n                C = point.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            // special case: point is the first point of the line\n            if (point === line.point1) {\n                x = A[1] + B[2] - A[2];\n                y = A[2] - B[1] + A[1];\n                z = A[0] * B[0];\n\n                if (Math.abs(z) < Mat.eps) {\n                    x = B[2];\n                    y = -B[1];\n                }\n                c = [z, x, y];\n                change = true;\n\n                // special case: point is the second point of the line\n            } else if (point === line.point2) {\n                x = B[1] + A[2] - B[2];\n                y = B[2] - A[1] + B[1];\n                z = A[0] * B[0];\n\n                if (Math.abs(z) < Mat.eps) {\n                    x = A[2];\n                    y = -A[1];\n                }\n                c = [z, x, y];\n                change = false;\n\n                // special case: point lies somewhere else on the line\n            } else if (Math.abs(Mat.innerProduct(C, line.stdform, 3)) < Mat.eps) {\n                x = C[1] + B[2] - C[2];\n                y = C[2] - B[1] + C[1];\n                z = B[0];\n\n                if (Math.abs(z) < Mat.eps) {\n                    x = B[2];\n                    y = -B[1];\n                }\n\n                change = true;\n                if (\n                    Math.abs(z) > Mat.eps &&\n                    Math.abs(x - C[1]) < Mat.eps &&\n                    Math.abs(y - C[2]) < Mat.eps\n                ) {\n                    x = C[1] + A[2] - C[2];\n                    y = C[2] - A[1] + C[1];\n                    change = false;\n                }\n                c = [z, x, y];\n\n                // general case: point does not lie on the line\n                // -> calculate the foot of the dropped perpendicular\n            } else {\n                c = [0, line.stdform[1], line.stdform[2]];\n                c = Mat.crossProduct(c, C); // perpendicuar to line\n                c = Mat.crossProduct(c, line.stdform); // intersection of line and perpendicular\n                change = true;\n            }\n\n            return [new Coords(Const.COORDS_BY_USER, c, board), change];\n        },\n\n        /**\n         * @deprecated Please use {@link JXG.Math.Geometry.circumcenter} instead.\n         */\n        circumcenterMidpoint: function () {\n            JXG.deprecated(\"Geometry.circumcenterMidpoint()\", \"Geometry.circumcenter()\");\n            this.circumcenter.apply(this, arguments);\n        },\n\n        /**\n         * Calculates the center of the circumcircle of the three given points.\n         * @param {JXG.Point} point1 Point\n         * @param {JXG.Point} point2 Point\n         * @param {JXG.Point} point3 Point\n         * @param {JXG.Board} [board=point1.board] Reference to the board\n         * @returns {JXG.Coords} Coordinates of the center of the circumcircle of the given points.\n         */\n        circumcenter: function (point1, point2, point3, board) {\n            var u,\n                v,\n                m1,\n                m2,\n                A = point1.coords.usrCoords,\n                B = point2.coords.usrCoords,\n                C = point3.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point1.board;\n            }\n\n            u = [B[0] - A[0], -B[2] + A[2], B[1] - A[1]];\n            v = [(A[0] + B[0]) * 0.5, (A[1] + B[1]) * 0.5, (A[2] + B[2]) * 0.5];\n            m1 = Mat.crossProduct(u, v);\n\n            u = [C[0] - B[0], -C[2] + B[2], C[1] - B[1]];\n            v = [(B[0] + C[0]) * 0.5, (B[1] + C[1]) * 0.5, (B[2] + C[2]) * 0.5];\n            m2 = Mat.crossProduct(u, v);\n\n            return new Coords(Const.COORDS_BY_USER, Mat.crossProduct(m1, m2), board);\n        },\n\n        /**\n         * Calculates the Euclidean distance for two given arrays of the same length.\n         * @param {Array} array1 Array of Number\n         * @param {Array} array2 Array of Number\n         * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.\n         * @returns {Number} Euclidean distance of the given vectors.\n         */\n        distance: function (array1, array2, n) {\n            var i,\n                sum = 0;\n\n            if (!n) {\n                n = Math.min(array1.length, array2.length);\n            }\n\n            for (i = 0; i < n; i++) {\n                sum += (array1[i] - array2[i]) * (array1[i] - array2[i]);\n            }\n\n            return Math.sqrt(sum);\n        },\n\n        /**\n         * Calculates Euclidean distance for two given arrays of the same length.\n         * If one of the arrays contains a zero in the first coordinate, and the Euclidean distance\n         * is different from zero it is a point at infinity and we return Infinity.\n         * @param {Array} array1 Array containing elements of type number.\n         * @param {Array} array2 Array containing elements of type number.\n         * @param {Number} [n] Length of the arrays. Default is the minimum length of the given arrays.\n         * @returns {Number} Euclidean (affine) distance of the given vectors.\n         */\n        affineDistance: function (array1, array2, n) {\n            var d;\n\n            d = this.distance(array1, array2, n);\n\n            if (\n                d > Mat.eps &&\n                (Math.abs(array1[0]) < Mat.eps || Math.abs(array2[0]) < Mat.eps)\n            ) {\n                return Infinity;\n            }\n\n            return d;\n        },\n\n        /**\n         * Affine ratio of three collinear points a, b, c: (c - a) / (b - a).\n         * If r > 1 or r < 0 then c is outside of the segment ab.\n         *\n         * @param {Array|JXG.Coords} a\n         * @param {Array|JXG.Coords} b\n         * @param {Array|JXG.Coords} c\n         * @returns {Number} affine ratio (c - a) / (b - a)\n         */\n        affineRatio: function (a, b, c) {\n            var r = 0.0,\n                dx;\n\n            if (Type.exists(a.usrCoords)) {\n                a = a.usrCoords;\n            }\n            if (Type.exists(b.usrCoords)) {\n                b = b.usrCoords;\n            }\n            if (Type.exists(c.usrCoords)) {\n                c = c.usrCoords;\n            }\n\n            dx = b[1] - a[1];\n\n            if (Math.abs(dx) > Mat.eps) {\n                r = (c[1] - a[1]) / dx;\n            } else {\n                r = (c[2] - a[2]) / (b[2] - a[2]);\n            }\n            return r;\n        },\n\n        /**\n         * Sort vertices counter clockwise starting with the first point.\n         *\n         * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n         *\n         * @returns {Array}\n         */\n        sortVertices: function (p) {\n            var ll,\n                ps = Expect.each(p, Expect.coordsArray),\n                N = ps.length,\n                lastPoint = null;\n\n            // If the last point equals the first point, we take the last point out of the array.\n            // It may be that the several points at the end of the array are equal to the first point.\n            // The polygonal chain is been closed by JSXGraph, but this may also have been done by the user.\n            // Therefore, we use a while lopp to pop the last points.\n            while (\n                ps[0][0] === ps[N - 1][0] &&\n                ps[0][1] === ps[N - 1][1] &&\n                ps[0][2] === ps[N - 1][2]\n            ) {\n                lastPoint = ps.pop();\n                N--;\n            }\n            // Find the point with the lowest y value\n            // for (i = 1; i < N; i++) {\n            //     if ((ps[i][2] < ps[0][2]) ||\n            //         // if the current and the lowest point have the same y value, pick the one with\n            //         // the lowest x value.\n            //         (Math.abs(ps[i][2] - ps[0][2]) < Mat.eps && ps[i][1] < ps[0][1])) {\n            //         console.log(i, 0);\n            //         ps = Type.swap(ps, i, 0);\n            //     }\n            // }\n\n            ll = ps[0];\n            // Sort ps in increasing order of the angle between a point and the first point ll.\n            // If a point is equal to the first point ll, the angle is defined to be -Infinity.\n            // Otherwise, atan2 would return zero, which is a value which also attained by points\n            // on the same horizontal line.\n            ps.sort(function (a, b) {\n                var rad1 =\n                    a[2] === ll[2] && a[1] === ll[1]\n                        ? -Infinity\n                        : Math.atan2(a[2] - ll[2], a[1] - ll[1]),\n                    rad2 =\n                        b[2] === ll[2] && b[1] === ll[1]\n                            ? -Infinity\n                            : Math.atan2(b[2] - ll[2], b[1] - ll[1]);\n\n                return rad1 - rad2;\n            });\n\n            // If the last point has been taken out of the array, we put it in again.\n            if (lastPoint !== null) {\n                ps.push(lastPoint);\n            }\n\n            return ps;\n        },\n\n        /**\n         * Signed triangle area of the three points given.\n         *\n         * @param {JXG.Point|JXG.Coords|Array} p1\n         * @param {JXG.Point|JXG.Coords|Array} p2\n         * @param {JXG.Point|JXG.Coords|Array} p3\n         *\n         * @returns {Number}\n         */\n        signedTriangle: function (p1, p2, p3) {\n            var A = Expect.coordsArray(p1),\n                B = Expect.coordsArray(p2),\n                C = Expect.coordsArray(p3);\n\n            return 0.5 * ((B[1] - A[1]) * (C[2] - A[2]) - (B[2] - A[2]) * (C[1] - A[1]));\n        },\n\n        /**\n         * Determine the signed area of a non-selfintersecting polygon.\n         * Surveyor's Formula\n         *\n         * @param {Array} p An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n         * @param {Boolean} [sort=true]\n         *\n         * @returns {Number}\n         */\n        signedPolygon: function (p, sort) {\n            var i,\n                N,\n                A = 0,\n                ps = Expect.each(p, Expect.coordsArray);\n\n            if (sort === undefined) {\n                sort = true;\n            }\n\n            if (!sort) {\n                ps = this.sortVertices(ps);\n            } else {\n                // Make sure the polygon is closed. If it is already closed this won't change the sum because the last\n                // summand will be 0.\n                ps.unshift(ps[ps.length - 1]);\n            }\n\n            N = ps.length;\n\n            for (i = 1; i < N; i++) {\n                A += ps[i - 1][1] * ps[i][2] - ps[i][1] * ps[i - 1][2];\n            }\n\n            return 0.5 * A;\n        },\n\n        /**\n         * Calculate the complex hull of a point cloud.\n         *\n         * @param {Array} points An array containing {@link JXG.Point}, {@link JXG.Coords}, and/or arrays.\n         *\n         * @returns {Array}\n         */\n        GrahamScan: function (points) {\n            var i,\n                M = 1,\n                ps = Expect.each(points, Expect.coordsArray),\n                N = ps.length;\n\n            ps = this.sortVertices(ps);\n            N = ps.length;\n\n            for (i = 2; i < N; i++) {\n                while (this.signedTriangle(ps[M - 1], ps[M], ps[i]) <= 0) {\n                    if (M > 1) {\n                        M -= 1;\n                    } else if (i === N - 1) {\n                        break;\n                    }\n                    i += 1;\n                }\n\n                M += 1;\n                ps = Type.swap(ps, M, i);\n            }\n\n            return ps.slice(0, M);\n        },\n\n        /**\n         * A line can be a segment, a straight, or a ray. So it is not always delimited by point1 and point2\n         * calcStraight determines the visual start point and end point of the line. A segment is only drawn\n         * from start to end point, a straight line is drawn until it meets the boards boundaries.\n         * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.\n         * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and\n         * set by this method.\n         * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set\n         * by this method.\n         * @param {Number} margin Optional margin, to avoid the display of the small sides of lines.\n         * @returns null\n         * @see Line\n         * @see JXG.Line\n         */\n        calcStraight: function (el, point1, point2, margin) {\n            var takePoint1,\n                takePoint2,\n                intersection,\n                intersect1,\n                intersect2,\n                straightFirst,\n                straightLast,\n                c, p1, p2;\n\n            if (!Type.exists(margin)) {\n                // Enlarge the drawable region slightly. This hides the small sides\n                // of thick lines in most cases.\n                margin = 10;\n            }\n\n            straightFirst = Type.evaluate(el.visProp.straightfirst);\n            straightLast = Type.evaluate(el.visProp.straightlast);\n\n            // If one of the point is an ideal point in homogeneous coordinates\n            // drawing of line segments or rays are not possible.\n            if (Math.abs(point1.scrCoords[0]) < Mat.eps) {\n                straightFirst = true;\n            }\n            if (Math.abs(point2.scrCoords[0]) < Mat.eps) {\n                straightLast = true;\n            }\n\n            // Do nothing in case of line segments (inside or outside of the board)\n            if (!straightFirst && !straightLast) {\n                return;\n            }\n\n            // Compute the stdform of the line in screen coordinates.\n            c = [];\n            c[0] =\n                el.stdform[0] -\n                (el.stdform[1] * el.board.origin.scrCoords[1]) / el.board.unitX +\n                (el.stdform[2] * el.board.origin.scrCoords[2]) / el.board.unitY;\n            c[1] = el.stdform[1] / el.board.unitX;\n            c[2] = -el.stdform[2] / el.board.unitY;\n\n            // If p1=p2\n            if (isNaN(c[0] + c[1] + c[2])) {\n                return;\n            }\n\n            takePoint1 = false;\n            takePoint2 = false;\n\n            // Line starts at point1 and point1 is inside the board\n            takePoint1 =\n                !straightFirst &&\n                Math.abs(point1.usrCoords[0]) >= Mat.eps &&\n                point1.scrCoords[1] >= 0.0 &&\n                point1.scrCoords[1] <= el.board.canvasWidth &&\n                point1.scrCoords[2] >= 0.0 &&\n                point1.scrCoords[2] <= el.board.canvasHeight;\n\n            // Line ends at point2 and point2 is inside the board\n            takePoint2 =\n                !straightLast &&\n                Math.abs(point2.usrCoords[0]) >= Mat.eps &&\n                point2.scrCoords[1] >= 0.0 &&\n                point2.scrCoords[1] <= el.board.canvasWidth &&\n                point2.scrCoords[2] >= 0.0 &&\n                point2.scrCoords[2] <= el.board.canvasHeight;\n\n            // Intersect the line with the four borders of the board.\n            intersection = this.meetLineBoard(c, el.board, margin);\n            intersect1 = intersection[0];\n            intersect2 = intersection[1];\n\n            /**\n             * At this point we have four points:\n             * point1 and point2 are the first and the second defining point on the line,\n             * intersect1, intersect2 are the intersections of the line with border around the board.\n             */\n\n            /*\n             * Here we handle rays where both defining points are outside of the board.\n             */\n            // If both points are outside and the complete ray is outside we do nothing\n            if (!takePoint1 && !takePoint2) {\n                // Ray starting at point 1\n                if (\n                    !straightFirst &&\n                    straightLast &&\n                    !this.isSameDirection(point1, point2, intersect1) &&\n                    !this.isSameDirection(point1, point2, intersect2)\n                ) {\n                    return;\n                }\n\n                // Ray starting at point 2\n                if (\n                    straightFirst &&\n                    !straightLast &&\n                    !this.isSameDirection(point2, point1, intersect1) &&\n                    !this.isSameDirection(point2, point1, intersect2)\n                ) {\n                    return;\n                }\n            }\n\n            /*\n             * If at least one of the defining points is outside of the board\n             * we take intersect1 or intersect2 as one of the end points\n             * The order is also important for arrows of axes\n             */\n            if (!takePoint1) {\n                if (!takePoint2) {\n                    // Two border intersection points are used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                        p1 = intersect2;\n                    }\n                } else {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                    } else {\n                        p1 = intersect2;\n                    }\n                }\n            } else {\n                if (!takePoint2) {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                    }\n                }\n            }\n\n            if (p1) {\n                //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));\n                point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords);\n            }\n\n            if (p2) {\n                //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));\n                point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords);\n            }\n        },\n\n        /**\n         * A line can be a segment, a straight, or a ray. so it is not always delimited by point1 and point2.\n         *\n         * This method adjusts the line's delimiting points taking into account its nature, the viewport defined\n         * by the board.\n         *\n         * A segment is delimited by start and end point, a straight line or ray is delimited until it meets the\n         * boards boundaries. However, if the line has infinite ticks, it will be delimited by the projection of\n         * the boards vertices onto itself.\n         *\n         * @param {JXG.Line} el Reference to a line object, that needs calculation of start and end point.\n         * @param {JXG.Coords} point1 Coordinates of the point where line drawing begins. This value is calculated and\n         * set by this method.\n         * @param {JXG.Coords} point2 Coordinates of the point where line drawing ends. This value is calculated and set\n         * by this method.\n         * @see Line\n         * @see JXG.Line\n         */\n        calcLineDelimitingPoints: function (el, point1, point2) {\n            var distP1P2,\n                boundingBox,\n                lineSlope,\n                intersect1,\n                intersect2,\n                straightFirst,\n                straightLast,\n                c,\n                p1,\n                p2,\n                takePoint1 = false,\n                takePoint2 = false;\n\n            straightFirst = Type.evaluate(el.visProp.straightfirst);\n            straightLast = Type.evaluate(el.visProp.straightlast);\n\n            // If one of the point is an ideal point in homogeneous coordinates\n            // drawing of line segments or rays are not possible.\n            if (Math.abs(point1.scrCoords[0]) < Mat.eps) {\n                straightFirst = true;\n            }\n            if (Math.abs(point2.scrCoords[0]) < Mat.eps) {\n                straightLast = true;\n            }\n\n            // Compute the stdform of the line in screen coordinates.\n            c = [];\n            c[0] =\n                el.stdform[0] -\n                (el.stdform[1] * el.board.origin.scrCoords[1]) / el.board.unitX +\n                (el.stdform[2] * el.board.origin.scrCoords[2]) / el.board.unitY;\n            c[1] = el.stdform[1] / el.board.unitX;\n            c[2] = -el.stdform[2] / el.board.unitY;\n\n            // p1=p2\n            if (isNaN(c[0] + c[1] + c[2])) {\n                return;\n            }\n\n            takePoint1 = !straightFirst;\n            takePoint2 = !straightLast;\n            // Intersect the board vertices on the line to establish the available visual space for the infinite ticks\n            // Based on the slope of the line we can optimise and only project the two outer vertices\n\n            // boundingBox = [x1, y1, x2, y2] upper left, lower right vertices\n            boundingBox = el.board.getBoundingBox();\n            lineSlope = el.getSlope();\n            if (lineSlope >= 0) {\n                // project vertices (x2,y1) (x1, y2)\n                intersect1 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[2], boundingBox[1]] } },\n                    el,\n                    el.board\n                );\n                intersect2 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[0], boundingBox[3]] } },\n                    el,\n                    el.board\n                );\n            } else {\n                // project vertices (x1, y1) (x2, y2)\n                intersect1 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[0], boundingBox[1]] } },\n                    el,\n                    el.board\n                );\n                intersect2 = this.projectPointToLine(\n                    { coords: { usrCoords: [1, boundingBox[2], boundingBox[3]] } },\n                    el,\n                    el.board\n                );\n            }\n\n            /**\n             * we have four points:\n             * point1 and point2 are the first and the second defining point on the line,\n             * intersect1, intersect2 are the intersections of the line with border around the board.\n             */\n\n            /*\n             * Here we handle rays/segments where both defining points are outside of the board.\n             */\n            if (!takePoint1 && !takePoint2) {\n                // Segment, if segment does not cross the board, do nothing\n                if (!straightFirst && !straightLast) {\n                    distP1P2 = point1.distance(Const.COORDS_BY_USER, point2);\n                    // if  intersect1 not between point1 and point2\n                    if (\n                        Math.abs(\n                            point1.distance(Const.COORDS_BY_USER, intersect1) +\n                            intersect1.distance(Const.COORDS_BY_USER, point2) -\n                            distP1P2\n                        ) > Mat.eps\n                    ) {\n                        return;\n                    }\n                    // if insersect2 not between point1 and point2\n                    if (\n                        Math.abs(\n                            point1.distance(Const.COORDS_BY_USER, intersect2) +\n                            intersect2.distance(Const.COORDS_BY_USER, point2) -\n                            distP1P2\n                        ) > Mat.eps\n                    ) {\n                        return;\n                    }\n                }\n\n                // If both points are outside and the complete ray is outside we do nothing\n                // Ray starting at point 1\n                if (\n                    !straightFirst &&\n                    straightLast &&\n                    !this.isSameDirection(point1, point2, intersect1) &&\n                    !this.isSameDirection(point1, point2, intersect2)\n                ) {\n                    return;\n                }\n\n                // Ray starting at point 2\n                if (\n                    straightFirst &&\n                    !straightLast &&\n                    !this.isSameDirection(point2, point1, intersect1) &&\n                    !this.isSameDirection(point2, point1, intersect2)\n                ) {\n                    return;\n                }\n            }\n\n            /*\n             * If at least one of the defining points is outside of the board\n             * we take intersect1 or intersect2 as one of the end points\n             * The order is also important for arrows of axes\n             */\n            if (!takePoint1) {\n                if (!takePoint2) {\n                    // Two border intersection points are used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                        p1 = intersect2;\n                    }\n                } else {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p1 = intersect1;\n                    } else {\n                        p1 = intersect2;\n                    }\n                }\n            } else {\n                if (!takePoint2) {\n                    // One border intersection points is used\n                    if (this.isSameDir(point1, point2, intersect1, intersect2)) {\n                        p2 = intersect2;\n                    } else {\n                        p2 = intersect1;\n                    }\n                }\n            }\n\n            if (p1) {\n                //point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords.slice(1));\n                point1.setCoordinates(Const.COORDS_BY_USER, p1.usrCoords);\n            }\n\n            if (p2) {\n                //point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords.slice(1));\n                point2.setCoordinates(Const.COORDS_BY_USER, p2.usrCoords);\n            }\n        },\n\n        /**\n         * Calculates the visProp.position corresponding to a given angle.\n         * @param {number} angle angle in radians. Must be in range (-2pi,2pi).\n         */\n        calcLabelQuadrant: function (angle) {\n            var q;\n            if (angle < 0) {\n                angle += 2 * Math.PI;\n            }\n            q = Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;\n            return [\"rt\", \"urt\", \"top\", \"ulft\", \"lft\", \"llft\", \"lrt\"][q];\n        },\n\n        /**\n         * The vectors <tt>p2-p1</tt> and <tt>i2-i1</tt> are supposed to be collinear. If their cosine is positive\n         * they point into the same direction otherwise they point in opposite direction.\n         * @param {JXG.Coords} p1\n         * @param {JXG.Coords} p2\n         * @param {JXG.Coords} i1\n         * @param {JXG.Coords} i2\n         * @returns {Boolean} True, if <tt>p2-p1</tt> and <tt>i2-i1</tt> point into the same direction\n         */\n        isSameDir: function (p1, p2, i1, i2) {\n            var dpx = p2.usrCoords[1] - p1.usrCoords[1],\n                dpy = p2.usrCoords[2] - p1.usrCoords[2],\n                dix = i2.usrCoords[1] - i1.usrCoords[1],\n                diy = i2.usrCoords[2] - i1.usrCoords[2];\n\n            if (Math.abs(p2.usrCoords[0]) < Mat.eps) {\n                dpx = p2.usrCoords[1];\n                dpy = p2.usrCoords[2];\n            }\n\n            if (Math.abs(p1.usrCoords[0]) < Mat.eps) {\n                dpx = -p1.usrCoords[1];\n                dpy = -p1.usrCoords[2];\n            }\n\n            return dpx * dix + dpy * diy >= 0;\n        },\n\n        /**\n         * If you're looking from point \"start\" towards point \"s\" and you can see the point \"p\", return true.\n         * Otherwise return false.\n         * @param {JXG.Coords} start The point you're standing on.\n         * @param {JXG.Coords} p The point in which direction you're looking.\n         * @param {JXG.Coords} s The point that should be visible.\n         * @returns {Boolean} True, if from start the point p is in the same direction as s is, that means s-start = k*(p-start) with k>=0.\n         */\n        isSameDirection: function (start, p, s) {\n            var dx,\n                dy,\n                sx,\n                sy,\n                r = false;\n\n            dx = p.usrCoords[1] - start.usrCoords[1];\n            dy = p.usrCoords[2] - start.usrCoords[2];\n\n            sx = s.usrCoords[1] - start.usrCoords[1];\n            sy = s.usrCoords[2] - start.usrCoords[2];\n\n            if (Math.abs(dx) < Mat.eps) {\n                dx = 0;\n            }\n\n            if (Math.abs(dy) < Mat.eps) {\n                dy = 0;\n            }\n\n            if (Math.abs(sx) < Mat.eps) {\n                sx = 0;\n            }\n\n            if (Math.abs(sy) < Mat.eps) {\n                sy = 0;\n            }\n\n            if (dx >= 0 && sx >= 0) {\n                r = (dy >= 0 && sy >= 0) || (dy <= 0 && sy <= 0);\n            } else if (dx <= 0 && sx <= 0) {\n                r = (dy >= 0 && sy >= 0) || (dy <= 0 && sy <= 0);\n            }\n\n            return r;\n        },\n\n        /**\n         * Determinant of three points in the Euclidean plane.\n         * Zero, if the points are collinear. Used to determine of a point q is left or\n         * right to a segment defined by points p1 and p2.\n         *\n         * @param  {Array} p1 Coordinates of the first point of the segment. Array of length 3. First coordinate is equal to 1.\n         * @param  {Array} p2 Coordinates of the second point of the segment. Array of length 3. First coordinate is equal to 1.\n         * @param  {Array} q Coordinates of the point. Array of length 3. First coordinate is equal to 1.\n         * @return {Number} Signed area of the triangle formed by these three points.\n         *\n         * @see #windingNumber\n         */\n        det3p: function (p1, p2, q) {\n            return (p1[1] - q[1]) * (p2[2] - q[2]) - (p2[1] - q[1]) * (p1[2] - q[2]);\n        },\n\n        /**\n         * Winding number of a point in respect to a polygon path.\n         *\n         * The point is regarded outside if the winding number is zero,\n         * inside otherwise. The algorithm tries to find degenerate cases, i.e.\n         * if the point is on the path. This is regarded as \"outside\".\n         * If the point is a vertex of the path, it is regarded as \"inside\".\n         *\n         * Implementation of algorithm 7 from \"The point in polygon problem for\n         * arbitrary polygons\" by Kai Hormann and Alexander Agathos, Computational Geometry,\n         * Volume 20, Issue 3, November 2001, Pages 131-144.\n         *\n         * @param  {Array} usrCoords Homogenous coordinates of the point\n         * @param  {Array} path      Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements\n         * do not have to be full points, but have to have a subobject \"coords\" or should be of type JXG.Coords.\n         * @param  {Boolean} [doNotClosePath=false] If true the last point of the path is not connected to the first point.\n         * This is necessary if the path consists of two or more closed subpaths, e.g. if the figure has a hole.\n         *\n         * @return {Number}          Winding number of the point. The point is\n         *                           regarded outside if the winding number is zero,\n         *                           inside otherwise.\n         */\n        windingNumber: function (usrCoords, path, doNotClosePath) {\n            var wn = 0,\n                le = path.length,\n                x = usrCoords[1],\n                y = usrCoords[2],\n                p0,\n                p1,\n                p2,\n                d,\n                sign,\n                i,\n                off = 0;\n\n            if (le === 0) {\n                return 0;\n            }\n\n            doNotClosePath = doNotClosePath || false;\n            if (doNotClosePath) {\n                off = 1;\n            }\n\n            // Infinite points are declared outside\n            if (isNaN(x) || isNaN(y)) {\n                return 1;\n            }\n\n            if (Type.exists(path[0].coords)) {\n                p0 = path[0].coords;\n                p1 = path[le - 1].coords;\n            } else {\n                p0 = path[0];\n                p1 = path[le - 1];\n            }\n            // Handle the case if the point is the first vertex of the path, i.e. inside.\n            if (p0.usrCoords[1] === x && p0.usrCoords[2] === y) {\n                return 1;\n            }\n\n            for (i = 0; i < le - off; i++) {\n                // Consider the edge from p1 = path[i] to p2 = path[i+1]isClosedPath\n                if (Type.exists(path[i].coords)) {\n                    p1 = path[i].coords.usrCoords;\n                    p2 = path[(i + 1) % le].coords.usrCoords;\n                } else {\n                    p1 = path[i].usrCoords;\n                    p2 = path[(i + 1) % le].usrCoords;\n                }\n\n                // If one of the two points p1, p2 is undefined or infinite,\n                // move on.\n                if (\n                    p1[0] === 0 ||\n                    p2[0] === 0 ||\n                    isNaN(p1[1]) ||\n                    isNaN(p2[1]) ||\n                    isNaN(p1[2]) ||\n                    isNaN(p2[2])\n                ) {\n                    continue;\n                }\n\n                if (p2[2] === y) {\n                    if (p2[1] === x) {\n                        return 1;\n                    }\n                    if (p1[2] === y && p2[1] > x === p1[1] < x) {\n                        return 0;\n                    }\n                }\n\n                if (p1[2] < y !== p2[2] < y) {\n                    // Crossing\n                    sign = 2 * (p2[2] > p1[2] ? 1 : 0) - 1;\n                    if (p1[1] >= x) {\n                        if (p2[1] > x) {\n                            wn += sign;\n                        } else {\n                            d = this.det3p(p1, p2, usrCoords);\n                            if (d === 0) {\n                                // Point is on line, i.e. outside\n                                return 0;\n                            }\n                            if (d > 0 + Mat.eps === p2[2] > p1[2]) {\n                                // Right crossing\n                                wn += sign;\n                            }\n                        }\n                    } else {\n                        if (p2[1] > x) {\n                            d = this.det3p(p1, p2, usrCoords);\n                            if (d > 0 + Mat.eps === p2[2] > p1[2]) {\n                                // Right crossing\n                                wn += sign;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return wn;\n        },\n\n        /**\n         * Decides if a point (x,y) is inside of a path / polygon.\n         * Does not work correct if the path has hole. In this case, windingNumber is the preferred method.\n         * Implements W. Randolf Franklin's pnpoly method.\n         *\n         * See <a href=\"https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\">https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html</a>.\n         *\n         * @param {Number} x_in x-coordinate (screen or user coordinates)\n         * @param {Number} y_in y-coordinate (screen or user coordinates)\n         * @param  {Array} path  Array of points / coords determining a path, i.e. the vertices of the polygon / path. The array elements\n         * do not have to be full points, but have to have a subobject \"coords\" or should be of type JXG.Coords.\n         * @param {Number} [coord_type=JXG.COORDS_BY_SCREEN] Type of coordinates used here.\n         *   Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.\n         *   Default value is JXG.COORDS_BY_SCREEN.\n         *\n         * @returns {Boolean} if (x_in, y_in) is inside of the polygon.\n         * @see JXG.Polygon.hasPoint\n         * @see JXG.Polygon.pnpoly\n         * @see #windingNumber\n         *\n         * @example\n         * var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n         * var p = board.create('point', [4, 3]);\n         * var txt = board.create('text', [-1, 0.5, function() {\n         *   return 'Point A is inside of the polygon = ' +\n         *     JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);\n         * }]);\n         *\n         * </pre><div id=\"JXG4656ed42-f965-4e35-bb66-c334a4529683\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         *     (function() {\n         *         var board = JXG.JSXGraph.initBoard('JXG4656ed42-f965-4e35-bb66-c334a4529683',\n         *             {boundingbox: [-2, 5, 5,-2], axis: true, showcopyright: false, shownavigation: false});\n         *     var pol = board.create('polygon', [[-1,2], [2,2], [-1,4]]);\n         *     var p = board.create('point', [4, 3]);\n         *     var txt = board.create('text', [-1, 0.5, function() {\n         *     \t\treturn 'Point A is inside of the polygon = ' + JXG.Math.Geometry.pnpoly(p.X(), p.Y(), JXG.COORDS_BY_USER, pol.vertices);\n         *     }]);\n         *\n         *     })();\n         *\n         * </script><pre>\n         *\n         */\n        pnpoly: function (x_in, y_in, path, coord_type) {\n            var i,\n                j,\n                len,\n                x,\n                y,\n                crds,\n                v = path,\n                vi,\n                vj,\n                isIn = false;\n\n            if (coord_type === Const.COORDS_BY_USER) {\n                crds = new Coords(Const.COORDS_BY_USER, [x_in, y_in], this.board);\n                x = crds.scrCoords[1];\n                y = crds.scrCoords[2];\n            } else {\n                x = x_in;\n                y = y_in;\n            }\n\n            len = path.length;\n            for (i = 0, j = len - 2; i < len - 1; j = i++) {\n                vi = Type.exists(v[i].coords) ? v[i].coords : v[i];\n                vj = Type.exists(v[j].coords) ? v[j].coords : v[j];\n\n                if (\n                    vi.scrCoords[2] > y !== vj.scrCoords[2] > y &&\n                    x <\n                    ((vj.scrCoords[1] - vi.scrCoords[1]) * (y - vi.scrCoords[2])) /\n                    (vj.scrCoords[2] - vi.scrCoords[2]) +\n                    vi.scrCoords[1]\n                ) {\n                    isIn = !isIn;\n                }\n            }\n\n            return isIn;\n        },\n\n        /****************************************/\n        /****          INTERSECTIONS         ****/\n        /****************************************/\n\n        /**\n         * Generate the function which computes the coordinates of the intersection point.\n         * Primarily used in {@link JXG.Point#createIntersectionPoint}.\n         * @param {JXG.Board} board object\n         * @param {JXG.Line,JXG.Circle_JXG.Line,JXG.Circle_Number|Function} el1,el2,i The result will be a intersection point on el1 and el2.\n         * i determines the intersection point if two points are available: <ul>\n         *   <li>i==0: use the positive square root,</li>\n         *   <li>i==1: use the negative square root.</li></ul>\n         * See further {@link JXG.Point#createIntersectionPoint}.\n         * @param {Boolean} alwaysintersect. Flag that determines if segments and arc can have an outer intersection point\n         * on their defining line or circle.\n         * @returns {Function} Function returning a {@link JXG.Coords} object that determines\n         * the intersection point.\n         */\n        intersectionFunction: function (board, el1, el2, i, j, alwaysintersect) {\n            var func,\n                that = this,\n                el1_isArcType = false,\n                el2_isArcType = false;\n\n            el1_isArcType =\n                el1.elementClass === Const.OBJECT_CLASS_CURVE &&\n                    (el1.type === Const.OBJECT_TYPE_ARC || el1.type === Const.OBJECT_TYPE_SECTOR)\n                    ? true\n                    : false;\n            el2_isArcType =\n                el2.elementClass === Const.OBJECT_CLASS_CURVE &&\n                    (el2.type === Const.OBJECT_TYPE_ARC || el2.type === Const.OBJECT_TYPE_SECTOR)\n                    ? true\n                    : false;\n\n            if (\n                (el1.elementClass === Const.OBJECT_CLASS_CURVE ||\n                    el2.elementClass === Const.OBJECT_CLASS_CURVE) &&\n                (el1.elementClass === Const.OBJECT_CLASS_CURVE ||\n                    el1.elementClass === Const.OBJECT_CLASS_CIRCLE) &&\n                (el2.elementClass === Const.OBJECT_CLASS_CURVE ||\n                    el2.elementClass === Const.OBJECT_CLASS_CIRCLE) /*&&\n                !(el1_isArcType && el2_isArcType)*/\n            ) {\n                // curve - curve\n                // with the exception that both elements are arc types\n                /** @ignore */\n                func = function () {\n                    return that.meetCurveCurve(el1, el2, i, j, el1.board);\n                };\n            } else if (\n                (el1.elementClass === Const.OBJECT_CLASS_CURVE &&\n                    !el1_isArcType &&\n                    el2.elementClass === Const.OBJECT_CLASS_LINE) ||\n                (el2.elementClass === Const.OBJECT_CLASS_CURVE &&\n                    !el2_isArcType &&\n                    el1.elementClass === Const.OBJECT_CLASS_LINE)\n            ) {\n                // curve - line (this includes intersections between conic sections and lines)\n                // with the exception that the curve is of arc type\n                /** @ignore */\n                func = function () {\n                    return that.meetCurveLine(el1, el2, i, el1.board, Type.evaluate(alwaysintersect));\n                };\n            } else if (\n                el1.type === Const.OBJECT_TYPE_POLYGON ||\n                el2.type === Const.OBJECT_TYPE_POLYGON\n            ) {\n                // polygon - other\n                // Uses the Greiner-Hormann clipping algorithm\n                // Not implemented: polygon - point\n\n                if (el1.elementClass === Const.OBJECT_CLASS_LINE) {\n                    // line - path\n                    /** @ignore */\n                    func = function () {\n                        var first1 = Type.evaluate(el1.visProp.straightfirst),\n                            last1 = Type.evaluate(el1.visProp.straightlast),\n                            first2 = Type.evaluate(el2.visProp.straightfirst),\n                            last2 = Type.evaluate(el2.visProp.straightlast),\n                            a_not;\n\n                        a_not = (!Type.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2));\n                        return that.meetPolygonLine(el2, el1, i, el1.board, a_not);\n                    };\n                } else if (el2.elementClass === Const.OBJECT_CLASS_LINE) {\n                    // path - line\n                    func = function () {\n                        var first1 = Type.evaluate(el1.visProp.straightfirst),\n                            last1 = Type.evaluate(el1.visProp.straightlast),\n                            first2 = Type.evaluate(el2.visProp.straightfirst),\n                            last2 = Type.evaluate(el2.visProp.straightlast),\n                            a_not;\n\n                        a_not = (!Type.evaluate(alwaysintersect) && (!first1 || !last1 || !first2 || !last2));\n                        return that.meetPolygonLine(el1, el2, i, el1.board, a_not);\n                    };\n                } else {\n                    // path - path\n                    /** @ignore */\n                    func = function () {\n                        return that.meetPathPath(el1, el2, i, el1.board);\n                    };\n                }\n            } else if (\n                el1.elementClass === Const.OBJECT_CLASS_LINE &&\n                el2.elementClass === Const.OBJECT_CLASS_LINE\n            ) {\n                // line - line, lines may also be segments.\n                /** @ignore */\n                func = function () {\n                    var res,\n                        c,\n                        first1 = Type.evaluate(el1.visProp.straightfirst),\n                        last1 = Type.evaluate(el1.visProp.straightlast),\n                        first2 = Type.evaluate(el2.visProp.straightfirst),\n                        last2 = Type.evaluate(el2.visProp.straightlast);\n\n                    /**\n                     * If one of the lines is a segment or ray and\n                     * the intersection point should disappear if outside\n                     * of the segment or ray we call\n                     * meetSegmentSegment\n                     */\n                    if (\n                        !Type.evaluate(alwaysintersect) &&\n                        (!first1 || !last1 || !first2 || !last2)\n                    ) {\n                        res = that.meetSegmentSegment(\n                            el1.point1.coords.usrCoords,\n                            el1.point2.coords.usrCoords,\n                            el2.point1.coords.usrCoords,\n                            el2.point2.coords.usrCoords\n                        );\n\n                        if (\n                            (!first1 && res[1] < 0) ||\n                            (!last1 && res[1] > 1) ||\n                            (!first2 && res[2] < 0) ||\n                            (!last2 && res[2] > 1)\n                        ) {\n                            // Non-existent\n                            c = [0, NaN, NaN];\n                        } else {\n                            c = res[0];\n                        }\n\n                        return new Coords(Const.COORDS_BY_USER, c, el1.board);\n                    }\n\n                    return that.meet(el1.stdform, el2.stdform, i, el1.board);\n                };\n            } else {\n                // All other combinations of circles and lines,\n                // Arc types are treated as circles.\n                /** @ignore */\n                func = function () {\n                    var res = that.meet(el1.stdform, el2.stdform, i, el1.board),\n                        has = true,\n                        first,\n                        last,\n                        r;\n\n                    if (Type.evaluate(alwaysintersect)) {\n                        return res;\n                    }\n                    if (el1.elementClass === Const.OBJECT_CLASS_LINE) {\n                        first = Type.evaluate(el1.visProp.straightfirst);\n                        last = Type.evaluate(el1.visProp.straightlast);\n                        if (!first || !last) {\n                            r = that.affineRatio(el1.point1.coords, el1.point2.coords, res);\n                            if ((!last && r > 1 + Mat.eps) || (!first && r < 0 - Mat.eps)) {\n                                return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n                            }\n                        }\n                    }\n                    if (el2.elementClass === Const.OBJECT_CLASS_LINE) {\n                        first = Type.evaluate(el2.visProp.straightfirst);\n                        last = Type.evaluate(el2.visProp.straightlast);\n                        if (!first || !last) {\n                            r = that.affineRatio(el2.point1.coords, el2.point2.coords, res);\n                            if ((!last && r > 1 + Mat.eps) || (!first && r < 0 - Mat.eps)) {\n                                return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n                            }\n                        }\n                    }\n                    if (el1_isArcType) {\n                        has = that.coordsOnArc(el1, res);\n                        if (has && el2_isArcType) {\n                            has = that.coordsOnArc(el2, res);\n                        }\n                        if (!has) {\n                            return new Coords(JXG.COORDS_BY_USER, [0, NaN, NaN], el1.board);\n                        }\n                    }\n                    return res;\n                };\n            }\n\n            return func;\n        },\n\n        /**\n         * Returns true if the coordinates are on the arc element,\n         * false otherwise. Usually, coords is an intersection\n         * on the circle line. Now it is decided if coords are on the\n         * circle restricted to the arc line.\n         * @param  {Arc} arc arc or sector element\n         * @param  {JXG.Coords} coords Coords object of an intersection\n         * @returns {Boolean}\n         * @private\n         */\n        coordsOnArc: function (arc, coords) {\n            var angle = this.rad(arc.radiuspoint, arc.center, coords.usrCoords.slice(1)),\n                alpha = 0.0,\n                beta = this.rad(arc.radiuspoint, arc.center, arc.anglepoint),\n                ev_s = Type.evaluate(arc.visProp.selection);\n\n            if ((ev_s === \"minor\" && beta > Math.PI) || (ev_s === \"major\" && beta < Math.PI)) {\n                alpha = beta;\n                beta = 2 * Math.PI;\n            }\n            if (angle < alpha || angle > beta) {\n                return false;\n            }\n            return true;\n        },\n\n        /**\n         * Computes the intersection of a pair of lines, circles or both.\n         * It uses the internal data array stdform of these elements.\n         * @param {Array} el1 stdform of the first element (line or circle)\n         * @param {Array} el2 stdform of the second element (line or circle)\n         * @param {Number|Function} i Index of the intersection point that should be returned.\n         * @param board Reference to the board.\n         * @returns {JXG.Coords} Coordinates of one of the possible two or more intersection points.\n         * Which point will be returned is determined by i.\n         */\n        meet: function (el1, el2, i, board) {\n            var result,\n                eps = Mat.eps;\n\n            if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) < eps) {\n                // line line\n                result = this.meetLineLine(el1, el2, i, board);\n            } else if (Math.abs(el1[3]) >= eps && Math.abs(el2[3]) < eps) {\n                // circle line\n                result = this.meetLineCircle(el2, el1, i, board);\n            } else if (Math.abs(el1[3]) < eps && Math.abs(el2[3]) >= eps) {\n                // line circle\n                result = this.meetLineCircle(el1, el2, i, board);\n            } else {\n                // circle circle\n                result = this.meetCircleCircle(el1, el2, i, board);\n            }\n\n            return result;\n        },\n\n        /**\n         * Intersection of the line with the board\n         * @param  {Array}     line   stdform of the line in screen coordinates\n         * @param  {JXG.Board} board  reference to a board.\n         * @param  {Number}    margin optional margin, to avoid the display of the small sides of lines.\n         * @returns {Array}            [intersection coords 1, intersection coords 2]\n         */\n        meetLineBoard: function (line, board, margin) {\n            // Intersect the line with the four borders of the board.\n            var s = [],\n                intersect1,\n                intersect2,\n                i, j;\n\n            if (!Type.exists(margin)) {\n                margin = 0;\n            }\n\n            // top\n            s[0] = Mat.crossProduct(line, [margin, 0, 1]);\n            // left\n            s[1] = Mat.crossProduct(line, [margin, 1, 0]);\n            // bottom\n            s[2] = Mat.crossProduct(line, [-margin - board.canvasHeight, 0, 1]);\n            // right\n            s[3] = Mat.crossProduct(line, [-margin - board.canvasWidth, 1, 0]);\n\n            // Normalize the intersections\n            for (i = 0; i < 4; i++) {\n                if (Math.abs(s[i][0]) > Mat.eps) {\n                    for (j = 2; j > 0; j--) {\n                        s[i][j] /= s[i][0];\n                    }\n                    s[i][0] = 1.0;\n                }\n            }\n\n            // line is parallel to \"left\", take \"top\" and \"bottom\"\n            if (Math.abs(s[1][0]) < Mat.eps) {\n                intersect1 = s[0]; // top\n                intersect2 = s[2]; // bottom\n                // line is parallel to \"top\", take \"left\" and \"right\"\n            } else if (Math.abs(s[0][0]) < Mat.eps) {\n                intersect1 = s[1]; // left\n                intersect2 = s[3]; // right\n                // left intersection out of board (above)\n            } else if (s[1][2] < 0) {\n                intersect1 = s[0]; // top\n\n                // right intersection out of board (below)\n                if (s[3][2] > board.canvasHeight) {\n                    intersect2 = s[2]; // bottom\n                } else {\n                    intersect2 = s[3]; // right\n                }\n                // left intersection out of board (below)\n            } else if (s[1][2] > board.canvasHeight) {\n                intersect1 = s[2]; // bottom\n\n                // right intersection out of board (above)\n                if (s[3][2] < 0) {\n                    intersect2 = s[0]; // top\n                } else {\n                    intersect2 = s[3]; // right\n                }\n            } else {\n                intersect1 = s[1]; // left\n\n                // right intersection out of board (above)\n                if (s[3][2] < 0) {\n                    intersect2 = s[0]; // top\n                    // right intersection out of board (below)\n                } else if (s[3][2] > board.canvasHeight) {\n                    intersect2 = s[2]; // bottom\n                } else {\n                    intersect2 = s[3]; // right\n                }\n            }\n\n            return [\n                new Coords(Const.COORDS_BY_SCREEN, intersect1.slice(1), board),\n                new Coords(Const.COORDS_BY_SCREEN, intersect2.slice(1), board)\n            ];\n        },\n\n        /**\n         * Intersection of two lines.\n         * @param {Array} l1 stdform of the first line\n         * @param {Array} l2 stdform of the second line\n         * @param {number} i unused\n         * @param {JXG.Board} board Reference to the board.\n         * @returns {JXG.Coords} Coordinates of the intersection point.\n         */\n        meetLineLine: function (l1, l2, i, board) {\n            var s = isNaN(l1[5] + l2[5]) ? [0, 0, 0] : Mat.crossProduct(l1, l2);\n\n            // Make intersection of parallel lines more robust:\n            if (Math.abs(s[0]) < 1.0e-14) {\n                s[0] = 0;\n            }\n            return new Coords(Const.COORDS_BY_USER, s, board);\n        },\n\n        /**\n         * Intersection of line and circle.\n         * @param {Array} lin stdform of the line\n         * @param {Array} circ stdform of the circle\n         * @param {number|function} i number of the returned intersection point.\n         *   i==0: use the positive square root,\n         *   i==1: use the negative square root.\n         * @param {JXG.Board} board Reference to a board.\n         * @returns {JXG.Coords} Coordinates of the intersection point\n         */\n        meetLineCircle: function (lin, circ, i, board) {\n            var a, b, c, d, n, A, B, C, k, t;\n\n            // Radius is zero, return center of circle\n            if (circ[4] < Mat.eps) {\n                if (Math.abs(Mat.innerProduct([1, circ[6], circ[7]], lin, 3)) < Mat.eps) {\n                    return new Coords(Const.COORDS_BY_USER, circ.slice(6, 8), board);\n                }\n\n                return new Coords(Const.COORDS_BY_USER, [NaN, NaN], board);\n            }\n            c = circ[0];\n            b = circ.slice(1, 3);\n            a = circ[3];\n            d = lin[0];\n            n = lin.slice(1, 3);\n\n            // Line is assumed to be normalized. Therefore, nn==1 and we can skip some operations:\n            /*\n             var nn = n[0]*n[0]+n[1]*n[1];\n             A = a*nn;\n             B = (b[0]*n[1]-b[1]*n[0])*nn;\n             C = a*d*d - (b[0]*n[0]+b[1]*n[1])*d + c*nn;\n             */\n            A = a;\n            B = b[0] * n[1] - b[1] * n[0];\n            C = a * d * d - (b[0] * n[0] + b[1] * n[1]) * d + c;\n\n            k = B * B - 4 * A * C;\n            if (k > -Mat.eps * Mat.eps) {\n                k = Math.sqrt(Math.abs(k));\n                t = [(-B + k) / (2 * A), (-B - k) / (2 * A)];\n\n                return Type.evaluate(i) === 0\n                    ? new Coords(\n                        Const.COORDS_BY_USER,\n                        [-t[0] * -n[1] - d * n[0], -t[0] * n[0] - d * n[1]],\n                        board\n                    )\n                    : new Coords(\n                        Const.COORDS_BY_USER,\n                        [-t[1] * -n[1] - d * n[0], -t[1] * n[0] - d * n[1]],\n                        board\n                    );\n            }\n\n            return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n        },\n\n        /**\n         * Intersection of two circles.\n         * @param {Array} circ1 stdform of the first circle\n         * @param {Array} circ2 stdform of the second circle\n         * @param {number|function} i number of the returned intersection point.\n         *   i==0: use the positive square root,\n         *   i==1: use the negative square root.\n         * @param {JXG.Board} board Reference to the board.\n         * @returns {JXG.Coords} Coordinates of the intersection point\n         */\n        meetCircleCircle: function (circ1, circ2, i, board) {\n            var radicalAxis;\n\n            // Radius is zero, return center of circle, if on other circle\n            if (circ1[4] < Mat.eps) {\n                if (\n                    Math.abs(this.distance(circ1.slice(6, 2), circ2.slice(6, 8)) - circ2[4]) <\n                    Mat.eps\n                ) {\n                    return new Coords(Const.COORDS_BY_USER, circ1.slice(6, 8), board);\n                }\n\n                return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n            }\n\n            // Radius is zero, return center of circle, if on other circle\n            if (circ2[4] < Mat.eps) {\n                if (\n                    Math.abs(this.distance(circ2.slice(6, 2), circ1.slice(6, 8)) - circ1[4]) <\n                    Mat.eps\n                ) {\n                    return new Coords(Const.COORDS_BY_USER, circ2.slice(6, 8), board);\n                }\n\n                return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n            }\n\n            radicalAxis = [\n                circ2[3] * circ1[0] - circ1[3] * circ2[0],\n                circ2[3] * circ1[1] - circ1[3] * circ2[1],\n                circ2[3] * circ1[2] - circ1[3] * circ2[2],\n                0,\n                1,\n                Infinity,\n                Infinity,\n                Infinity\n            ];\n            radicalAxis = Mat.normalize(radicalAxis);\n\n            return this.meetLineCircle(radicalAxis, circ1, i, board);\n        },\n\n        /**\n         * Compute an intersection of the curves c1 and c2.\n         * We want to find values t1, t2 such that\n         * c1(t1) = c2(t2), i.e. (c1_x(t1)-c2_x(t2),c1_y(t1)-c2_y(t2)) = (0,0).\n         *\n         * Methods: segment-wise intersections (default) or generalized Newton method.\n         * @param {JXG.Curve} c1 Curve, Line or Circle\n         * @param {JXG.Curve} c2 Curve, Line or Circle\n         * @param {Number|Function} nr the nr-th intersection point will be returned.\n         * @param {Number} t2ini not longer used.\n         * @param {JXG.Board} [board=c1.board] Reference to a board object.\n         * @param {String} [method='segment'] Intersection method, possible values are 'newton' and 'segment'.\n         * @returns {JXG.Coords} intersection point\n         */\n        meetCurveCurve: function (c1, c2, nr, t2ini, board, method) {\n            var co;\n\n            if (Type.exists(method) && method === \"newton\") {\n                co = Numerics.generalizedNewton(c1, c2, Type.evaluate(nr), t2ini);\n            } else {\n                if (c1.bezierDegree === 3 || c2.bezierDegree === 3) {\n                    co = this.meetBezierCurveRedBlueSegments(c1, c2, nr);\n                } else {\n                    co = this.meetCurveRedBlueSegments(c1, c2, nr);\n                }\n            }\n\n            return new Coords(Const.COORDS_BY_USER, co, board);\n        },\n\n        /**\n         * Intersection of curve with line,\n         * Order of input does not matter for el1 and el2.\n         * From version 0.99.7 on this method calls\n         * {@link JXG.Math.Geometry.meetCurveLineDiscrete}.\n         * If higher precision is needed, {@link JXG.Math.Geometry.meetCurveLineContinuous}\n         * has to be used.\n         *\n         * @param {JXG.Curve|JXG.Line} el1 Curve or Line\n         * @param {JXG.Curve|JXG.Line} el2 Curve or Line\n         * @param {Number|Function} nr the nr-th intersection point will be returned.\n         * @param {JXG.Board} [board=el1.board] Reference to a board object.\n         * @param {Boolean} alwaysIntersect If false just the segment between the two defining points are tested for intersection\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,1,0] is returned.\n         */\n        meetCurveLine: function (el1, el2, nr, board, alwaysIntersect) {\n            var v = [0, NaN, NaN],\n                cu,\n                li;\n\n            if (!Type.exists(board)) {\n                board = el1.board;\n            }\n\n            if (el1.elementClass === Const.OBJECT_CLASS_CURVE) {\n                cu = el1;\n                li = el2;\n            } else {\n                cu = el2;\n                li = el1;\n            }\n\n            v = this.meetCurveLineDiscrete(cu, li, nr, board, !alwaysIntersect);\n\n            return v;\n        },\n\n        /**\n         * Intersection of line and curve, continuous case.\n         * Finds the nr-the intersection point\n         * Uses {@link JXG.Math.Geometry.meetCurveLineDiscrete} as a first approximation.\n         * A more exact solution is then found with {@link JXG.Math.Numerics.root}.\n         *\n         * @param {JXG.Curve} cu Curve\n         * @param {JXG.Line} li Line\n         * @param {NumberFunction} nr Will return the nr-th intersection point.\n         * @param {JXG.Board} board\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the\n         * line defined by the segment\n         * @returns {JXG.Coords} Coords object containing the intersection.\n         */\n        meetCurveLineContinuous: function (cu, li, nr, board, testSegment) {\n            var t,\n                func0,\n                func1,\n                v,\n                x,\n                y,\n                z,\n                eps = Mat.eps,\n                epsLow = Mat.eps,\n                steps,\n                delta,\n                tnew,\n                i,\n                tmin,\n                fmin,\n                ft;\n\n            v = this.meetCurveLineDiscrete(cu, li, nr, board, testSegment);\n            x = v.usrCoords[1];\n            y = v.usrCoords[2];\n\n            func0 = function (t) {\n                var c1, c2;\n\n                if (t > cu.maxX() || t < cu.minX()) {\n                    return Infinity;\n                }\n                c1 = x - cu.X(t);\n                c2 = y - cu.Y(t);\n                return c1 * c1 + c2 * c2;\n            };\n\n            func1 = function (t) {\n                var v = li.stdform[0] + li.stdform[1] * cu.X(t) + li.stdform[2] * cu.Y(t);\n                return v * v;\n            };\n\n            // Find t\n            steps = 50;\n            delta = (cu.maxX() - cu.minX()) / steps;\n            tnew = cu.minX();\n\n            fmin = 0.0001; //eps;\n            tmin = NaN;\n            for (i = 0; i < steps; i++) {\n                t = Numerics.root(func0, [\n                    Math.max(tnew, cu.minX()),\n                    Math.min(tnew + delta, cu.maxX())\n                ]);\n                ft = Math.abs(func0(t));\n                if (ft <= fmin) {\n                    fmin = ft;\n                    tmin = t;\n                    if (fmin < eps) {\n                        break;\n                    }\n                }\n\n                tnew += delta;\n            }\n            t = tmin;\n            // Compute \"exact\" t\n            t = Numerics.root(func1, [\n                Math.max(t - delta, cu.minX()),\n                Math.min(t + delta, cu.maxX())\n            ]);\n\n            ft = func1(t);\n            // Is the point on the line?\n            if (isNaN(ft) || Math.abs(ft) > epsLow) {\n                z = 0.0; //NaN;\n            } else {\n                z = 1.0;\n            }\n\n            return new Coords(Const.COORDS_BY_USER, [z, cu.X(t), cu.Y(t)], board);\n        },\n\n        /**\n         * Intersection of line and curve, discrete case.\n         * Segments are treated as lines.\n         * Finding the nr-th intersection point should work for all nr.\n         * @param {JXG.Curve} cu\n         * @param {JXG.Line} li\n         * @param {Number|Function} nr\n         * @param {JXG.Board} board\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the\n         * line defined by the segment\n         *\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,1,0] is returned.\n         */\n        meetCurveLineDiscrete: function (cu, li, nr, board, testSegment) {\n            var i,\n                j,\n                n = Type.evaluate(nr),\n                p1,\n                p2,\n                p,\n                q,\n                lip1 = li.point1.coords.usrCoords,\n                lip2 = li.point2.coords.usrCoords,\n                d,\n                res,\n                cnt = 0,\n                len = cu.numberPoints,\n                ev_sf = Type.evaluate(li.visProp.straightfirst),\n                ev_sl = Type.evaluate(li.visProp.straightlast);\n\n            // In case, no intersection will be found we will take this\n            q = new Coords(Const.COORDS_BY_USER, [0, NaN, NaN], board);\n\n            if (lip1[0] === 0.0) {\n                lip1 = [1, lip2[1] + li.stdform[2], lip2[2] - li.stdform[1]];\n            } else if (lip2[0] === 0.0) {\n                lip2 = [1, lip1[1] + li.stdform[2], lip1[2] - li.stdform[1]];\n            }\n\n            p2 = cu.points[0].usrCoords;\n            for (i = 1; i < len; i += cu.bezierDegree) {\n                p1 = p2.slice(0);\n                p2 = cu.points[i].usrCoords;\n                d = this.distance(p1, p2);\n\n                // The defining points are not identical\n                if (d > Mat.eps) {\n                    if (cu.bezierDegree === 3) {\n                        res = this.meetBeziersegmentBeziersegment(\n                            [\n                                cu.points[i - 1].usrCoords.slice(1),\n                                cu.points[i].usrCoords.slice(1),\n                                cu.points[i + 1].usrCoords.slice(1),\n                                cu.points[i + 2].usrCoords.slice(1)\n                            ],\n                            [lip1.slice(1), lip2.slice(1)],\n                            testSegment\n                        );\n                    } else {\n                        res = [this.meetSegmentSegment(p1, p2, lip1, lip2)];\n                    }\n\n                    for (j = 0; j < res.length; j++) {\n                        p = res[j];\n                        if (0 <= p[1] && p[1] <= 1) {\n                            if (cnt === n) {\n                                /**\n                                 * If the intersection point is not part of the segment,\n                                 * this intersection point is set to non-existent.\n                                 * This prevents jumping behavior of the intersection points.\n                                 * But it may be discussed if it is the desired behavior.\n                                 */\n                                if (\n                                    testSegment &&\n                                    ((!ev_sf && p[2] < 0) || (!ev_sl && p[2] > 1))\n                                ) {\n                                    return q; // break;\n                                }\n\n                                q = new Coords(Const.COORDS_BY_USER, p[0], board);\n                                return q; // break;\n                            }\n                            cnt += 1;\n                        }\n                    }\n                }\n            }\n\n            return q;\n        },\n\n        /**\n         * Find the n-th intersection point of two curves named red (first parameter) and blue (second parameter).\n         * We go through each segment of the red curve and search if there is an intersection with a segemnt of the blue curve.\n         * This double loop, i.e. the outer loop runs along the red curve and the inner loop runs along the blue curve, defines\n         * the n-th intersection point. The segments are either line segments or Bezier curves of degree 3. This depends on\n         * the property bezierDegree of the curves.\n         * <p>\n         * This method works also for transformed curves, since only the already\n         * transformed points are used.\n         *\n         * @param {JXG.Curve} red\n         * @param {JXG.Curve} blue\n         * @param {Number|Function} nr\n         */\n        meetCurveRedBlueSegments: function (red, blue, nr) {\n            var i,\n                j,\n                n = Type.evaluate(nr),\n                red1,\n                red2,\n                blue1,\n                blue2,\n                m,\n                minX,\n                maxX,\n                iFound = 0,\n                lenBlue = blue.numberPoints, //points.length,\n                lenRed = red.numberPoints; //points.length;\n\n            if (lenBlue <= 1 || lenRed <= 1) {\n                return [0, NaN, NaN];\n            }\n\n            for (i = 1; i < lenRed; i++) {\n                red1 = red.points[i - 1].usrCoords;\n                red2 = red.points[i].usrCoords;\n                minX = Math.min(red1[1], red2[1]);\n                maxX = Math.max(red1[1], red2[1]);\n\n                blue2 = blue.points[0].usrCoords;\n                for (j = 1; j < lenBlue; j++) {\n                    blue1 = blue2;\n                    blue2 = blue.points[j].usrCoords;\n\n                    if (\n                        Math.min(blue1[1], blue2[1]) < maxX &&\n                        Math.max(blue1[1], blue2[1]) > minX\n                    ) {\n                        m = this.meetSegmentSegment(red1, red2, blue1, blue2);\n                        if (\n                            m[1] >= 0.0 &&\n                            m[2] >= 0.0 &&\n                            // The two segments meet in the interior or at the start points\n                            ((m[1] < 1.0 && m[2] < 1.0) ||\n                                // One of the curve is intersected in the very last point\n                                (i === lenRed - 1 && m[1] === 1.0) ||\n                                (j === lenBlue - 1 && m[2] === 1.0))\n                        ) {\n                            if (iFound === n) {\n                                return m[0];\n                            }\n\n                            iFound++;\n                        }\n                    }\n                }\n            }\n\n            return [0, NaN, NaN];\n        },\n\n        /**\n         * (Virtual) Intersection of two segments.\n         * @param {Array} p1 First point of segment 1 using normalized homogeneous coordinates [1,x,y]\n         * @param {Array} p2 Second point or direction of segment 1 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively\n         * @param {Array} q1 First point of segment 2 using normalized homogeneous coordinates [1,x,y]\n         * @param {Array} q2 Second point or direction of segment 2 using normalized homogeneous coordinates [1,x,y] or point at infinity [0,x,y], respectively\n         * @returns {Array} [Intersection point, t, u] The first entry contains the homogeneous coordinates\n         * of the intersection point. The second and third entry give the position of the intersection with respect\n         * to the definiting parameters. For example, the second entry t is defined by: intersection point = p1 + t * deltaP, where\n         * deltaP = (p2 - p1) when both parameters are coordinates, and deltaP = p2 if p2 is a point at infinity.\n         * If the two segments are collinear, [[0,0,0], Infinity, Infinity] is returned.\n         **/\n        meetSegmentSegment: function (p1, p2, q1, q2) {\n            var t,\n                u,\n                i,\n                d,\n                li1 = Mat.crossProduct(p1, p2),\n                li2 = Mat.crossProduct(q1, q2),\n                c = Mat.crossProduct(li1, li2);\n\n            if (Math.abs(c[0]) < Mat.eps) {\n                return [c, Infinity, Infinity];\n            }\n\n            // Normalize the intersection coordinates\n            c[1] /= c[0];\n            c[2] /= c[0];\n            c[0] /= c[0];\n\n            // Now compute in principle:\n            //    t = dist(c - p1) / dist(p2 - p1) and\n            //    u = dist(c - q1) / dist(q2 - q1)\n            // However: the points q1, q2, p1, p2 might be ideal points - or in general - the\n            // coordinates might be not normalized.\n            // Note that the z-coordinates of p2 and q2 are used to determine whether it should be interpreted\n            // as a segment coordinate or a direction.\n            i = Math.abs(p2[1] - p2[0] * p1[1]) < Mat.eps ? 2 : 1;\n            d = p1[i] / p1[0];\n            t = (c[i] - d) / (p2[0] !== 0 ? p2[i] / p2[0] - d : p2[i]);\n\n            i = Math.abs(q2[1] - q2[0] * q1[1]) < Mat.eps ? 2 : 1;\n            d = q1[i] / q1[0];\n            u = (c[i] - d) / (q2[0] !== 0 ? q2[i] / q2[0] - d : q2[i]);\n\n            return [c, t, u];\n        },\n\n        /**\n         * Find the n-th intersection point of two pathes, usually given by polygons. Uses parts of the\n         * Greiner-Hormann algorithm in JXG.Math.Clip.\n         *\n         * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path1\n         * @param {JXG.Circle|JXG.Curve|JXG.Polygon} path2\n         * @param {Number|Function} n\n         * @param {JXG.Board} board\n         *\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,0,0] is returned.\n         *\n         */\n        meetPathPath: function (path1, path2, nr, board) {\n            var S, C, len, intersections,\n                n = Type.evaluate(nr);\n\n            S = JXG.Math.Clip._getPath(path1, board);\n            len = S.length;\n            if (\n                len > 0 &&\n                this.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < Mat.eps\n            ) {\n                S.pop();\n            }\n\n            C = JXG.Math.Clip._getPath(path2, board);\n            len = C.length;\n            if (\n                len > 0 &&\n                this.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) <\n                Mat.eps * Mat.eps\n            ) {\n                C.pop();\n            }\n\n            // Handle cases where at least one of the paths is empty\n            if (nr < 0 || JXG.Math.Clip.isEmptyCase(S, C, \"intersection\")) {\n                return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n            }\n\n            JXG.Math.Clip.makeDoublyLinkedList(S);\n            JXG.Math.Clip.makeDoublyLinkedList(C);\n\n            intersections = JXG.Math.Clip.findIntersections(S, C, board)[0];\n            if (n < intersections.length) {\n                return intersections[n].coords;\n            }\n            return new Coords(Const.COORDS_BY_USER, [0, 0, 0], board);\n        },\n\n        /**\n         * Find the n-th intersection point between a polygon and a line.\n         * @param {JXG.Polygon} path\n         * @param {JXG.Line} line\n         * @param {Number|Function} nr\n         * @param {JXG.Board} board\n         * @param {Boolean} alwaysIntersect If false just the segment between the two defining points of the line are tested for intersection.\n         *\n         * @returns {JXG.Coords} Intersection point. In case no intersection point is detected,\n         * the ideal point [0,0,0] is returned.\n         */\n        meetPolygonLine: function (path, line, nr, board, alwaysIntersect) {\n            var i,\n                n = Type.evaluate(nr),\n                res,\n                border,\n                crds = [0, 0, 0],\n                len = path.borders.length,\n                intersections = [];\n\n            for (i = 0; i < len; i++) {\n                border = path.borders[i];\n                res = this.meetSegmentSegment(\n                    border.point1.coords.usrCoords,\n                    border.point2.coords.usrCoords,\n                    line.point1.coords.usrCoords,\n                    line.point2.coords.usrCoords\n                );\n\n                if (\n                    (!alwaysIntersect || (res[2] >= 0 && res[2] < 1)) &&\n                    res[1] >= 0 &&\n                    res[1] < 1\n                ) {\n                    intersections.push(res[0]);\n                }\n            }\n\n            if (n >= 0 && n < intersections.length) {\n                crds = intersections[n];\n            }\n            return new Coords(Const.COORDS_BY_USER, crds, board);\n        },\n\n        /****************************************/\n        /****   BEZIER CURVE ALGORITHMS      ****/\n        /****************************************/\n\n        /**\n         * Splits a Bezier curve segment defined by four points into\n         * two Bezier curve segments. Dissection point is t=1/2.\n         * @param {Array} curve Array of four coordinate arrays of length 2 defining a\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @returns {Array} Array consisting of two coordinate arrays for Bezier curves.\n         */\n        _bezierSplit: function (curve) {\n            var p0, p1, p2, p00, p22, p000;\n\n            p0 = [(curve[0][0] + curve[1][0]) * 0.5, (curve[0][1] + curve[1][1]) * 0.5];\n            p1 = [(curve[1][0] + curve[2][0]) * 0.5, (curve[1][1] + curve[2][1]) * 0.5];\n            p2 = [(curve[2][0] + curve[3][0]) * 0.5, (curve[2][1] + curve[3][1]) * 0.5];\n\n            p00 = [(p0[0] + p1[0]) * 0.5, (p0[1] + p1[1]) * 0.5];\n            p22 = [(p1[0] + p2[0]) * 0.5, (p1[1] + p2[1]) * 0.5];\n\n            p000 = [(p00[0] + p22[0]) * 0.5, (p00[1] + p22[1]) * 0.5];\n\n            return [\n                [curve[0], p0, p00, p000],\n                [p000, p22, p2, curve[3]]\n            ];\n        },\n\n        /**\n         * Computes the bounding box [minX, maxY, maxX, minY] of a Bezier curve segment\n         * from its control points.\n         * @param {Array} curve Array of four coordinate arrays of length 2 defining a\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @returns {Array} Bounding box [minX, maxY, maxX, minY]\n         */\n        _bezierBbox: function (curve) {\n            var bb = [];\n\n            if (curve.length === 4) {\n                // bezierDegree == 3\n                bb[0] = Math.min(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // minX\n                bb[1] = Math.max(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // maxY\n                bb[2] = Math.max(curve[0][0], curve[1][0], curve[2][0], curve[3][0]); // maxX\n                bb[3] = Math.min(curve[0][1], curve[1][1], curve[2][1], curve[3][1]); // minY\n            } else {\n                // bezierDegree == 1\n                bb[0] = Math.min(curve[0][0], curve[1][0]); // minX\n                bb[1] = Math.max(curve[0][1], curve[1][1]); // maxY\n                bb[2] = Math.max(curve[0][0], curve[1][0]); // maxX\n                bb[3] = Math.min(curve[0][1], curve[1][1]); // minY\n            }\n\n            return bb;\n        },\n\n        /**\n         * Decide if two Bezier curve segments overlap by comparing their bounding boxes.\n         * @param {Array} bb1 Bounding box of the first Bezier curve segment\n         * @param {Array} bb2 Bounding box of the second Bezier curve segment\n         * @returns {Boolean} true if the bounding boxes overlap, false otherwise.\n         */\n        _bezierOverlap: function (bb1, bb2) {\n            return bb1[2] >= bb2[0] && bb1[0] <= bb2[2] && bb1[1] >= bb2[3] && bb1[3] <= bb2[1];\n        },\n\n        /**\n         * Append list of intersection points to a list.\n         * @private\n         */\n        _bezierListConcat: function (L, Lnew, t1, t2) {\n            var i,\n                t2exists = Type.exists(t2),\n                start = 0,\n                len = Lnew.length,\n                le = L.length;\n\n            if (\n                le > 0 &&\n                len > 0 &&\n                ((L[le - 1][1] === 1 && Lnew[0][1] === 0) ||\n                    (t2exists && L[le - 1][2] === 1 && Lnew[0][2] === 0))\n            ) {\n                start = 1;\n            }\n\n            for (i = start; i < len; i++) {\n                if (t2exists) {\n                    Lnew[i][2] *= 0.5;\n                    Lnew[i][2] += t2;\n                }\n\n                Lnew[i][1] *= 0.5;\n                Lnew[i][1] += t1;\n\n                L.push(Lnew[i]);\n            }\n        },\n\n        /**\n         * Find intersections of two Bezier curve segments by recursive subdivision.\n         * Below maxlevel determine intersections by intersection line segments.\n         * @param {Array} red Array of four coordinate arrays of length 2 defining the first\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Array} blue Array of four coordinate arrays of length 2 defining the second\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Number} level Recursion level\n         * @returns {Array} List of intersection points (up to nine). Each intersection point is an\n         * array of length three (homogeneous coordinates) plus preimages.\n         */\n        _bezierMeetSubdivision: function (red, blue, level) {\n            var bbb,\n                bbr,\n                ar,\n                b0,\n                b1,\n                r0,\n                r1,\n                m,\n                p0,\n                p1,\n                q0,\n                q1,\n                L = [],\n                maxLev = 5; // Maximum recursion level\n\n            bbr = this._bezierBbox(blue);\n            bbb = this._bezierBbox(red);\n\n            if (!this._bezierOverlap(bbr, bbb)) {\n                return [];\n            }\n\n            if (level < maxLev) {\n                ar = this._bezierSplit(red);\n                r0 = ar[0];\n                r1 = ar[1];\n\n                ar = this._bezierSplit(blue);\n                b0 = ar[0];\n                b1 = ar[1];\n\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r0, b0, level + 1),\n                    0.0,\n                    0.0\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r0, b1, level + 1),\n                    0,\n                    0.5\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r1, b0, level + 1),\n                    0.5,\n                    0.0\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierMeetSubdivision(r1, b1, level + 1),\n                    0.5,\n                    0.5\n                );\n\n                return L;\n            }\n\n            // Make homogeneous coordinates\n            q0 = [1].concat(red[0]);\n            q1 = [1].concat(red[3]);\n            p0 = [1].concat(blue[0]);\n            p1 = [1].concat(blue[3]);\n\n            m = this.meetSegmentSegment(q0, q1, p0, p1);\n\n            if (m[1] >= 0.0 && m[2] >= 0.0 && m[1] <= 1.0 && m[2] <= 1.0) {\n                return [m];\n            }\n\n            return [];\n        },\n\n        /**\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment\n         */\n        _bezierLineMeetSubdivision: function (red, blue, level, testSegment) {\n            var bbb, bbr, ar,\n                r0, r1,\n                m,\n                p0, p1, q0, q1,\n                L = [],\n                maxLev = 5; // Maximum recursion level\n\n            bbb = this._bezierBbox(blue);\n            bbr = this._bezierBbox(red);\n\n            if (testSegment && !this._bezierOverlap(bbr, bbb)) {\n                return [];\n            }\n\n            if (level < maxLev) {\n                ar = this._bezierSplit(red);\n                r0 = ar[0];\n                r1 = ar[1];\n\n                this._bezierListConcat(\n                    L,\n                    this._bezierLineMeetSubdivision(r0, blue, level + 1),\n                    0.0\n                );\n                this._bezierListConcat(\n                    L,\n                    this._bezierLineMeetSubdivision(r1, blue, level + 1),\n                    0.5\n                );\n\n                return L;\n            }\n\n            // Make homogeneous coordinates\n            q0 = [1].concat(red[0]);\n            q1 = [1].concat(red[3]);\n            p0 = [1].concat(blue[0]);\n            p1 = [1].concat(blue[1]);\n\n            m = this.meetSegmentSegment(q0, q1, p0, p1);\n\n            if (m[1] >= 0.0 && m[1] <= 1.0) {\n                if (!testSegment || (m[2] >= 0.0 && m[2] <= 1.0)) {\n                    return [m];\n                }\n            }\n\n            return [];\n        },\n\n        /**\n         * Find the nr-th intersection point of two Bezier curve segments.\n         * @param {Array} red Array of four coordinate arrays of length 2 defining the first\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Array} blue Array of four coordinate arrays of length 2 defining the second\n         * Bezier curve segment, i.e. [[x0,y0], [x1,y1], [x2,y2], [x3,y3]].\n         * @param {Boolean} testSegment Test if intersection has to be inside of the segment or somewhere on the line defined by the segment\n         * @returns {Array} Array containing the list of all intersection points as homogeneous coordinate arrays plus\n         * preimages [x,y], t_1, t_2] of the two Bezier curve segments.\n         *\n         */\n        meetBeziersegmentBeziersegment: function (red, blue, testSegment) {\n            var L, L2, i;\n\n            if (red.length === 4 && blue.length === 4) {\n                L = this._bezierMeetSubdivision(red, blue, 0);\n            } else {\n                L = this._bezierLineMeetSubdivision(red, blue, 0, testSegment);\n            }\n\n            L.sort(function (a, b) {\n                return (a[1] - b[1]) * 10000000.0 + (a[2] - b[2]);\n            });\n\n            L2 = [];\n            for (i = 0; i < L.length; i++) {\n                // Only push entries different from their predecessor\n                if (i === 0 || L[i][1] !== L[i - 1][1] || L[i][2] !== L[i - 1][2]) {\n                    L2.push(L[i]);\n                }\n            }\n            return L2;\n        },\n\n        /**\n         * Find the nr-th intersection point of two Bezier curves, i.e. curves with bezierDegree == 3.\n         * @param {JXG.Curve} red Curve with bezierDegree == 3\n         * @param {JXG.Curve} blue Curve with bezierDegree == 3\n         * @param {Number|Function} nr The number of the intersection point which should be returned.\n         * @returns {Array} The homogeneous coordinates of the nr-th intersection point.\n         */\n        meetBezierCurveRedBlueSegments: function (red, blue, nr) {\n            var p, i, j, k,\n                n = Type.evaluate(nr),\n                po, tmp,\n                redArr,\n                blueArr,\n                bbr,\n                bbb,\n                intersections,\n                startRed = 0,\n                startBlue = 0,\n                lenBlue, lenRed,\n                L = [];\n\n            if (blue.numberPoints < blue.bezierDegree + 1 || red.numberPoints < red.bezierDegree + 1) {\n                return [0, NaN, NaN];\n            }\n            if (red.bezierDegree === 1 && blue.bezierDegree === 3) {\n                tmp = red;\n                red = blue;\n                blue = tmp;\n            }\n\n            lenBlue = blue.numberPoints - blue.bezierDegree;\n            lenRed = red.numberPoints - red.bezierDegree;\n\n            // For sectors, we ignore the \"legs\"\n            if (red.type === Const.OBJECT_TYPE_SECTOR) {\n                startRed = 3;\n                lenRed -= 3;\n            }\n            if (blue.type === Const.OBJECT_TYPE_SECTOR) {\n                startBlue = 3;\n                lenBlue -= 3;\n            }\n\n            for (i = startRed; i < lenRed; i += red.bezierDegree) {\n                p = red.points;\n                redArr = [p[i].usrCoords.slice(1), p[i + 1].usrCoords.slice(1)];\n                if (red.bezierDegree === 3) {\n                    redArr[2] = p[i + 2].usrCoords.slice(1);\n                    redArr[3] = p[i + 3].usrCoords.slice(1);\n                }\n\n                bbr = this._bezierBbox(redArr);\n\n                for (j = startBlue; j < lenBlue; j += blue.bezierDegree) {\n                    p = blue.points;\n                    blueArr = [p[j].usrCoords.slice(1), p[j + 1].usrCoords.slice(1)];\n                    if (blue.bezierDegree === 3) {\n                        blueArr[2] = p[j + 2].usrCoords.slice(1);\n                        blueArr[3] = p[j + 3].usrCoords.slice(1);\n                    }\n\n                    bbb = this._bezierBbox(blueArr);\n                    if (this._bezierOverlap(bbr, bbb)) {\n                        intersections = this.meetBeziersegmentBeziersegment(redArr, blueArr);\n                        if (intersections.length === 0) {\n                            continue;\n                        }\n                        for (k = 0; k < intersections.length; k++) {\n                            po = intersections[k];\n                            if (\n                                po[1] < -Mat.eps ||\n                                po[1] > 1 + Mat.eps ||\n                                po[2] < -Mat.eps ||\n                                po[2] > 1 + Mat.eps\n                            ) {\n                                continue;\n                            }\n                            L.push(po);\n                        }\n                        if (L.length > n) {\n                            return L[n][0];\n                        }\n                    }\n                }\n            }\n            if (L.length > n) {\n                return L[n][0];\n            }\n\n            return [0, NaN, NaN];\n        },\n\n        bezierSegmentEval: function (t, curve) {\n            var f,\n                x,\n                y,\n                t1 = 1.0 - t;\n\n            x = 0;\n            y = 0;\n\n            f = t1 * t1 * t1;\n            x += f * curve[0][0];\n            y += f * curve[0][1];\n\n            f = 3.0 * t * t1 * t1;\n            x += f * curve[1][0];\n            y += f * curve[1][1];\n\n            f = 3.0 * t * t * t1;\n            x += f * curve[2][0];\n            y += f * curve[2][1];\n\n            f = t * t * t;\n            x += f * curve[3][0];\n            y += f * curve[3][1];\n\n            return [1.0, x, y];\n        },\n\n        /**\n         * Generate the defining points of a 3rd degree bezier curve that approximates\n         * a circle sector defined by three coordinate points A, B, C, each defined by an array of length three.\n         * The coordinate arrays are given in homogeneous coordinates.\n         * @param {Array} A First point\n         * @param {Array} B Second point (intersection point)\n         * @param {Array} C Third point\n         * @param {Boolean} withLegs Flag. If true the legs to the intersection point are part of the curve.\n         * @param {Number} sgn Wither 1 or -1. Needed for minor and major arcs. In case of doubt, use 1.\n         */\n        bezierArc: function (A, B, C, withLegs, sgn) {\n            var p1,\n                p2,\n                p3,\n                p4,\n                r,\n                phi,\n                beta,\n                PI2 = Math.PI * 0.5,\n                x = B[1],\n                y = B[2],\n                z = B[0],\n                dataX = [],\n                dataY = [],\n                co,\n                si,\n                ax,\n                ay,\n                bx,\n                by,\n                k,\n                v,\n                d,\n                matrix;\n\n            r = this.distance(B, A);\n\n            // x,y, z is intersection point. Normalize it.\n            x /= z;\n            y /= z;\n\n            phi = this.rad(A.slice(1), B.slice(1), C.slice(1));\n            if (sgn === -1) {\n                phi = 2 * Math.PI - phi;\n            }\n\n            p1 = A;\n            p1[1] /= p1[0];\n            p1[2] /= p1[0];\n            p1[0] /= p1[0];\n\n            p4 = p1.slice(0);\n\n            if (withLegs) {\n                dataX = [x, x + 0.333 * (p1[1] - x), x + 0.666 * (p1[1] - x), p1[1]];\n                dataY = [y, y + 0.333 * (p1[2] - y), y + 0.666 * (p1[2] - y), p1[2]];\n            } else {\n                dataX = [p1[1]];\n                dataY = [p1[2]];\n            }\n\n            while (phi > Mat.eps) {\n                if (phi > PI2) {\n                    beta = PI2;\n                    phi -= PI2;\n                } else {\n                    beta = phi;\n                    phi = 0;\n                }\n\n                co = Math.cos(sgn * beta);\n                si = Math.sin(sgn * beta);\n\n                matrix = [\n                    [1, 0, 0],\n                    [x * (1 - co) + y * si, co, -si],\n                    [y * (1 - co) - x * si, si, co]\n                ];\n                v = Mat.matVecMult(matrix, p1);\n                p4 = [v[0] / v[0], v[1] / v[0], v[2] / v[0]];\n\n                ax = p1[1] - x;\n                ay = p1[2] - y;\n                bx = p4[1] - x;\n                by = p4[2] - y;\n                d = Mat.hypot(ax + bx, ay + by);\n\n                if (Math.abs(by - ay) > Mat.eps) {\n                    k = ((((ax + bx) * (r / d - 0.5)) / (by - ay)) * 8) / 3;\n                } else {\n                    k = ((((ay + by) * (r / d - 0.5)) / (ax - bx)) * 8) / 3;\n                }\n\n                p2 = [1, p1[1] - k * ay, p1[2] + k * ax];\n                p3 = [1, p4[1] + k * by, p4[2] - k * bx];\n\n                dataX = dataX.concat([p2[1], p3[1], p4[1]]);\n                dataY = dataY.concat([p2[2], p3[2], p4[2]]);\n                p1 = p4.slice(0);\n            }\n\n            if (withLegs) {\n                dataX = dataX.concat([\n                    p4[1] + 0.333 * (x - p4[1]),\n                    p4[1] + 0.666 * (x - p4[1]),\n                    x\n                ]);\n                dataY = dataY.concat([\n                    p4[2] + 0.333 * (y - p4[2]),\n                    p4[2] + 0.666 * (y - p4[2]),\n                    y\n                ]);\n            }\n\n            return [dataX, dataY];\n        },\n\n        /****************************************/\n        /****           PROJECTIONS          ****/\n        /****************************************/\n\n        /**\n         * Calculates the coordinates of the projection of a given point on a given circle. I.o.w. the\n         * nearest one of the two intersection points of the line through the given point and the circles\n         * center.\n         * @param {JXG.Point|JXG.Coords} point Point to project or coords object to project.\n         * @param {JXG.Circle} circle Circle on that the point is projected.\n         * @param {JXG.Board} [board=point.board] Reference to the board\n         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.\n         */\n        projectPointToCircle: function (point, circle, board) {\n            var dist,\n                P,\n                x,\n                y,\n                factor,\n                M = circle.center.coords.usrCoords;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            // gave us a point\n            if (Type.isPoint(point)) {\n                dist = point.coords.distance(Const.COORDS_BY_USER, circle.center.coords);\n                P = point.coords.usrCoords;\n                // gave us coords\n            } else {\n                dist = point.distance(Const.COORDS_BY_USER, circle.center.coords);\n                P = point.usrCoords;\n            }\n\n            if (Math.abs(dist) < Mat.eps) {\n                dist = Mat.eps;\n            }\n\n            factor = circle.Radius() / dist;\n            x = M[1] + factor * (P[1] - M[1]);\n            y = M[2] + factor * (P[2] - M[2]);\n\n            return new Coords(Const.COORDS_BY_USER, [x, y], board);\n        },\n\n        /**\n         * Calculates the coordinates of the orthogonal projection of a given point on a given line. I.o.w. the\n         * intersection point of the given line and its perpendicular through the given point.\n         * @param {JXG.Point|JXG.Coords} point Point to project.\n         * @param {JXG.Line} line Line on that the point is projected.\n         * @param {JXG.Board} [board=point.board|board=line.board] Reference to a board.\n         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given line.\n         */\n        projectPointToLine: function (point, line, board) {\n            var v = [0, line.stdform[1], line.stdform[2]],\n                coords;\n\n            if (!Type.exists(board)) {\n                if (Type.exists(point.coords)) {\n                    board = point.board;\n                } else {\n                    board = line.board;\n                }\n            }\n\n            if (Type.exists(point.coords)) {\n                coords = point.coords.usrCoords;\n            } else {\n                coords = point.usrCoords;\n            }\n\n            v = Mat.crossProduct(v, coords);\n            return new Coords(Const.COORDS_BY_USER, Mat.crossProduct(v, line.stdform), board);\n        },\n\n        /**\n         * Calculates the coordinates of the orthogonal projection of a given coordinate array on a given line\n         * segment defined by two coordinate arrays.\n         * @param {Array} p Point to project.\n         * @param {Array} q1 Start point of the line segment on that the point is projected.\n         * @param {Array} q2 End point of the line segment on that the point is projected.\n         * @returns {Array} The coordinates of the projection of the given point on the given segment\n         * and the factor that determines the projected point as a convex combination of the\n         * two endpoints q1 and q2 of the segment.\n         */\n        projectCoordsToSegment: function (p, q1, q2) {\n            var t,\n                denom,\n                s = [q2[1] - q1[1], q2[2] - q1[2]],\n                v = [p[1] - q1[1], p[2] - q1[2]];\n\n            /**\n             * If the segment has length 0, i.e. is a point,\n             * the projection is equal to that point.\n             */\n            if (Math.abs(s[0]) < Mat.eps && Math.abs(s[1]) < Mat.eps) {\n                return [q1, 0];\n            }\n\n            t = Mat.innerProduct(v, s);\n            denom = Mat.innerProduct(s, s);\n            t /= denom;\n\n            return [[1, t * s[0] + q1[1], t * s[1] + q1[2]], t];\n        },\n\n        /**\n         * Finds the coordinates of the closest point on a Bezier segment of a\n         * {@link JXG.Curve} to a given coordinate array.\n         * @param {Array} pos Point to project in homogeneous coordinates.\n         * @param {JXG.Curve} curve Curve of type \"plot\" having Bezier degree 3.\n         * @param {Number} start Number of the Bezier segment of the curve.\n         * @returns {Array} The coordinates of the projection of the given point\n         * on the given Bezier segment and the preimage of the curve which\n         * determines the closest point.\n         */\n        projectCoordsToBeziersegment: function (pos, curve, start) {\n            var t0,\n                /** @ignore */\n                minfunc = function (t) {\n                    var z = [1, curve.X(start + t), curve.Y(start + t)];\n\n                    z[1] -= pos[1];\n                    z[2] -= pos[2];\n\n                    return z[1] * z[1] + z[2] * z[2];\n                };\n\n            t0 = JXG.Math.Numerics.fminbr(minfunc, [0.0, 1.0]);\n\n            return [[1, curve.X(t0 + start), curve.Y(t0 + start)], t0];\n        },\n\n        /**\n         * Calculates the coordinates of the projection of a given point on a given curve.\n         * Uses {@link JXG.Math.Geometry.projectCoordsToCurve}.\n         *\n         * @param {JXG.Point} point Point to project.\n         * @param {JXG.Curve} curve Curve on that the point is projected.\n         * @param {JXG.Board} [board=point.board] Reference to a board.\n         * @see #projectCoordsToCurve\n         * @returns {Array} [JXG.Coords, position] The coordinates of the projection of the given\n         * point on the given graph and the relative position on the curve (real number).\n         */\n        projectPointToCurve: function (point, curve, board) {\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            var x = point.X(),\n                y = point.Y(),\n                t = point.position || 0.0,\n                result = this.projectCoordsToCurve(x, y, t, curve, board);\n\n            // point.position = result[1];\n\n            return result;\n        },\n\n        /**\n         * Calculates the coordinates of the projection of a coordinates pair on a given curve. In case of\n         * function graphs this is the\n         * intersection point of the curve and the parallel to y-axis through the given point.\n         * @param {Number} x coordinate to project.\n         * @param {Number} y coordinate to project.\n         * @param {Number} t start value for newtons method\n         * @param {JXG.Curve} curve Curve on that the point is projected.\n         * @param {JXG.Board} [board=curve.board] Reference to a board.\n         * @see #projectPointToCurve\n         * @returns {JXG.Coords} Array containing the coordinates of the projection of the given point on the given curve and\n         * the position on the curve.\n         */\n        projectCoordsToCurve: function (x, y, t, curve, board) {\n            var newCoords, newCoordsObj,\n                i, j, mindist, dist, lbda,\n                v, coords, d, p1, p2, res, minfunc,\n                t_new, f_new, f_old,\n                delta, delta1, delta2, steps, minX, maxX,\n                infty = Number.POSITIVE_INFINITY;\n\n            if (!Type.exists(board)) {\n                board = curve.board;\n            }\n\n            if (Type.evaluate(curve.visProp.curvetype) === \"plot\") {\n                t = 0;\n                mindist = infty;\n                if (curve.numberPoints === 0) {\n                    newCoords = [0, 1, 1];\n                } else {\n                    newCoords = [curve.Z(0), curve.X(0), curve.Y(0)];\n                }\n\n                if (curve.numberPoints > 1) {\n                    v = [1, x, y];\n                    if (curve.bezierDegree === 3) {\n                        j = 0;\n                    } else {\n                        p1 = [curve.Z(0), curve.X(0), curve.Y(0)];\n                    }\n                    for (i = 0; i < curve.numberPoints - 1; i++) {\n                        if (curve.bezierDegree === 3) {\n                            res = this.projectCoordsToBeziersegment(v, curve, j);\n                        } else {\n                            p2 = [curve.Z(i + 1), curve.X(i + 1), curve.Y(i + 1)];\n                            res = this.projectCoordsToSegment(v, p1, p2);\n                        }\n                        lbda = res[1];\n                        coords = res[0];\n\n                        if (0.0 <= lbda && lbda <= 1.0) {\n                            dist = this.distance(coords, v);\n                            d = i + lbda;\n                        } else if (lbda < 0.0) {\n                            coords = p1;\n                            dist = this.distance(p1, v);\n                            d = i;\n                        } else if (lbda > 1.0 && i === curve.numberPoints - 2) {\n                            coords = p2;\n                            dist = this.distance(coords, v);\n                            d = curve.numberPoints - 1;\n                        }\n\n                        if (dist < mindist) {\n                            mindist = dist;\n                            t = d;\n                            newCoords = coords;\n                        }\n\n                        if (curve.bezierDegree === 3) {\n                            j++;\n                            i += 2;\n                        } else {\n                            p1 = p2;\n                        }\n                    }\n                }\n\n                newCoordsObj = new Coords(Const.COORDS_BY_USER, newCoords, board);\n            } else {\n                // 'parameter', 'polar', 'functiongraph'\n                /** @ignore */\n                minfunc = function (t) {\n                    var dx, dy;\n                    if (t < curve.minX() || t > curve.maxX()) {\n                        return Infinity;\n                    }\n                    dx = x - curve.X(t);\n                    dy = y - curve.Y(t);\n                    return dx * dx + dy * dy;\n                };\n\n                f_old = minfunc(t);\n                steps = 50;\n                minX = curve.minX();\n                maxX = curve.maxX();\n\n                delta = (maxX - minX) / steps;\n                t_new = minX;\n\n                for (i = 0; i < steps; i++) {\n                    f_new = minfunc(t_new);\n\n                    if (f_new < f_old || f_old === Infinity || isNaN(f_old)) {\n                        t = t_new;\n                        f_old = f_new;\n                    }\n\n                    t_new += delta;\n                }\n\n                // t = Numerics.root(Numerics.D(minfunc), t);\n                // Ensure that minfunc is defined on the\n                // enclsoing interval [t-delta1, t+delta2]\n                delta1 = delta;\n                for (i = 0;\n                    i < 20 && isNaN(minfunc(t - delta1));\n                    i++, delta1 *= 0.5);\n\n                if (isNaN(minfunc(t - delta1))) {\n                    delta1 = 0.0;\n                }\n                delta2 = delta;\n                for (i = 0;\n                    i < 20 && isNaN(minfunc(t + delta2));\n                    i++, delta2 *= 0.5);\n                if (isNaN(minfunc(t + delta2))) {\n                    delta2 = 0.0;\n                }\n\n                t = Numerics.fminbr(minfunc, [\n                    Math.max(t - delta1, minX),\n                    Math.min(t + delta2, maxX)\n                ]);\n\n                // Distinction between closed and open curves is not necessary.\n                // If closed, the cyclic projection shift will work anyhow\n                // if (Math.abs(curve.X(minX) - curve.X(maxX)) < Mat.eps &&\n                //     Math.abs(curve.Y(minX) - curve.Y(maxX)) < Mat.eps) {\n                //     // Cyclically\n                //     if (t < minX) {console.log(t)\n                //         t = maxX + t - minX;\n                //     }\n                //     if (t > maxX) {\n                //         t = minX + t - maxX;\n                //     }\n                // } else {\n                t = t < minX ? minX : t;\n                t = t > maxX ? maxX : t;\n                // }\n\n                newCoordsObj = new Coords(\n                    Const.COORDS_BY_USER,\n                    [curve.X(t), curve.Y(t)],\n                    board\n                );\n            }\n\n            return [curve.updateTransform(newCoordsObj), t];\n        },\n\n        /**\n         * Calculates the coordinates of the closest orthogonal projection of a given coordinate array onto the\n         * border of a polygon.\n         * @param {Array} p Point to project.\n         * @param {JXG.Polygon} pol Polygon element\n         * @returns {Array} The coordinates of the closest projection of the given point to the border of the polygon.\n         */\n        projectCoordsToPolygon: function (p, pol) {\n            var i,\n                len = pol.vertices.length,\n                d_best = Infinity,\n                d,\n                projection,\n                proj,\n                bestprojection;\n\n            for (i = 0; i < len - 1; i++) {\n                projection = JXG.Math.Geometry.projectCoordsToSegment(\n                    p,\n                    pol.vertices[i].coords.usrCoords,\n                    pol.vertices[i + 1].coords.usrCoords\n                );\n\n                if (0 <= projection[1] && projection[1] <= 1) {\n                    d = JXG.Math.Geometry.distance(projection[0], p, 3);\n                    proj = projection[0];\n                } else if (projection[1] < 0) {\n                    d = JXG.Math.Geometry.distance(pol.vertices[i].coords.usrCoords, p, 3);\n                    proj = pol.vertices[i].coords.usrCoords;\n                } else {\n                    d = JXG.Math.Geometry.distance(pol.vertices[i + 1].coords.usrCoords, p, 3);\n                    proj = pol.vertices[i + 1].coords.usrCoords;\n                }\n                if (d < d_best) {\n                    bestprojection = proj.slice(0);\n                    d_best = d;\n                }\n            }\n            return bestprojection;\n        },\n\n        /**\n         * Calculates the coordinates of the projection of a given point on a given turtle. A turtle consists of\n         * one or more curves of curveType 'plot'. Uses {@link JXG.Math.Geometry.projectPointToCurve}.\n         * @param {JXG.Point} point Point to project.\n         * @param {JXG.Turtle} turtle on that the point is projected.\n         * @param {JXG.Board} [board=point.board] Reference to a board.\n         * @returns {Array} [JXG.Coords, position] Array containing the coordinates of the projection of the given point on the turtle and\n         * the position on the turtle.\n         */\n        projectPointToTurtle: function (point, turtle, board) {\n            var newCoords,\n                t,\n                x,\n                y,\n                i,\n                dist,\n                el,\n                minEl,\n                res,\n                newPos,\n                np = 0,\n                npmin = 0,\n                mindist = Number.POSITIVE_INFINITY,\n                len = turtle.objects.length;\n\n            if (!Type.exists(board)) {\n                board = point.board;\n            }\n\n            // run through all curves of this turtle\n            for (i = 0; i < len; i++) {\n                el = turtle.objects[i];\n\n                if (el.elementClass === Const.OBJECT_CLASS_CURVE) {\n                    res = this.projectPointToCurve(point, el);\n                    newCoords = res[0];\n                    newPos = res[1];\n                    dist = this.distance(newCoords.usrCoords, point.coords.usrCoords);\n\n                    if (dist < mindist) {\n                        x = newCoords.usrCoords[1];\n                        y = newCoords.usrCoords[2];\n                        t = newPos;\n                        mindist = dist;\n                        minEl = el;\n                        npmin = np;\n                    }\n                    np += el.numberPoints;\n                }\n            }\n\n            newCoords = new Coords(Const.COORDS_BY_USER, [x, y], board);\n            // point.position = t + npmin;\n            // return minEl.updateTransform(newCoords);\n            return [minEl.updateTransform(newCoords), t + npmin];\n        },\n\n        /**\n         * Trivial projection of a point to another point.\n         * @param {JXG.Point} point Point to project (not used).\n         * @param {JXG.Point} dest Point on that the point is projected.\n         * @returns {JXG.Coords} The coordinates of the projection of the given point on the given circle.\n         */\n        projectPointToPoint: function (point, dest) {\n            return dest.coords;\n        },\n\n        /**\n         *\n         * @param {JXG.Point|JXG.Coords} point\n         * @param {JXG.Board} [board]\n         */\n        projectPointToBoard: function (point, board) {\n            var i,\n                l,\n                c,\n                brd = board || point.board,\n                // comparison factor, point coord idx, bbox idx, 1st bbox corner x & y idx, 2nd bbox corner x & y idx\n                config = [\n                    // left\n                    [1, 1, 0, 0, 3, 0, 1],\n                    // top\n                    [-1, 2, 1, 0, 1, 2, 1],\n                    // right\n                    [-1, 1, 2, 2, 1, 2, 3],\n                    // bottom\n                    [1, 2, 3, 0, 3, 2, 3]\n                ],\n                coords = point.coords || point,\n                bbox = brd.getBoundingBox();\n\n            for (i = 0; i < 4; i++) {\n                c = config[i];\n                if (c[0] * coords.usrCoords[c[1]] < c[0] * bbox[c[2]]) {\n                    // define border\n                    l = Mat.crossProduct(\n                        [1, bbox[c[3]], bbox[c[4]]],\n                        [1, bbox[c[5]], bbox[c[6]]]\n                    );\n                    l[3] = 0;\n                    l = Mat.normalize(l);\n\n                    // project point\n                    coords = this.projectPointToLine({ coords: coords }, { stdform: l }, brd);\n                }\n            }\n\n            return coords;\n        },\n\n        /**\n         * Calculates the distance of a point to a line. The point and the line are given by homogeneous\n         * coordinates. For lines this can be line.stdform.\n         * @param {Array} point Homogeneous coordinates of a point.\n         * @param {Array} line Homogeneous coordinates of a line ([C,A,B] where A*x+B*y+C*z=0).\n         * @returns {Number} Distance of the point to the line.\n         */\n        distPointLine: function (point, line) {\n            var a = line[1],\n                b = line[2],\n                c = line[0],\n                nom;\n\n            if (Math.abs(a) + Math.abs(b) < Mat.eps) {\n                return Number.POSITIVE_INFINITY;\n            }\n\n            nom = a * point[1] + b * point[2] + c;\n            a *= a;\n            b *= b;\n\n            return Math.abs(nom) / Math.sqrt(a + b);\n        },\n\n        /**\n         * Determine the (Euclidean) distance between a point q and a line segment\n         * defined by two points p1 and p2. In case p1 equals p2, the distance to this\n         * point is returned.\n         *\n         * @param {Array} q Homogeneous coordinates of q\n         * @param {Array} p1 Homogeneous coordinates of p1\n         * @param {Array} p2 Homogeneous coordinates of p2\n         * @returns {Number} Distance of q to line segment [p1, p2]\n         */\n        distPointSegment: function (q, p1, p2) {\n            var x, y, dx, dy,\n                den, lbda,\n                eps = Mat.eps * Mat.eps,\n                huge = 1000000;\n\n            // Difference q - p1\n            x = q[1] - p1[1];\n            y = q[2] - p1[2];\n            x = (x === Infinity) ? huge : (x === -Infinity) ? -huge : x;\n            y = (y === Infinity) ? huge : (y === -Infinity) ? -huge : y;\n\n            // Difference p2 - p1\n            dx = p2[1] - p1[1];\n            dy = p2[2] - p1[2];\n            dx = (dx === Infinity) ? huge : (dx === -Infinity) ? -huge : dx;\n            dy = (dy === Infinity) ? huge : (dy === -Infinity) ? -huge : dy;\n\n            // If den==0 then p1 and p2 are identical\n            // In this case the distance to p1 is returned\n            den = dx * dx + dy * dy;\n            if (den > eps) {\n                lbda = (x * dx + y * dy) / den;\n                if (lbda < 0.0) {\n                    lbda = 0.0;\n                } else if (lbda > 1.0) {\n                    lbda = 1.0;\n                }\n                x -= lbda * dx;\n                y -= lbda * dy;\n            }\n\n            return Mat.hypot(x, y);\n        },\n\n        /**\n         * Helper function to create curve which displays a Reuleaux polygons.\n         * @param {Array} points Array of points which should be the vertices of the Reuleaux polygon. Typically,\n         * these point list is the array vertices of a regular polygon.\n         * @param {Number} nr Number of vertices\n         * @returns {Array} An array containing the two functions defining the Reuleaux polygon and the two values\n         * for the start and the end of the paramtric curve. array may be used as parent array of a\n         * {@link JXG.Curve}.\n         *\n         * @example\n         * var A = brd.create('point',[-2,-2]);\n         * var B = brd.create('point',[0,1]);\n         * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});\n         * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),\n         *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});\n         *\n         * </pre><div class=\"jxgbox\" id=\"JXG2543a843-46a9-4372-abc1-94d9ad2db7ac\" style=\"width: 300px; height: 300px;\"></div>\n         * <script type=\"text/javascript\">\n         * var brd = JXG.JSXGraph.initBoard('JXG2543a843-46a9-4372-abc1-94d9ad2db7ac', {boundingbox: [-5, 5, 5, -5], axis: true, showcopyright:false, shownavigation: false});\n         * var A = brd.create('point',[-2,-2]);\n         * var B = brd.create('point',[0,1]);\n         * var pol = brd.create('regularpolygon',[A,B,3], {withLines:false, fillColor:'none', highlightFillColor:'none', fillOpacity:0.0});\n         * var reuleauxTriangle = brd.create('curve', JXG.Math.Geometry.reuleauxPolygon(pol.vertices, 3),\n         *                          {strokeWidth:6, strokeColor:'#d66d55', fillColor:'#ad5544', highlightFillColor:'#ad5544'});\n         * </script><pre>\n         */\n        reuleauxPolygon: function (points, nr) {\n            var beta,\n                pi2 = Math.PI * 2,\n                pi2_n = pi2 / nr,\n                diag = (nr - 1) / 2,\n                d = 0,\n                makeFct = function (which, trig) {\n                    return function (t, suspendUpdate) {\n                        var t1 = ((t % pi2) + pi2) % pi2,\n                            j = Math.floor(t1 / pi2_n) % nr;\n\n                        if (!suspendUpdate) {\n                            d = points[0].Dist(points[diag]);\n                            beta = Mat.Geometry.rad(\n                                [points[0].X() + 1, points[0].Y()],\n                                points[0],\n                                points[diag % nr]\n                            );\n                        }\n\n                        if (isNaN(j)) {\n                            return j;\n                        }\n\n                        t1 = t1 * 0.5 + j * pi2_n * 0.5 + beta;\n\n                        return points[j][which]() + d * Math[trig](t1);\n                    };\n                };\n\n            return [makeFct(\"X\", \"cos\"), makeFct(\"Y\", \"sin\"), 0, pi2];\n        },\n\n        meet3Planes: function (n1, d1, n2, d2, n3, d3) {\n            var p = [0, 0, 0],\n                n31,\n                n12,\n                n23,\n                denom,\n                i;\n\n            n31 = Mat.crossProduct(n3, n1);\n            n12 = Mat.crossProduct(n1, n2);\n            n23 = Mat.crossProduct(n2, n3);\n            denom = Mat.innerProduct(n1, n23, 3);\n            for (i = 0; i < 3; i++) {\n                p[i] = (d1 * n23[i] + d2 * n31[i] + d3 * n12[i]) / denom;\n            }\n            return p;\n        },\n\n        meetPlanePlane: function (v11, v12, v21, v22) {\n            var i,\n                no1,\n                no2,\n                v = [0, 0, 0],\n                w = [0, 0, 0];\n\n            for (i = 0; i < 3; i++) {\n                v[i] = Type.evaluate(v11[i]);\n                w[i] = Type.evaluate(v12[i]);\n            }\n            no1 = Mat.crossProduct(v, w);\n\n            for (i = 0; i < 3; i++) {\n                v[i] = Type.evaluate(v21[i]);\n                w[i] = Type.evaluate(v22[i]);\n            }\n            no2 = Mat.crossProduct(v, w);\n\n            return Mat.crossProduct(no1, no2);\n        },\n\n        project3DTo3DPlane: function (point, normal, foot) {\n            // TODO: homogeneous 3D coordinates\n            var sol = [0, 0, 0],\n                le,\n                d1,\n                d2,\n                lbda;\n\n            foot = foot || [0, 0, 0];\n\n            le = Mat.norm(normal);\n            d1 = Mat.innerProduct(point, normal, 3);\n            d2 = Mat.innerProduct(foot, normal, 3);\n            // (point - lbda * normal / le) * normal / le == foot * normal / le\n            // => (point * normal - foot * normal) ==  lbda * le\n            lbda = (d1 - d2) / le;\n            sol = Mat.axpy(-lbda, normal, point);\n\n            return sol;\n        },\n\n        getPlaneBounds: function (v1, v2, q, s, e) {\n            var s1, s2, e1, e2, mat, rhs, sol;\n\n            if (v1[2] + v2[0] !== 0) {\n                mat = [\n                    [v1[0], v2[0]],\n                    [v1[1], v2[1]]\n                ];\n                rhs = [s - q[0], s - q[1]];\n\n                sol = Numerics.Gauss(mat, rhs);\n                s1 = sol[0];\n                s2 = sol[1];\n\n                rhs = [e - q[0], e - q[1]];\n                sol = Numerics.Gauss(mat, rhs);\n                e1 = sol[0];\n                e2 = sol[1];\n                return [s1, e1, s2, e2];\n            }\n            return null;\n        }\n    }\n);\n\nexport default Mat.Geometry;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}