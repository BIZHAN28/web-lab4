{"ast":null,"code":"/*\n JessieCode Computer algebra algorithms\n\n    Copyright 2011-2019\n        Michael Gerhaeuser,\n        Alfred Wassermann\n\n    JessieCode is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JessieCode is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JessieCode. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true, console: true, self: true, document: true, parser: true*/\n/*jslint nomen: true, plusplus: true*/\n/*eslint eqeqeq: \"off\"*/\n\n/**\n * @fileoverview Here, the computer algebra algorithms are implemented.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n// import Const from \"../base/constants\";\n// import Text from \"../base/text\";\n// import Mat from \"../math/math\";\n// import Geometry from \"../math/geometry\";\n// import Statistics from \"../math/statistics\";\n// import Env from \"../utils/env\";\n\n/**\n * A JessieCode object provides an interface to the parser and stores all variables and objects used within a JessieCode script.\n * The optional argument <tt>code</tt> is interpreted after initializing. To evaluate more code after initializing a JessieCode instance\n * please use {@link JXG.JessieCode#parse}. For code snippets like single expressions use {@link JXG.JessieCode#snippet}.\n * @constructor\n * @param {String} [code] Code to parse.\n * @param {Boolean} [geonext=false] Geonext compatibility mode.\n */\nJXG.CA = function (node, createNode, parser) {\n  this.node = node;\n  this.createNode = createNode;\n  this.parser = parser;\n};\nJXG.extend(JXG.CA.prototype, /** @lends JXG.CA.prototype */{\n  findMapNode: function (mapname, node) {\n    var i, len, ret;\n\n    //console.log(\"FINDMAP\", node);\n    if (node.value === \"op_assign\" && node.children[0].value === mapname) {\n      return node.children[1];\n    } else if (node.children) {\n      len = node.children.length;\n      for (i = 0; i < len; ++i) {\n        ret = this.findMapNode(mapname, node.children[i]);\n        if (ret !== null) {\n          return ret;\n        }\n      }\n    }\n    return null;\n  },\n  /**\n   * Declare all subnodes as math nodes,\n   * i.e recursively set node.isMath = true;\n   */\n  setMath: function (node) {\n    var i, len;\n    if (node.type == \"node_op\" && (node.value == \"op_add\" || node.value == \"op_sub\" || node.value == \"op_mul\" || node.value == \"op_div\" || node.value == \"op_neg\" || node.value == \"op_execfun\" || node.value == \"op_exp\") || node.type == \"node_var\" || node.type == \"node_const\") {\n      node.isMath = true;\n    }\n    if (node.children) {\n      len = node.children.length;\n      for (i = 0; i < len; ++i) {\n        this.setMath(node.children[i]);\n      }\n    }\n  },\n  deriveElementary: function (node, varname) {\n    var fun = node.children[0].value,\n      arg = node.children[1],\n      newNode;\n    switch (fun) {\n      case \"abs\":\n        // x / sqrt(x * x)\n        newNode = this.createNode(\"node_op\", \"op_div\", arg[0], this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sqrt\"), [this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0]))]));\n        break;\n      case \"sqrt\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_mul\", this.createNode(\"node_const\", 2.0), this.createNode(node.type, node.value, Type.deepCopy(node.children[0]), Type.deepCopy(node.children[1]))));\n        break;\n      case \"sin\":\n        newNode = this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"cos\"), Type.deepCopy(arg));\n        break;\n      case \"cos\":\n        newNode = this.createNode(\"node_op\", \"op_neg\", this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sin\"), Type.deepCopy(arg)));\n        break;\n      case \"tan\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_exp\", this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"cos\"), Type.deepCopy(arg)), this.createNode(\"node_const\", 2)));\n        break;\n      case \"cot\":\n        newNode = this.createNode(\"node_op\", \"op_neg\", this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_exp\", this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sin\"), Type.deepCopy(arg)), this.createNode(\"node_const\", 2))));\n        break;\n      case \"exp\":\n        newNode = this.createNode(node.type, node.value, Type.deepCopy(node.children[0]), Type.deepCopy(node.children[1]));\n        break;\n      case \"pow\":\n        // (f^g)' = f^g*(f'g/f + g' log(f))\n        newNode = this.createNode(\"node_op\", \"op_mul\", this.createNode(\"node_op\", \"op_execfun\", Type.deepCopy(node.children[0]), Type.deepCopy(node.children[1])), this.createNode(\"node_op\", \"op_add\", this.createNode(\"node_op\", \"op_mul\", this.derivative(node.children[1][0], varname), this.createNode(\"node_op\", \"op_div\", Type.deepCopy(node.children[1][1]), Type.deepCopy(node.children[1][0]))), this.createNode(\"node_op\", \"op_mul\", this.derivative(node.children[1][1], varname), this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"log\"), [Type.deepCopy(node.children[1][0])]))));\n        break;\n      case \"log\":\n      case \"ln\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0),\n        // Attention: single variable mode\n        Type.deepCopy(arg[0]));\n        break;\n      case \"log2\":\n      case \"lb\":\n      case \"ld\":\n        newNode = this.createNode(\"node_op\", \"op_mul\", this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0),\n        // Attention: single variable mode\n        Type.deepCopy(arg[0])), this.createNode(\"node_const\", 1.4426950408889634) // 1/log(2)\n        );\n        break;\n      case \"log10\":\n      case \"lg\":\n        newNode = this.createNode(\"node_op\", \"op_mul\", this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0),\n        // Attention: single variable mode\n        Type.deepCopy(arg[0])), this.createNode(\"node_const\", 0.43429448190325176) // 1/log(10)\n        );\n        break;\n      case \"asin\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sqrt\"), [this.createNode(\"node_op\", \"op_sub\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0])))]));\n        break;\n      case \"acos\":\n        newNode = this.createNode(\"node_op\", \"op_neg\", this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sqrt\"), [this.createNode(\"node_op\", \"op_sub\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0])))])));\n        break;\n\n      //case 'atan2':\n\n      case \"atan\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_add\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0]))));\n        break;\n      case \"acot\":\n        newNode = this.createNode(\"node_op\", \"op_neg\", this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_add\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0])))));\n        break;\n      case \"sinh\":\n        newNode = this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"cosh\"), [Type.deepCopy(arg[0])]);\n        break;\n      case \"cosh\":\n        newNode = this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sinh\"), [Type.deepCopy(arg[0])]);\n        break;\n      case \"tanh\":\n        newNode = this.createNode(\"node_op\", \"op_sub\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_exp\", this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"tanh\"), [Type.deepCopy(arg[0])]), this.createNode(\"node_const\", 2.0)));\n        break;\n      case \"asinh\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sqrt\"), [this.createNode(\"node_op\", \"op_add\", this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0])), this.createNode(\"node_const\", 1.0))]));\n        break;\n      case \"acosh\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"sqrt\"), [this.createNode(\"node_op\", \"op_sub\", this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0])), this.createNode(\"node_const\", 1.0))]));\n        break;\n      case \"atanh\":\n        newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_sub\", this.createNode(\"node_const\", 1.0), this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(arg[0]), Type.deepCopy(arg[0]))));\n        break;\n      default:\n        newNode = this.createNode(\"node_const\", 0.0);\n        console.log('Derivative of \"' + fun + '\" not yet implemented');\n        throw new Error(\"Error(\" + this.line + \"): \");\n      //  this._error('Derivative of \"' + fun + '\" not yet implemented');\n    }\n    return newNode;\n  },\n  derivative: function (node, varname) {\n    var newNode;\n    switch (node.type) {\n      case \"node_op\":\n        switch (node.value) {\n          /*\n          case 'op_map':\n              if (true) {\n                  newNode = this.createNode('node_op', 'op_map',\n                          Type.deepCopy(node.children[0]),\n                          this.derivative(node.children[1], varname)\n                      );\n              } else {\n                  newNode = this.derivative(node.children[1], varname);\n              }\n              break;\n          */\n          case \"op_execfun\":\n            // f'(g(x))g'(x)\n            if (node.children[0].value == \"pow\") {\n              newNode = this.deriveElementary(node, varname);\n            } else {\n              if (node.children[1].length === 0) {\n                newNode = this.createNode(\"node_const\", 0.0);\n              } else {\n                newNode = this.createNode(\"node_op\", \"op_mul\", this.deriveElementary(node, varname),\n                // Warning: single variable mode\n                this.derivative(node.children[1][0], varname));\n              }\n            }\n            break;\n          case \"op_div\":\n            // (f'g − g'f )/(g*g)\n            newNode = this.createNode(\"node_op\", \"op_div\", this.createNode(\"node_op\", \"op_sub\", this.createNode(\"node_op\", \"op_mul\", this.derivative(node.children[0], varname), Type.deepCopy(node.children[1])), this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(node.children[0]), this.derivative(node.children[1], varname))), this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(node.children[1]), Type.deepCopy(node.children[1])));\n            break;\n          case \"op_mul\":\n            // fg' + f'g\n            newNode = this.createNode(\"node_op\", \"op_add\", this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(node.children[0]), this.derivative(node.children[1], varname)), this.createNode(\"node_op\", \"op_mul\", this.derivative(node.children[0], varname), Type.deepCopy(node.children[1])));\n            break;\n          case \"op_neg\":\n            newNode = this.createNode(\"node_op\", \"op_neg\", this.derivative(node.children[0], varname));\n            break;\n          case \"op_add\":\n          case \"op_sub\":\n            newNode = this.createNode(\"node_op\", node.value, this.derivative(node.children[0], varname), this.derivative(node.children[1], varname));\n            break;\n          case \"op_exp\":\n            // (f^g)' = f^g*(f'g/f + g' log(f))\n            newNode = this.createNode(\"node_op\", \"op_mul\", Type.deepCopy(node), this.createNode(\"node_op\", \"op_add\", this.createNode(\"node_op\", \"op_mul\", this.derivative(node.children[0], varname), this.createNode(\"node_op\", \"op_div\", Type.deepCopy(node.children[1]), Type.deepCopy(node.children[0]))), this.createNode(\"node_op\", \"op_mul\", this.derivative(node.children[1], varname), this.createNode(\"node_op\", \"op_execfun\", this.createNode(\"node_var\", \"log\"), [Type.deepCopy(node.children[0])]))));\n            break;\n        }\n        break;\n      case \"node_var\":\n        //console.log('node_var', node);\n        if (node.value === varname) {\n          newNode = this.createNode(\"node_const\", 1.0);\n        } else {\n          newNode = this.createNode(\"node_const\", 0.0);\n        }\n        break;\n      case \"node_const\":\n        newNode = this.createNode(\"node_const\", 0.0);\n        break;\n      case \"node_const_bool\":\n        break;\n      case \"node_str\":\n        break;\n    }\n    return newNode;\n  },\n  /**\n   * f = map (x) -> x*sin(x);\n   * Usages:\n   *   h = D(f, x);\n   *   h = map (x) -> D(f, x);\n   * or\n   *   D(x^2, x);\n   */\n  expandDerivatives: function (node, parent, ast) {\n    var len, i, j, mapNode, codeNode, ret, node2, newNode, mapName, varname, vArray, order, isMap;\n    ret = 0;\n    if (!node) {\n      return ret;\n    }\n    this.line = node.line;\n    this.col = node.col;\n\n    // First we have to go down in the tree.\n    // This ensures that in cases like D(D(f,x),x) the inner D is expanded first.\n    len = node.children.length;\n    for (i = 0; i < len; ++i) {\n      if (node.children[i] && node.children[i].type) {\n        node.children[i] = this.expandDerivatives(node.children[i], node, ast);\n      } else if (Type.isArray(node.children[i])) {\n        for (j = 0; j < node.children[i].length; ++j) {\n          if (node.children[i][j] && node.children[i][j].type) {\n            node.children[i][j] = this.expandDerivatives(node.children[i][j], node, ast);\n          }\n        }\n      }\n    }\n    switch (node.type) {\n      case \"node_op\":\n        switch (node.value) {\n          case \"op_execfun\":\n            if (node.children[0] && node.children[0].value === \"D\") {\n              /*\n               * Distinguish the cases:\n               *   D(f, x) where f is map -> isMap = true\n               * and\n               *   D(2*x, x), D(sin(x), x), ...  -> isMap = false\n               */\n              isMap = false;\n              if (node.children[1][0].type == \"node_var\") {\n                mapName = node.children[1][0].value;\n                mapNode = this.findMapNode(mapName, ast);\n                if (mapNode !== null) {\n                  isMap = true;\n                }\n              }\n              if (isMap) {\n                /*\n                 * Derivative of map, that is compute D(f,x)\n                 * where e.g. f = map (x) -> x^2\n                 *\n                 * First step: find node where the map is defined\n                 */\n                // Already done above\n                // mapName = node.children[1][0].value;\n                // mapNode = this.findMapNode(mapName, ast);\n                vArray = mapNode.children[0];\n\n                // Variable name for differentiation\n                if (node.children[1].length >= 2) {\n                  varname = node.children[1][1].value;\n                } else {\n                  varname = mapNode.children[0][0]; // Usually it's 'x'\n                }\n                codeNode = mapNode.children[1];\n              } else {\n                /*\n                 * Derivative of expression, e.g.\n                 *     D(2*x, x) or D(sin(x), x)\n                 */\n                codeNode = node.children[1][0];\n                vArray = [\"x\"];\n\n                // Variable name for differentiation and order\n                if (node.children[1].length >= 2) {\n                  varname = node.children[1][1].value;\n                } else {\n                  varname = \"x\";\n                }\n              }\n\n              // Differentiation order\n              if (node.children[1].length >= 3) {\n                order = node.children[1][2].value;\n              } else {\n                order = 1;\n              }\n\n              // Create node which contains the derivative\n              newNode = codeNode;\n              //newNode = this.removeTrivialNodes(newNode);\n              if (order >= 1) {\n                while (order >= 1) {\n                  newNode = this.derivative(newNode, varname);\n                  newNode = this.removeTrivialNodes(newNode);\n                  order--;\n                }\n              }\n\n              // Replace the node containing e.g. D(f,x) by the derivative.\n              if (parent.type == \"node_op\" && parent.value == \"op_assign\") {\n                // If D is an assignment it has to be replaced by a map\n                // h = D(f, x)\n                node2 = this.createNode(\"node_op\", \"op_map\", vArray, newNode);\n              } else {\n                node2 = newNode;\n              }\n              this.setMath(node2);\n              node.type = node2.type;\n              node.value = node2.value;\n              if (node2.children.length > 0) {\n                node.children[0] = node2.children[0];\n              }\n              if (node2.children.length > 1) {\n                node.children[1] = node2.children[1];\n              }\n            }\n        }\n        break;\n      case \"node_var\":\n      case \"node_const\":\n      case \"node_const_bool\":\n      case \"node_str\":\n        break;\n    }\n    return node;\n  },\n  removeTrivialNodes: function (node) {\n    var i, len, n0, n1, swap;\n\n    // In case of 'op_execfun' the children[1] node is an array.\n    if (Type.isArray(node)) {\n      len = node.length;\n      for (i = 0; i < len; ++i) {\n        node[i] = this.removeTrivialNodes(node[i]);\n      }\n    }\n    if (node.type != \"node_op\" || !node.children) {\n      return node;\n    }\n    len = node.children.length;\n    for (i = 0; i < len; ++i) {\n      this.mayNotBeSimplified = false;\n      do {\n        node.children[i] = this.removeTrivialNodes(node.children[i]);\n      } while (this.mayNotBeSimplified);\n    }\n    switch (node.value) {\n      // Allow maps of the form\n      //  map (x) -> x;\n      case \"op_map\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n1.type == \"node_var\") {\n          for (i = 0; i < n0.length; ++i) {\n            // Allow maps of the form map(x) -> x\n            if (n0[i] == n1.value) {\n              n1.isMath = true;\n              break;\n            }\n          }\n        }\n        break;\n\n      // a + 0 -> a\n      // 0 + a -> a\n      case \"op_add\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n0.type == \"node_const\" && n0.value === 0.0) {\n          return n1;\n        }\n        if (n1.type == \"node_const\" && n1.value === 0.0) {\n          return n0;\n        }\n\n        // const + const -> const\n        if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n          n0.value += n1.value;\n          return n0;\n        }\n        break;\n\n      // 1 * a = a\n      // a * 1 = a\n      // a * 0 = 0\n      // 0 * a = 0\n      // - * - = +\n      // Order children\n      case \"op_mul\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n0.type == \"node_const\" && n0.value == 1.0) {\n          return n1;\n        }\n        if (n1.type == \"node_const\" && n1.value == 1.0) {\n          return n0;\n        }\n        if (n0.type == \"node_const\" && n0.value === 0.0) {\n          return n0;\n        }\n        if (n1.type == \"node_const\" && n1.value === 0.0) {\n          return n1;\n        }\n        if (n1.type == \"node_const\" && n1.value === 0.0) {\n          return n1;\n        }\n\n        // (-a) * (-b) -> a*b\n        if (n0.type == \"node_op\" && n0.value == \"op_neg\" && n1.type == \"node_op\" && n1.value == \"op_neg\") {\n          node.children = [n0.children[0], n1.children[0]];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // (-a) * b -> -(a*b)\n        if (n0.value == \"op_neg\" && n1.value != \"op_neg\") {\n          node.type = \"node_op\";\n          node.value = \"op_neg\";\n          node.children = [this.createNode(\"node_op\", \"op_mul\", n0.children[0], n1)];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // a * (-b) -> -(a*b)\n        if (n0.value != \"op_neg\" && n1.value == \"op_neg\") {\n          node.type = \"node_op\";\n          node.value = \"op_neg\";\n          node.children = [this.createNode(\"node_op\", \"op_mul\", n0, n1.children[0])];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // (1 / a) * b -> a / b\n        if (n0.value == \"op_div\" && n0.children[0].type == \"node_const\" && n0.children[0].value == 1.0) {\n          node.type = \"node_op\";\n          node.value = \"op_div\";\n          node.children = [n1, n0.children[1]];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // a * (1 / b) -> a / b\n        if (n1.value == \"op_div\" && n1.children[0].type == \"node_const\" && n1.children[0].value == 1.0) {\n          node.type = \"node_op\";\n          node.value = \"op_div\";\n          node.children = [n0, n1.children[1]];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // Order children\n        // a * const -> const * a\n        if (n0.type != \"node_const\" && n1.type == \"node_const\") {\n          node.children = [n1, n0];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // a + (-const) -> -const + a\n        if (n0.type != \"node_const\" && n1.type == \"node_op\" && n1.value == \"op_neg\" && n1.children[0].type == \"node_const\") {\n          node.children = [n1, n0];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // a * var -> var * a\n        // a * fun -> fun * a\n        if (n0.type == \"node_op\" && n0.value != \"op_execfun\" && (n1.type == \"node_var\" || n1.type == \"node_op\" && n1.value == \"op_execfun\")) {\n          node.children = [n1, n0];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // a + (-var) -> -var  + a\n        if (n0.type != \"node_op\" && n1.type == \"node_op\" && n1.value == \"op_neg\" && n1.children[0].type == \"node_var\") {\n          node.children = [n1, n0];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // a * (const * b) -> const * (a*b)\n        // a * (const / b) -> const * (a/b)\n        if (n0.type != \"node_const\" && n1.type == \"node_op\" && (n1.value == \"op_mul\" || n1.value == \"op_div\") && n1.children[0].type == \"node_const\") {\n          swap = n1.children[0];\n          n1.children[0] = n0;\n          node.children = [swap, n1];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // (const * a) * b -> const * (a * b)\n        if (n1.type != \"node_const\" && n0.type == \"node_op\" && n0.value == \"op_mul\" && n0.children[0].type == \"node_const\") {\n          node.children = [n0.children[0], this.createNode(\"node_op\", \"op_mul\", n0.children[1], n1)];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // const * const -> const\n        if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n          n0.value *= n1.value;\n          return n0;\n        }\n\n        // const * (const * a) -> const * a\n        // const * (const / a) -> const / a\n        if (n0.type == \"node_const\" && n1.type == \"node_op\" && (n1.value == \"op_mul\" || n1.value == \"op_div\") && n1.children[0].type == \"node_const\") {\n          n1.children[0].value *= n0.value;\n          return n1;\n        }\n\n        // a * a-> a^2\n        n0.hash = this.parser.compile(n0);\n        n1.hash = this.parser.compile(n1);\n        if (n0.hash === n1.hash) {\n          node.value = \"op_exp\";\n          node.children[1] = this.createNode(\"node_const\", 2.0);\n          return node;\n        }\n        if (n0.type == \"node_const\" && n1.type == \"node_op\" && (n1.value == \"op_mul\" || n1.value == \"op_div\") && n1.children[0].type == \"node_const\") {\n          n1.children[0].value *= n0.value;\n          return n1;\n        }\n\n        // a * a^b -> a^(b+1)\n        if (n1.type == \"node_op\" && n1.value == \"op_exp\") {\n          if (!n0.hash) {\n            n0.hash = this.parser.compile(n0);\n          }\n          if (!n1.children[0].hash) {\n            n1.children[0].hash = this.parser.compile(n1.children[0]);\n          }\n          if (n0.hash === n1.children[0].hash) {\n            n1.children[1] = this.createNode(\"node_op\", \"op_add\", n1.children[1], this.createNode(\"node_const\", 1.0));\n            this.mayNotBeSimplified = true;\n            return n1;\n          }\n        }\n\n        // a^b * a^c -> a^(b+c)\n        if (n0.type == \"node_op\" && n0.value == \"op_exp\" && n1.type == \"node_op\" && n1.value == \"op_exp\") {\n          n0.children[0].hash = this.parser.compile(n0.children[0]);\n          n1.children[0].hash = this.parser.compile(n1.children[0]);\n          if (n0.children[0].hash === n1.children[0].hash) {\n            n0.children[1] = this.createNode(\"node_op\", \"op_add\", n0.children[1], n1.children[1]);\n            this.mayNotBeSimplified = true;\n            return n0;\n          }\n        }\n        break;\n\n      // 0 - a -> -a\n      // a - 0 -> a\n      // a - a -> 0\n      case \"op_sub\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n0.type == \"node_const\" && n0.value === 0.0) {\n          node.value = \"op_neg\";\n          node.children[0] = n1;\n          return node;\n        }\n        if (n1.type == \"node_const\" && n1.value === 0.0) {\n          return n0;\n        }\n        if (n0.type == \"node_const\" && n1.type == \"node_const\" && n0.value == n1.value) {\n          return this.createNode(\"node_const\", 0.0);\n        }\n        if (n0.type == \"node_var\" && n1.type == \"node_var\" && n0.value == n1.value) {\n          return this.createNode(\"node_const\", 0.0);\n        }\n\n        // const - const -> const\n        if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n          n0.value -= n1.value;\n          return n0;\n        }\n\n        // const * a - const * a -> const * a\n        if (n0.type == \"node_op\" && n0.value == \"op_mul\" && n1.type == \"node_op\" && n1.value == \"op_mul\") {\n          n0.children[1].hash = this.parser.compile(n0.children[1]);\n          n1.children[1].hash = this.parser.compile(n1.children[1]);\n          if (n0.children[1].hash === n1.children[1].hash) {\n            node.value = \"op_mul\";\n            node.children = [this.createNode(\"node_op\", \"op_sub\", n0.children[0], n1.children[0]), n0.children[1]];\n            this.mayNotBeSimplified = true;\n            return node;\n          }\n        }\n        // const * a - a -> (const - 1) * a\n        if (n0.type == \"node_op\" && n0.value == \"op_mul\") {\n          n0.children[1].hash = this.parser.compile(n0.children[1]);\n          n1.hash = this.parser.compile(n1);\n          if (n0.children[1].hash === n1.hash) {\n            node.value = \"op_mul\";\n            node.children = [this.createNode(\"node_op\", \"op_sub\", n0.children[0], this.createNode(\"node_const\", 1.0)), n1];\n            this.mayNotBeSimplified = true;\n            return node;\n          }\n        }\n        // a - const*a -> (const - 1) * a\n        if (n1.type == \"node_op\" && n1.value == \"op_mul\") {\n          n1.children[1].hash = this.parser.compile(n1.children[1]);\n          n0.hash = this.parser.compile(n0);\n          if (n1.children[1].hash === n0.hash) {\n            node.value = \"op_mul\";\n            node.children = [this.createNode(\"node_op\", \"op_sub\", this.createNode(\"node_const\", 1.0), n1.children[0]), n0];\n            this.mayNotBeSimplified = true;\n            return node;\n          }\n        }\n        break;\n\n      // -0 -> 0\n      // -(-b) = b\n      case \"op_neg\":\n        n0 = node.children[0];\n        if (n0.type == \"node_const\" && n0.value === 0.0) {\n          return n0;\n        }\n        if (n0.type == \"node_op\" && n0.value == \"op_neg\") {\n          return n0.children[0];\n        }\n        break;\n\n      // a / a -> 1, a != 0\n      // 0 / a -> 0, a != 0\n      // a / 0 -> Infinity, a != 0\n      // 0 / 0 -> NaN, a == 0\n      case \"op_div\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n0.type == \"node_const\" && n1.type == \"node_const\" && n0.value == n1.value && n0.value !== 0) {\n          n0.value = 1.0;\n          return n0;\n        }\n        if (n0.type == \"node_const\" && n0.value === 0 && n1.type == \"node_const\" && n1.value !== 0) {\n          n0.value = 0.0;\n          return n0;\n        }\n\n        // Risky: 0 / (something != 0) -> 0.0\n        if (n0.type == \"node_const\" && n0.value === 0 && (n1.type == \"node_op\" || n1.type == \"node_var\")) {\n          node.type = \"node_const\";\n          node.value = 0.0;\n          return node;\n        }\n        if (n0.type == \"node_var\" && n1.type == \"node_var\" && n0.value == n1.value) {\n          return this.createNode(\"node_const\", 1.0);\n        }\n        if (n0.type == \"node_const\" && n0.value !== 0 && n1.type == \"node_const\" && n1.value === 0) {\n          if (n0.value > 0.0) {\n            n0.value = Infinity;\n          } else {\n            n0.value = -Infinity; // Do we ever need this?\n          }\n          return n0;\n        }\n\n        // (-a) / (-b) -> a/b\n        if (n0.type == \"node_op\" && n0.value == \"op_neg\" && n1.type == \"node_op\" && n1.value == \"op_neg\") {\n          node.children = [n0.children[0], n1.children[0]];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // (-a) / b -> -(a/b)\n        if (n0.value == \"op_neg\" && n1.value != \"op_neg\") {\n          node.type = \"node_op\";\n          node.value = \"op_neg\";\n          node.children = [this.createNode(\"node_op\", \"op_div\", n0.children[0], n1)];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        // a / (-b) -> -(a/b)\n        if (n0.value != \"op_neg\" && n1.value == \"op_neg\") {\n          node.type = \"node_op\";\n          node.value = \"op_neg\";\n          node.children = [this.createNode(\"node_op\", \"op_div\", n0, n1.children[0])];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // a^b / a -> a^(b-1)\n        if (n0.type == \"node_op\" && n0.value == \"op_exp\") {\n          if (!n1.hash) {\n            n1.hash = this.parser.compile(n1);\n          }\n          if (!n0.children[0].hash) {\n            n0.children[0].hash = this.parser.compile(n0.children[0]);\n          }\n          if (n1.hash === n0.children[0].hash) {\n            n0.children[1] = this.createNode(\"node_op\", \"op_sub\", n0.children[1], this.createNode(\"node_const\", 1.0));\n            this.mayNotBeSimplified = true;\n            return n0;\n          }\n        }\n\n        // (const * a) / b -> const * (a / b)\n        if (n1.type != \"node_const\" && n0.type == \"node_op\" && n0.value == \"op_mul\" && n0.children[0].type == \"node_const\") {\n          node.value = \"op_mul\";\n          node.children = [n0.children[0], this.createNode(\"node_op\", \"op_div\", n0.children[1], n1)];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // a^b / a^c -> a^(b-c)\n        if (n0.type == \"node_op\" && n0.value == \"op_exp\" && n1.type == \"node_op\" && n1.value == \"op_exp\") {\n          n0.children[0].hash = this.parser.compile(n0.children[0]);\n          n1.children[0].hash = this.parser.compile(n1.children[0]);\n          if (n0.children[0].hash === n1.children[0].hash) {\n            n0.children[1] = this.createNode(\"node_op\", \"op_sub\", n0.children[1], n1.children[1]);\n            this.mayNotBeSimplified = true;\n            return n0;\n          }\n        }\n        break;\n\n      // a^0 = 1\n      // a^1 -> a\n      // 1^a -> 1\n      // 0^a -> 0: a const != 0\n      case \"op_exp\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n1.type == \"node_const\" && n1.value === 0.0) {\n          n1.value = 1.0;\n          return n1;\n        }\n        if (n1.type == \"node_const\" && n1.value == 1.0) {\n          return n0;\n        }\n        if (n0.type == \"node_const\" && n0.value == 1.0) {\n          return n0;\n        }\n        if (n0.type == \"node_const\" && n0.value === 0.0 && n1.type == \"node_const\" && n1.value !== 0.0) {\n          return n0;\n        }\n\n        // (a^b)^c -> a^(b*c)\n        if (n0.type == \"node_op\" && n0.value == \"op_exp\") {\n          node.children = [n0.children[0], this.createNode(\"node_op\", \"op_mul\", n0.children[1], n1)];\n          return node;\n        }\n        break;\n    }\n    switch (node.value) {\n      // const_1 + const_2 -> (const_1 + const_2)\n      // a + a -> 2*a\n      // a + (-b) = a - b\n      case \"op_add\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n0.type == \"node_const\" && n1.type == \"node_const\" && n0.value == n1.value) {\n          n0.value += n1.value;\n          return n0;\n        }\n        if (n0.type == \"node_var\" && n1.type == \"node_var\" && n0.value == n1.value) {\n          node.children[0] = this.createNode(\"node_const\", 2.0);\n          node.value = \"op_mul\";\n          return node;\n        }\n        if (n0.type == \"node_op\" && n0.value == \"op_neg\") {\n          node.value = \"op_sub\";\n          node.children[0] = n1;\n          node.children[1] = n0.children[0];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        if (n1.type == \"node_op\" && n1.value == \"op_neg\") {\n          node.value = \"op_sub\";\n          node.children[1] = n1.children[0];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n\n        // const * a + const * a -> const * a\n        if (n0.type == \"node_op\" && n0.value == \"op_mul\" && n1.type == \"node_op\" && n1.value == \"op_mul\") {\n          n0.children[1].hash = this.parser.compile(n0.children[1]);\n          n1.children[1].hash = this.parser.compile(n1.children[1]);\n          if (n0.children[1].hash === n1.children[1].hash) {\n            node.value = \"op_mul\";\n            node.children = [this.createNode(\"node_op\", \"op_add\", n0.children[0], n1.children[0]), n0.children[1]];\n            this.mayNotBeSimplified = true;\n            return node;\n          }\n        }\n        // const * a + a -> (const + 1) * a\n        if (n0.type == \"node_op\" && n0.value == \"op_mul\") {\n          n0.children[1].hash = this.parser.compile(n0.children[1]);\n          n1.hash = this.parser.compile(n1);\n          if (n0.children[1].hash === n1.hash) {\n            node.value = \"op_mul\";\n            node.children = [this.createNode(\"node_op\", \"op_add\", n0.children[0], this.createNode(\"node_const\", 1.0)), n1];\n            this.mayNotBeSimplified = true;\n            return node;\n          }\n        }\n        // a + const*a -> (const + 1) * a\n        if (n1.type == \"node_op\" && n1.value == \"op_mul\") {\n          n1.children[1].hash = this.parser.compile(n1.children[1]);\n          n0.hash = this.parser.compile(n0);\n          if (n1.children[1].hash === n0.hash) {\n            node.value = \"op_mul\";\n            node.children = [this.createNode(\"node_op\", \"op_add\", this.createNode(\"node_const\", 1.0), n1.children[0]), n0];\n            this.mayNotBeSimplified = true;\n            return node;\n          }\n        }\n        break;\n\n      // a - (-b) = a + b\n      case \"op_sub\":\n        n0 = node.children[0];\n        n1 = node.children[1];\n        if (n1.type == \"node_op\" && n1.value == \"op_neg\") {\n          node.value = \"op_add\";\n          node.children[1] = n1.children[0];\n          this.mayNotBeSimplified = true;\n          return node;\n        }\n        break;\n      case \"op_execfun\":\n        return this.simplifyElementary(node);\n    }\n    return node;\n  },\n  simplifyElementary: function (node) {\n    var fun = node.children[0].value,\n      arg = node.children[1];\n\n    // Catch errors of the form sin()\n    if (arg.length == 0) {\n      return node;\n    }\n    switch (fun) {\n      // sin(0) -> 0\n      // sin(PI) -> 0\n      // sin (int * PI) -> 0\n      // sin (PI * int) -> 0\n      // Same for tan()\n      case \"sin\":\n      case \"tan\":\n        if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n          node.type = \"node_const\";\n          node.value = 0.0;\n          return node;\n        }\n        if (arg[0].type == \"node_var\" && arg[0].value == \"PI\") {\n          node.type = \"node_const\";\n          node.value = 0.0;\n          return node;\n        }\n        if (arg[0].type == \"node_op\" && arg[0].value == \"op_mul\" && arg[0].children[0].type == \"node_const\" && arg[0].children[0].value % 1 === 0 && arg[0].children[1].type == \"node_var\" && arg[0].children[1].value == \"PI\") {\n          node.type = \"node_const\";\n          node.value = 0.0;\n          return node;\n        }\n        break;\n\n      // cos(0) -> 1.0\n      // cos(PI) -> -1.0\n      // cos(int * PI) -> +/- 1.0\n      // cos(PI * int) -> +/- 1.0\n      case \"cos\":\n        if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n          node.type = \"node_const\";\n          node.value = 1.0;\n          return node;\n        }\n        if (arg[0].type == \"node_var\" && arg[0].value == \"PI\") {\n          node.type = \"node_op\";\n          node.value = \"op_neg\";\n          node.children = [this.createNode(\"node_const\", 1.0)];\n          return node;\n        }\n        /*\n        if (arg[0].type == 'node_op' && arg[0].value == 'op_mul' &&\n            ((arg[0].children[0].type == 'node_const' && arg[0].children[0].value % 1 === 0 &&\n             arg[0].children[1].type == 'node_var' && arg[0].children[1].value == 'PI') ||\n             (arg[0].children[1].type == 'node_const' && arg[0].children[1].value % 1 === 0 &&\n              arg[0].children[0].type == 'node_var' && arg[0].children[0].value == 'PI'))) {\n            node.type = 'node_const';\n            node.value = 1.0;\n            return node;\n        }\n        */\n        break;\n\n      // exp(0) -> 1\n      case \"exp\":\n        if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n          node.type = \"node_const\";\n          node.value = 1.0;\n          return node;\n        }\n        break;\n\n      // pow(a, 0) -> 1\n      case \"pow\":\n        if (arg[1].type == \"node_const\" && arg[1].value === 0) {\n          node.type = \"node_const\";\n          node.value = 1.0;\n          return node;\n        }\n        break;\n    }\n    return node;\n  }\n});\nexport default JXG.CA;","map":{"version":3,"names":["JXG","Type","CA","node","createNode","parser","extend","prototype","findMapNode","mapname","i","len","ret","value","children","length","setMath","type","isMath","deriveElementary","varname","fun","arg","newNode","deepCopy","derivative","console","log","Error","line","expandDerivatives","parent","ast","j","mapNode","codeNode","node2","mapName","vArray","order","isMap","col","isArray","removeTrivialNodes","n0","n1","swap","mayNotBeSimplified","hash","compile","Infinity","simplifyElementary"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/parser/ca.js"],"sourcesContent":["/*\n JessieCode Computer algebra algorithms\n\n    Copyright 2011-2019\n        Michael Gerhaeuser,\n        Alfred Wassermann\n\n    JessieCode is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JessieCode is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JessieCode. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, window: true, console: true, self: true, document: true, parser: true*/\n/*jslint nomen: true, plusplus: true*/\n/*eslint eqeqeq: \"off\"*/\n\n/**\n * @fileoverview Here, the computer algebra algorithms are implemented.\n */\n\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n// import Const from \"../base/constants\";\n// import Text from \"../base/text\";\n// import Mat from \"../math/math\";\n// import Geometry from \"../math/geometry\";\n// import Statistics from \"../math/statistics\";\n// import Env from \"../utils/env\";\n\n/**\n * A JessieCode object provides an interface to the parser and stores all variables and objects used within a JessieCode script.\n * The optional argument <tt>code</tt> is interpreted after initializing. To evaluate more code after initializing a JessieCode instance\n * please use {@link JXG.JessieCode#parse}. For code snippets like single expressions use {@link JXG.JessieCode#snippet}.\n * @constructor\n * @param {String} [code] Code to parse.\n * @param {Boolean} [geonext=false] Geonext compatibility mode.\n */\nJXG.CA = function (node, createNode, parser) {\n    this.node = node;\n    this.createNode = createNode;\n    this.parser = parser;\n};\n\nJXG.extend(\n    JXG.CA.prototype,\n    /** @lends JXG.CA.prototype */ {\n        findMapNode: function (mapname, node) {\n            var i, len, ret;\n\n            //console.log(\"FINDMAP\", node);\n            if (node.value === \"op_assign\" && node.children[0].value === mapname) {\n                return node.children[1];\n            } else if (node.children) {\n                len = node.children.length;\n                for (i = 0; i < len; ++i) {\n                    ret = this.findMapNode(mapname, node.children[i]);\n                    if (ret !== null) {\n                        return ret;\n                    }\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Declare all subnodes as math nodes,\n         * i.e recursively set node.isMath = true;\n         */\n        setMath: function (node) {\n            var i, len;\n\n            if (\n                (node.type == \"node_op\" &&\n                    (node.value == \"op_add\" ||\n                        node.value == \"op_sub\" ||\n                        node.value == \"op_mul\" ||\n                        node.value == \"op_div\" ||\n                        node.value == \"op_neg\" ||\n                        node.value == \"op_execfun\" ||\n                        node.value == \"op_exp\")) ||\n                node.type == \"node_var\" ||\n                node.type == \"node_const\"\n            ) {\n                node.isMath = true;\n            }\n            if (node.children) {\n                len = node.children.length;\n                for (i = 0; i < len; ++i) {\n                    this.setMath(node.children[i]);\n                }\n            }\n        },\n\n        deriveElementary: function (node, varname) {\n            var fun = node.children[0].value,\n                arg = node.children[1],\n                newNode;\n\n            switch (fun) {\n                case \"abs\":\n                    // x / sqrt(x * x)\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        arg[0],\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(arg[0]),\n                                    Type.deepCopy(arg[0])\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"sqrt\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_mul\",\n                            this.createNode(\"node_const\", 2.0),\n                            this.createNode(\n                                node.type,\n                                node.value,\n                                Type.deepCopy(node.children[0]),\n                                Type.deepCopy(node.children[1])\n                            )\n                        )\n                    );\n                    break;\n\n                case \"sin\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_execfun\",\n                        this.createNode(\"node_var\", \"cos\"),\n                        Type.deepCopy(arg)\n                    );\n                    break;\n\n                case \"cos\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sin\"),\n                            Type.deepCopy(arg)\n                        )\n                    );\n                    break;\n\n                case \"tan\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_exp\",\n                            this.createNode(\n                                \"node_op\",\n                                \"op_execfun\",\n                                this.createNode(\"node_var\", \"cos\"),\n                                Type.deepCopy(arg)\n                            ),\n                            this.createNode(\"node_const\", 2)\n                        )\n                    );\n                    break;\n\n                case \"cot\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_exp\",\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_execfun\",\n                                    this.createNode(\"node_var\", \"sin\"),\n                                    Type.deepCopy(arg)\n                                ),\n                                this.createNode(\"node_const\", 2)\n                            )\n                        )\n                    );\n                    break;\n\n                case \"exp\":\n                    newNode = this.createNode(\n                        node.type,\n                        node.value,\n                        Type.deepCopy(node.children[0]),\n                        Type.deepCopy(node.children[1])\n                    );\n                    break;\n\n                case \"pow\":\n                    // (f^g)' = f^g*(f'g/f + g' log(f))\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_mul\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            Type.deepCopy(node.children[0]),\n                            Type.deepCopy(node.children[1])\n                        ),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_add\",\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                this.derivative(node.children[1][0], varname),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_div\",\n                                    Type.deepCopy(node.children[1][1]),\n                                    Type.deepCopy(node.children[1][0])\n                                )\n                            ),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                this.derivative(node.children[1][1], varname),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_execfun\",\n                                    this.createNode(\"node_var\", \"log\"),\n                                    [Type.deepCopy(node.children[1][0])]\n                                )\n                            )\n                        )\n                    );\n                    break;\n\n                case \"log\":\n                case \"ln\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        // Attention: single variable mode\n                        Type.deepCopy(arg[0])\n                    );\n                    break;\n\n                case \"log2\":\n                case \"lb\":\n                case \"ld\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_mul\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            // Attention: single variable mode\n                            Type.deepCopy(arg[0])\n                        ),\n                        this.createNode(\"node_const\", 1.4426950408889634) // 1/log(2)\n                    );\n                    break;\n\n                case \"log10\":\n                case \"lg\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_mul\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            // Attention: single variable mode\n                            Type.deepCopy(arg[0])\n                        ),\n                        this.createNode(\"node_const\", 0.43429448190325176) // 1/log(10)\n                    );\n                    break;\n\n                case \"asin\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\"node_const\", 1.0),\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(arg[0]),\n                                        Type.deepCopy(arg[0])\n                                    )\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"acos\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_execfun\",\n                                this.createNode(\"node_var\", \"sqrt\"),\n                                [\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_sub\",\n                                        this.createNode(\"node_const\", 1.0),\n                                        this.createNode(\n                                            \"node_op\",\n                                            \"op_mul\",\n                                            Type.deepCopy(arg[0]),\n                                            Type.deepCopy(arg[0])\n                                        )\n                                    )\n                                ]\n                            )\n                        )\n                    );\n                    break;\n\n                //case 'atan2':\n\n                case \"atan\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_add\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                Type.deepCopy(arg[0]),\n                                Type.deepCopy(arg[0])\n                            )\n                        )\n                    );\n                    break;\n\n                case \"acot\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_neg\",\n                        this.createNode(\n                            \"node_op\",\n                            \"op_div\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                this.createNode(\"node_const\", 1.0),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(arg[0]),\n                                    Type.deepCopy(arg[0])\n                                )\n                            )\n                        )\n                    );\n                    break;\n\n                case \"sinh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_execfun\",\n                        this.createNode(\"node_var\", \"cosh\"),\n                        [Type.deepCopy(arg[0])]\n                    );\n                    break;\n\n                case \"cosh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_execfun\",\n                        this.createNode(\"node_var\", \"sinh\"),\n                        [Type.deepCopy(arg[0])]\n                    );\n                    break;\n\n                case \"tanh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_sub\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_exp\",\n                            this.createNode(\n                                \"node_op\",\n                                \"op_execfun\",\n                                this.createNode(\"node_var\", \"tanh\"),\n                                [Type.deepCopy(arg[0])]\n                            ),\n                            this.createNode(\"node_const\", 2.0)\n                        )\n                    );\n                    break;\n\n                case \"asinh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(arg[0]),\n                                        Type.deepCopy(arg[0])\n                                    ),\n                                    this.createNode(\"node_const\", 1.0)\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"acosh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_execfun\",\n                            this.createNode(\"node_var\", \"sqrt\"),\n                            [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(arg[0]),\n                                        Type.deepCopy(arg[0])\n                                    ),\n                                    this.createNode(\"node_const\", 1.0)\n                                )\n                            ]\n                        )\n                    );\n                    break;\n\n                case \"atanh\":\n                    newNode = this.createNode(\n                        \"node_op\",\n                        \"op_div\",\n                        this.createNode(\"node_const\", 1.0),\n                        this.createNode(\n                            \"node_op\",\n                            \"op_sub\",\n                            this.createNode(\"node_const\", 1.0),\n                            this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                Type.deepCopy(arg[0]),\n                                Type.deepCopy(arg[0])\n                            )\n                        )\n                    );\n                    break;\n\n                default:\n                    newNode = this.createNode(\"node_const\", 0.0);\n                    console.log('Derivative of \"' + fun + '\" not yet implemented');\n                    throw new Error(\"Error(\" + this.line + \"): \");\n                //  this._error('Derivative of \"' + fun + '\" not yet implemented');\n            }\n\n            return newNode;\n        },\n\n        derivative: function (node, varname) {\n            var newNode;\n\n            switch (node.type) {\n                case \"node_op\":\n                    switch (node.value) {\n                        /*\n                        case 'op_map':\n                            if (true) {\n                                newNode = this.createNode('node_op', 'op_map',\n                                        Type.deepCopy(node.children[0]),\n                                        this.derivative(node.children[1], varname)\n                                    );\n                            } else {\n                                newNode = this.derivative(node.children[1], varname);\n                            }\n                            break;\n                        */\n                        case \"op_execfun\":\n                            // f'(g(x))g'(x)\n                            if (node.children[0].value == \"pow\") {\n                                newNode = this.deriveElementary(node, varname);\n                            } else {\n                                if (node.children[1].length === 0) {\n                                    newNode = this.createNode(\"node_const\", 0.0);\n                                } else {\n                                    newNode = this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.deriveElementary(node, varname),\n                                        // Warning: single variable mode\n                                        this.derivative(node.children[1][0], varname)\n                                    );\n                                }\n                            }\n                            break;\n\n                        case \"op_div\":\n                            // (f'g − g'f )/(g*g)\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_div\",\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.derivative(node.children[0], varname),\n                                        Type.deepCopy(node.children[1])\n                                    ),\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        Type.deepCopy(node.children[0]),\n                                        this.derivative(node.children[1], varname)\n                                    )\n                                ),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(node.children[1]),\n                                    Type.deepCopy(node.children[1])\n                                )\n                            );\n                            break;\n\n                        case \"op_mul\":\n                            // fg' + f'g\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    Type.deepCopy(node.children[0]),\n                                    this.derivative(node.children[1], varname)\n                                ),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_mul\",\n                                    this.derivative(node.children[0], varname),\n                                    Type.deepCopy(node.children[1])\n                                )\n                            );\n                            break;\n\n                        case \"op_neg\":\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_neg\",\n                                this.derivative(node.children[0], varname)\n                            );\n                            break;\n\n                        case \"op_add\":\n                        case \"op_sub\":\n                            newNode = this.createNode(\n                                \"node_op\",\n                                node.value,\n                                this.derivative(node.children[0], varname),\n                                this.derivative(node.children[1], varname)\n                            );\n                            break;\n\n                        case \"op_exp\":\n                            // (f^g)' = f^g*(f'g/f + g' log(f))\n                            newNode = this.createNode(\n                                \"node_op\",\n                                \"op_mul\",\n                                Type.deepCopy(node),\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.derivative(node.children[0], varname),\n                                        this.createNode(\n                                            \"node_op\",\n                                            \"op_div\",\n                                            Type.deepCopy(node.children[1]),\n                                            Type.deepCopy(node.children[0])\n                                        )\n                                    ),\n                                    this.createNode(\n                                        \"node_op\",\n                                        \"op_mul\",\n                                        this.derivative(node.children[1], varname),\n                                        this.createNode(\n                                            \"node_op\",\n                                            \"op_execfun\",\n                                            this.createNode(\"node_var\", \"log\"),\n                                            [Type.deepCopy(node.children[0])]\n                                        )\n                                    )\n                                )\n                            );\n                            break;\n                    }\n                    break;\n\n                case \"node_var\":\n                    //console.log('node_var', node);\n                    if (node.value === varname) {\n                        newNode = this.createNode(\"node_const\", 1.0);\n                    } else {\n                        newNode = this.createNode(\"node_const\", 0.0);\n                    }\n                    break;\n\n                case \"node_const\":\n                    newNode = this.createNode(\"node_const\", 0.0);\n                    break;\n\n                case \"node_const_bool\":\n                    break;\n\n                case \"node_str\":\n                    break;\n            }\n\n            return newNode;\n        },\n\n        /**\n         * f = map (x) -> x*sin(x);\n         * Usages:\n         *   h = D(f, x);\n         *   h = map (x) -> D(f, x);\n         * or\n         *   D(x^2, x);\n         */\n        expandDerivatives: function (node, parent, ast) {\n            var len, i, j, mapNode, codeNode,\n                ret, node2, newNode, mapName,\n                varname, vArray, order, isMap;\n\n            ret = 0;\n            if (!node) {\n                return ret;\n            }\n\n            this.line = node.line;\n            this.col = node.col;\n\n            // First we have to go down in the tree.\n            // This ensures that in cases like D(D(f,x),x) the inner D is expanded first.\n            len = node.children.length;\n            for (i = 0; i < len; ++i) {\n                if (node.children[i] && node.children[i].type) {\n                    node.children[i] = this.expandDerivatives(node.children[i], node, ast);\n                } else if (Type.isArray(node.children[i])) {\n                    for (j = 0; j < node.children[i].length; ++j) {\n                        if (node.children[i][j] && node.children[i][j].type) {\n                            node.children[i][j] = this.expandDerivatives(\n                                node.children[i][j],\n                                node,\n                                ast\n                            );\n                        }\n                    }\n                }\n            }\n\n            switch (node.type) {\n                case \"node_op\":\n                    switch (node.value) {\n                        case \"op_execfun\":\n                            if (node.children[0] && node.children[0].value === \"D\") {\n                                /*\n                                 * Distinguish the cases:\n                                 *   D(f, x) where f is map -> isMap = true\n                                 * and\n                                 *   D(2*x, x), D(sin(x), x), ...  -> isMap = false\n                                 */\n                                isMap = false;\n                                if (node.children[1][0].type == \"node_var\") {\n                                    mapName = node.children[1][0].value;\n                                    mapNode = this.findMapNode(mapName, ast);\n                                    if (mapNode !== null) {\n                                        isMap = true;\n                                    }\n                                }\n\n                                if (isMap) {\n                                    /*\n                                     * Derivative of map, that is compute D(f,x)\n                                     * where e.g. f = map (x) -> x^2\n                                     *\n                                     * First step: find node where the map is defined\n                                     */\n                                    // Already done above\n                                    // mapName = node.children[1][0].value;\n                                    // mapNode = this.findMapNode(mapName, ast);\n                                    vArray = mapNode.children[0];\n\n                                    // Variable name for differentiation\n                                    if (node.children[1].length >= 2) {\n                                        varname = node.children[1][1].value;\n                                    } else {\n                                        varname = mapNode.children[0][0]; // Usually it's 'x'\n                                    }\n                                    codeNode = mapNode.children[1];\n                                } else {\n                                    /*\n                                     * Derivative of expression, e.g.\n                                     *     D(2*x, x) or D(sin(x), x)\n                                     */\n                                    codeNode = node.children[1][0];\n                                    vArray = [\"x\"];\n\n                                    // Variable name for differentiation and order\n                                    if (node.children[1].length >= 2) {\n                                        varname = node.children[1][1].value;\n                                    } else {\n                                        varname = \"x\";\n                                    }\n                                }\n\n                                // Differentiation order\n                                if (node.children[1].length >= 3) {\n                                    order = node.children[1][2].value;\n                                } else {\n                                    order = 1;\n                                }\n\n                                // Create node which contains the derivative\n                                newNode = codeNode;\n                                //newNode = this.removeTrivialNodes(newNode);\n                                if (order >= 1) {\n                                    while (order >= 1) {\n                                        newNode = this.derivative(newNode, varname);\n                                        newNode = this.removeTrivialNodes(newNode);\n                                        order--;\n                                    }\n                                }\n\n                                // Replace the node containing e.g. D(f,x) by the derivative.\n                                if (parent.type == \"node_op\" && parent.value == \"op_assign\") {\n                                    // If D is an assignment it has to be replaced by a map\n                                    // h = D(f, x)\n                                    node2 = this.createNode(\n                                        \"node_op\",\n                                        \"op_map\",\n                                        vArray,\n                                        newNode\n                                    );\n                                } else {\n                                    node2 = newNode;\n                                }\n\n                                this.setMath(node2);\n                                node.type = node2.type;\n                                node.value = node2.value;\n                                if (node2.children.length > 0) {\n                                    node.children[0] = node2.children[0];\n                                }\n                                if (node2.children.length > 1) {\n                                    node.children[1] = node2.children[1];\n                                }\n                            }\n                    }\n                    break;\n\n                case \"node_var\":\n                case \"node_const\":\n                case \"node_const_bool\":\n                case \"node_str\":\n                    break;\n            }\n\n            return node;\n        },\n\n        removeTrivialNodes: function (node) {\n            var i, len, n0, n1, swap;\n\n            // In case of 'op_execfun' the children[1] node is an array.\n            if (Type.isArray(node)) {\n                len = node.length;\n                for (i = 0; i < len; ++i) {\n                    node[i] = this.removeTrivialNodes(node[i]);\n                }\n            }\n            if (node.type != \"node_op\" || !node.children) {\n                return node;\n            }\n\n            len = node.children.length;\n            for (i = 0; i < len; ++i) {\n                this.mayNotBeSimplified = false;\n                do {\n                    node.children[i] = this.removeTrivialNodes(node.children[i]);\n                } while (this.mayNotBeSimplified);\n            }\n\n            switch (node.value) {\n                // Allow maps of the form\n                //  map (x) -> x;\n                case \"op_map\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n1.type == \"node_var\") {\n                        for (i = 0; i < n0.length; ++i) {\n                            // Allow maps of the form map(x) -> x\n                            if (n0[i] == n1.value) {\n                                n1.isMath = true;\n                                break;\n                            }\n                        }\n                    }\n                    break;\n\n                // a + 0 -> a\n                // 0 + a -> a\n                case \"op_add\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n0;\n                    }\n\n                    // const + const -> const\n                    if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n                        n0.value += n1.value;\n                        return n0;\n                    }\n                    break;\n\n                // 1 * a = a\n                // a * 1 = a\n                // a * 0 = 0\n                // 0 * a = 0\n                // - * - = +\n                // Order children\n                case \"op_mul\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n0.type == \"node_const\" && n0.value == 1.0) {\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value == 1.0) {\n                        return n0;\n                    }\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        return n0;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n1;\n                    }\n\n                    // (-a) * (-b) -> a*b\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_neg\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\"\n                    ) {\n                        node.children = [n0.children[0], n1.children[0]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // (-a) * b -> -(a*b)\n                    if (n0.value == \"op_neg\" && n1.value != \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_mul\", n0.children[0], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a * (-b) -> -(a*b)\n                    if (n0.value != \"op_neg\" && n1.value == \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_mul\", n0, n1.children[0])\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // (1 / a) * b -> a / b\n                    if (\n                        n0.value == \"op_div\" &&\n                        n0.children[0].type == \"node_const\" &&\n                        n0.children[0].value == 1.0\n                    ) {\n                        node.type = \"node_op\";\n                        node.value = \"op_div\";\n                        node.children = [n1, n0.children[1]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a * (1 / b) -> a / b\n                    if (\n                        n1.value == \"op_div\" &&\n                        n1.children[0].type == \"node_const\" &&\n                        n1.children[0].value == 1.0\n                    ) {\n                        node.type = \"node_op\";\n                        node.value = \"op_div\";\n                        node.children = [n0, n1.children[1]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // Order children\n                    // a * const -> const * a\n                    if (n0.type != \"node_const\" && n1.type == \"node_const\") {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a + (-const) -> -const + a\n                    if (\n                        n0.type != \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\" &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a * var -> var * a\n                    // a * fun -> fun * a\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value != \"op_execfun\" &&\n                        (n1.type == \"node_var\" ||\n                            (n1.type == \"node_op\" && n1.value == \"op_execfun\"))\n                    ) {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a + (-var) -> -var  + a\n                    if (\n                        n0.type != \"node_op\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\" &&\n                        n1.children[0].type == \"node_var\"\n                    ) {\n                        node.children = [n1, n0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a * (const * b) -> const * (a*b)\n                    // a * (const / b) -> const * (a/b)\n                    if (\n                        n0.type != \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        (n1.value == \"op_mul\" || n1.value == \"op_div\") &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        swap = n1.children[0];\n                        n1.children[0] = n0;\n                        node.children = [swap, n1];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // (const * a) * b -> const * (a * b)\n                    if (\n                        n1.type != \"node_const\" &&\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n0.children[0].type == \"node_const\"\n                    ) {\n                        node.children = [\n                            n0.children[0],\n                            this.createNode(\"node_op\", \"op_mul\", n0.children[1], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // const * const -> const\n                    if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n                        n0.value *= n1.value;\n                        return n0;\n                    }\n\n                    // const * (const * a) -> const * a\n                    // const * (const / a) -> const / a\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        (n1.value == \"op_mul\" || n1.value == \"op_div\") &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        n1.children[0].value *= n0.value;\n                        return n1;\n                    }\n\n                    // a * a-> a^2\n                    n0.hash = this.parser.compile(n0);\n                    n1.hash = this.parser.compile(n1);\n                    if (n0.hash === n1.hash) {\n                        node.value = \"op_exp\";\n                        node.children[1] = this.createNode(\"node_const\", 2.0);\n                        return node;\n                    }\n\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_op\" &&\n                        (n1.value == \"op_mul\" || n1.value == \"op_div\") &&\n                        n1.children[0].type == \"node_const\"\n                    ) {\n                        n1.children[0].value *= n0.value;\n                        return n1;\n                    }\n\n                    // a * a^b -> a^(b+1)\n                    if (n1.type == \"node_op\" && n1.value == \"op_exp\") {\n                        if (!n0.hash) {\n                            n0.hash = this.parser.compile(n0);\n                        }\n                        if (!n1.children[0].hash) {\n                            n1.children[0].hash = this.parser.compile(n1.children[0]);\n                        }\n                        if (n0.hash === n1.children[0].hash) {\n                            n1.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                n1.children[1],\n                                this.createNode(\"node_const\", 1.0)\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n1;\n                        }\n                    }\n\n                    // a^b * a^c -> a^(b+c)\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_exp\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_exp\"\n                    ) {\n                        n0.children[0].hash = this.parser.compile(n0.children[0]);\n                        n1.children[0].hash = this.parser.compile(n1.children[0]);\n                        if (n0.children[0].hash === n1.children[0].hash) {\n                            n0.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_add\",\n                                n0.children[1],\n                                n1.children[1]\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n0;\n                        }\n                    }\n\n                    break;\n\n                // 0 - a -> -a\n                // a - 0 -> a\n                // a - a -> 0\n                case \"op_sub\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        node.value = \"op_neg\";\n                        node.children[0] = n1;\n                        return node;\n                    }\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        return n0;\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_const\" &&\n                        n0.value == n1.value\n                    ) {\n                        return this.createNode(\"node_const\", 0.0);\n                    }\n                    if (\n                        n0.type == \"node_var\" &&\n                        n1.type == \"node_var\" &&\n                        n0.value == n1.value\n                    ) {\n                        return this.createNode(\"node_const\", 0.0);\n                    }\n\n                    // const - const -> const\n                    if (n0.type == \"node_const\" && n1.type == \"node_const\") {\n                        n0.value -= n1.value;\n                        return n0;\n                    }\n\n                    // const * a - const * a -> const * a\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_mul\"\n                    ) {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        if (n0.children[1].hash === n1.children[1].hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    n0.children[0],\n                                    n1.children[0]\n                                ),\n                                n0.children[1]\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // const * a - a -> (const - 1) * a\n                    if (n0.type == \"node_op\" && n0.value == \"op_mul\") {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.hash = this.parser.compile(n1);\n                        if (n0.children[1].hash === n1.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    n0.children[0],\n                                    this.createNode(\"node_const\", 1.0)\n                                ),\n                                n1\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // a - const*a -> (const - 1) * a\n                    if (n1.type == \"node_op\" && n1.value == \"op_mul\") {\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        n0.hash = this.parser.compile(n0);\n                        if (n1.children[1].hash === n0.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_sub\",\n                                    this.createNode(\"node_const\", 1.0),\n                                    n1.children[0]\n                                ),\n                                n0\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n\n                    break;\n\n                // -0 -> 0\n                // -(-b) = b\n                case \"op_neg\":\n                    n0 = node.children[0];\n                    if (n0.type == \"node_const\" && n0.value === 0.0) {\n                        return n0;\n                    }\n                    if (n0.type == \"node_op\" && n0.value == \"op_neg\") {\n                        return n0.children[0];\n                    }\n                    break;\n\n                // a / a -> 1, a != 0\n                // 0 / a -> 0, a != 0\n                // a / 0 -> Infinity, a != 0\n                // 0 / 0 -> NaN, a == 0\n                case \"op_div\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_const\" &&\n                        n0.value == n1.value &&\n                        n0.value !== 0\n                    ) {\n                        n0.value = 1.0;\n                        return n0;\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value === 0 &&\n                        n1.type == \"node_const\" &&\n                        n1.value !== 0\n                    ) {\n                        n0.value = 0.0;\n                        return n0;\n                    }\n\n                    // Risky: 0 / (something != 0) -> 0.0\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value === 0 &&\n                        (n1.type == \"node_op\" || n1.type == \"node_var\")\n                    ) {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n\n                    if (\n                        n0.type == \"node_var\" &&\n                        n1.type == \"node_var\" &&\n                        n0.value == n1.value\n                    ) {\n                        return this.createNode(\"node_const\", 1.0);\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value !== 0 &&\n                        n1.type == \"node_const\" &&\n                        n1.value === 0\n                    ) {\n                        if (n0.value > 0.0) {\n                            n0.value = Infinity;\n                        } else {\n                            n0.value = -Infinity; // Do we ever need this?\n                        }\n                        return n0;\n                    }\n\n                    // (-a) / (-b) -> a/b\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_neg\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_neg\"\n                    ) {\n                        node.children = [n0.children[0], n1.children[0]];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // (-a) / b -> -(a/b)\n                    if (n0.value == \"op_neg\" && n1.value != \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_div\", n0.children[0], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    // a / (-b) -> -(a/b)\n                    if (n0.value != \"op_neg\" && n1.value == \"op_neg\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [\n                            this.createNode(\"node_op\", \"op_div\", n0, n1.children[0])\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a^b / a -> a^(b-1)\n                    if (n0.type == \"node_op\" && n0.value == \"op_exp\") {\n                        if (!n1.hash) {\n                            n1.hash = this.parser.compile(n1);\n                        }\n                        if (!n0.children[0].hash) {\n                            n0.children[0].hash = this.parser.compile(n0.children[0]);\n                        }\n                        if (n1.hash === n0.children[0].hash) {\n                            n0.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_sub\",\n                                n0.children[1],\n                                this.createNode(\"node_const\", 1.0)\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n0;\n                        }\n                    }\n\n                    // (const * a) / b -> const * (a / b)\n                    if (\n                        n1.type != \"node_const\" &&\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n0.children[0].type == \"node_const\"\n                    ) {\n                        node.value = \"op_mul\";\n                        node.children = [\n                            n0.children[0],\n                            this.createNode(\"node_op\", \"op_div\", n0.children[1], n1)\n                        ];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // a^b / a^c -> a^(b-c)\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_exp\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_exp\"\n                    ) {\n                        n0.children[0].hash = this.parser.compile(n0.children[0]);\n                        n1.children[0].hash = this.parser.compile(n1.children[0]);\n                        if (n0.children[0].hash === n1.children[0].hash) {\n                            n0.children[1] = this.createNode(\n                                \"node_op\",\n                                \"op_sub\",\n                                n0.children[1],\n                                n1.children[1]\n                            );\n                            this.mayNotBeSimplified = true;\n                            return n0;\n                        }\n                    }\n\n                    break;\n\n                // a^0 = 1\n                // a^1 -> a\n                // 1^a -> 1\n                // 0^a -> 0: a const != 0\n                case \"op_exp\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n1.type == \"node_const\" && n1.value === 0.0) {\n                        n1.value = 1.0;\n                        return n1;\n                    }\n                    if (n1.type == \"node_const\" && n1.value == 1.0) {\n                        return n0;\n                    }\n                    if (n0.type == \"node_const\" && n0.value == 1.0) {\n                        return n0;\n                    }\n                    if (\n                        n0.type == \"node_const\" &&\n                        n0.value === 0.0 &&\n                        n1.type == \"node_const\" &&\n                        n1.value !== 0.0\n                    ) {\n                        return n0;\n                    }\n\n                    // (a^b)^c -> a^(b*c)\n                    if (n0.type == \"node_op\" && n0.value == \"op_exp\") {\n                        node.children = [\n                            n0.children[0],\n                            this.createNode(\"node_op\", \"op_mul\", n0.children[1], n1)\n                        ];\n                        return node;\n                    }\n                    break;\n            }\n\n            switch (node.value) {\n                // const_1 + const_2 -> (const_1 + const_2)\n                // a + a -> 2*a\n                // a + (-b) = a - b\n                case \"op_add\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (\n                        n0.type == \"node_const\" &&\n                        n1.type == \"node_const\" &&\n                        n0.value == n1.value\n                    ) {\n                        n0.value += n1.value;\n                        return n0;\n                    }\n\n                    if (\n                        n0.type == \"node_var\" &&\n                        n1.type == \"node_var\" &&\n                        n0.value == n1.value\n                    ) {\n                        node.children[0] = this.createNode(\"node_const\", 2.0);\n                        node.value = \"op_mul\";\n                        return node;\n                    }\n\n                    if (n0.type == \"node_op\" && n0.value == \"op_neg\") {\n                        node.value = \"op_sub\";\n                        node.children[0] = n1;\n                        node.children[1] = n0.children[0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    if (n1.type == \"node_op\" && n1.value == \"op_neg\") {\n                        node.value = \"op_sub\";\n                        node.children[1] = n1.children[0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n\n                    // const * a + const * a -> const * a\n                    if (\n                        n0.type == \"node_op\" &&\n                        n0.value == \"op_mul\" &&\n                        n1.type == \"node_op\" &&\n                        n1.value == \"op_mul\"\n                    ) {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        if (n0.children[1].hash === n1.children[1].hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    n0.children[0],\n                                    n1.children[0]\n                                ),\n                                n0.children[1]\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // const * a + a -> (const + 1) * a\n                    if (n0.type == \"node_op\" && n0.value == \"op_mul\") {\n                        n0.children[1].hash = this.parser.compile(n0.children[1]);\n                        n1.hash = this.parser.compile(n1);\n                        if (n0.children[1].hash === n1.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    n0.children[0],\n                                    this.createNode(\"node_const\", 1.0)\n                                ),\n                                n1\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n                    // a + const*a -> (const + 1) * a\n                    if (n1.type == \"node_op\" && n1.value == \"op_mul\") {\n                        n1.children[1].hash = this.parser.compile(n1.children[1]);\n                        n0.hash = this.parser.compile(n0);\n                        if (n1.children[1].hash === n0.hash) {\n                            node.value = \"op_mul\";\n                            node.children = [\n                                this.createNode(\n                                    \"node_op\",\n                                    \"op_add\",\n                                    this.createNode(\"node_const\", 1.0),\n                                    n1.children[0]\n                                ),\n                                n0\n                            ];\n                            this.mayNotBeSimplified = true;\n                            return node;\n                        }\n                    }\n\n                    break;\n\n                // a - (-b) = a + b\n                case \"op_sub\":\n                    n0 = node.children[0];\n                    n1 = node.children[1];\n                    if (n1.type == \"node_op\" && n1.value == \"op_neg\") {\n                        node.value = \"op_add\";\n                        node.children[1] = n1.children[0];\n                        this.mayNotBeSimplified = true;\n                        return node;\n                    }\n                    break;\n\n                case \"op_execfun\":\n                    return this.simplifyElementary(node);\n            }\n\n            return node;\n        },\n\n        simplifyElementary: function (node) {\n            var fun = node.children[0].value,\n                arg = node.children[1];\n\n            // Catch errors of the form sin()\n            if (arg.length == 0) {\n                return node;\n            }\n\n            switch (fun) {\n                // sin(0) -> 0\n                // sin(PI) -> 0\n                // sin (int * PI) -> 0\n                // sin (PI * int) -> 0\n                // Same for tan()\n                case \"sin\":\n                case \"tan\":\n                    if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n                    if (arg[0].type == \"node_var\" && arg[0].value == \"PI\") {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n                    if (\n                        arg[0].type == \"node_op\" &&\n                        arg[0].value == \"op_mul\" &&\n                        arg[0].children[0].type == \"node_const\" &&\n                        arg[0].children[0].value % 1 === 0 &&\n                        arg[0].children[1].type == \"node_var\" &&\n                        arg[0].children[1].value == \"PI\"\n                    ) {\n                        node.type = \"node_const\";\n                        node.value = 0.0;\n                        return node;\n                    }\n                    break;\n\n                // cos(0) -> 1.0\n                // cos(PI) -> -1.0\n                // cos(int * PI) -> +/- 1.0\n                // cos(PI * int) -> +/- 1.0\n                case \"cos\":\n                    if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 1.0;\n                        return node;\n                    }\n                    if (arg[0].type == \"node_var\" && arg[0].value == \"PI\") {\n                        node.type = \"node_op\";\n                        node.value = \"op_neg\";\n                        node.children = [this.createNode(\"node_const\", 1.0)];\n                        return node;\n                    }\n                    /*\n                    if (arg[0].type == 'node_op' && arg[0].value == 'op_mul' &&\n                        ((arg[0].children[0].type == 'node_const' && arg[0].children[0].value % 1 === 0 &&\n                         arg[0].children[1].type == 'node_var' && arg[0].children[1].value == 'PI') ||\n                         (arg[0].children[1].type == 'node_const' && arg[0].children[1].value % 1 === 0 &&\n                          arg[0].children[0].type == 'node_var' && arg[0].children[0].value == 'PI'))) {\n                        node.type = 'node_const';\n                        node.value = 1.0;\n                        return node;\n                    }\n                    */\n                    break;\n\n                // exp(0) -> 1\n                case \"exp\":\n                    if (arg[0].type == \"node_const\" && arg[0].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 1.0;\n                        return node;\n                    }\n                    break;\n\n                // pow(a, 0) -> 1\n                case \"pow\":\n                    if (arg[1].type == \"node_const\" && arg[1].value === 0) {\n                        node.type = \"node_const\";\n                        node.value = 1.0;\n                        return node;\n                    }\n                    break;\n            }\n\n            return node;\n        }\n    }\n);\n\nexport default JXG.CA;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}