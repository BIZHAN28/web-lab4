{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/**\n * @fileoverview Simple prefix parser for measurements and expressions of measurements.\n * An expression is given as\n * <ul>\n * <li> array starting with an operator as first element, followed\n * by one or more operands,\n * <li> number.\n * </ul>\n * <p>\n * Possible operands are:\n * <ul>\n * <li> '+', '-', '*', '/'\n * </ul>\n *\n * @example\n *\n */\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\nimport Const from \"../base/constants\";\n\n/**\n * Prefix expression parser, i.e. a poor man's parser.\n * This is a simple prefix parser for measurements and expressions of measurements,\n * see {@link Measurement}.\n * An expression is given as\n * <ul>\n * <li> array starting with an operator as first element, followed\n * by one or more operands,\n * <li> number.\n * </ul>\n * <p>\n * Possible operators are:\n * <ul>\n * <li> '+', '-', '*', '/': binary operators\n * <li> 'Area', 'Radius', 'Value', 'V', 'L': arbitrary methods of JSXGraph elements, supplied as strings.\n * <li> 'exec': call a function\n * </ul>\n * <p>\n * Possible operands are:\n * <ul>\n * <li> numbers\n * <li> strings\n * <li> JSXGraph elements in case the operator is a method. Example: ['Area', circle] calls\n * the method circle.Area().\n * <li> prefix expressions (for binary operators)\n * <li> 'exec': call functions. Example: ['exec', 'sin', ['V', slider]] computes 'Math.sin(slider.Value())'.\n * As functions only functions in Math or JXG.Math are allowed.\n * </ul>\n * @namespace\n *\n * @example\n *   ['+', 100, 200]\n * @example\n * var p1 = board.create('point', [1, 1]);\n * var p2 = board.create('point', [1, 3]);\n * var seg = board.create('segment', [[-2,-3], [-2, 3]]);\n *\n * // Valid prefix expression: ['L', seg]\n *\n * @example\n * var p1 = board.create('point', [1, 1]);\n * var p2 = board.create('point', [1, 3]);\n * var seg = board.create('segment', [[-2,-3], [-2, 3]]);\n * var ci = board.create('circle', [p1, 7]);\n *\n * // Valid prefix expression:  ['+', ['Radius', ci], ['L', seg]]\n *\n * @example\n * var ang = board.create('angle', [[4, 0], [0, 0], [2, 2]]);\n * // Valid prefix expression:  ['V', ang, 'degrees']);\n */\nJXG.PrefixParser = {\n  /**\n   * Parse a prefix expression and apply an action.\n   * @param {array|number} term Expression\n   * @param {String} action Determines what to do. So far, the only\n   * action available is 'execute', which evaluates the expression.\n   * @returns {Number} What ever the action does.\n   */\n  parse: function (term, action) {\n    var method, i, le, res, fun, v;\n    if (Type.isNumber(term) || Type.isString(term)) {\n      return term;\n    }\n    if (!Type.isArray(term) || term.length < 2) {\n      throw new Error('prefixParser.parse: term is not an array, number or string');\n    }\n    method = term[0];\n    le = term.length;\n    if (action === 'execute') {\n      if (Type.isInArray(['+', '-', '*', '/'], method)) {\n        res = this.parse(term[1], action);\n        for (i = 2; i < le; i++) {\n          v = this.parse(term[i], action);\n          switch (method) {\n            case '+':\n              res += v;\n              break;\n            case '-':\n              res -= v;\n              break;\n            case '*':\n              res *= v;\n              break;\n            case '/':\n              res /= v;\n              break;\n            default:\n          }\n        }\n      } else if (method === 'exec') {\n        fun = term[1];\n        v = [];\n        for (i = 2; i < le; i++) {\n          v.push(this.parse(term[i], action));\n        }\n        if (Type.exists(Math[fun])) {\n          res = Math[fun].apply(this, v);\n        } else if (Type.exists(Mat[fun])) {\n          res = Mat[fun].apply(this, v);\n        } else {\n          throw new Error(\"PrefixParser.parse: \" + fun + \" is not allowed\");\n        }\n      } else {\n        // Allow shortcut 'V' for 'Value'\n        fun = term[0];\n        if (fun === 'V') {\n          fun = 'Value';\n        }\n        if (!Type.exists(term[1][fun])) {\n          throw new Error(\"PrefixParser.parse: \" + fun + \" is not a method of \" + term[1]);\n        }\n        v = [];\n        for (i = 2; i < le; i++) {\n          v.push(this.parse(term[i], action));\n        }\n        res = term[1][fun].apply(term[1], v);\n      }\n    }\n    return res;\n  },\n  /**\n   * Determine the dimension of the resulting value, i.e. ['L', obj] as well as\n   * ['+', ['L', obj1], ['L', obj2]] have dimension 1.\n   * <p>\n   * ['+', ['Area', obj1], ['L', obj2]] will retrun NaN, because the two\n   * operands have conflicting dimensions.\n   * <p>\n   * If an element is a measurement element, then it's dimension can be set as attribute.\n   * This overrules the computed dimension.\n   *\n   * @param {Array|Number} term Prefix expression\n   * @returns Number\n   */\n  dimension: function (term) {\n    var method, i, le, res, fun, d, v, unit;\n    if (Type.isNumber(term)) {\n      return 0;\n    }\n    if (!Type.isArray(term) || term.length < 2) {\n      throw new Error('PrefixParser.dimension: term is not an array');\n    }\n    method = term[0];\n    le = term.length;\n    if (Type.isInArray(['+', '-', '*', '/'], method)) {\n      res = this.dimension(term[1]);\n      for (i = 2; i < le; i++) {\n        v = this.dimension(term[i]);\n        switch (method) {\n          case '+':\n            if (v !== res) {\n              res = NaN;\n            }\n            break;\n          case '-':\n            if (v !== res) {\n              res = NaN;\n            }\n            break;\n          case '*':\n            res += v;\n            break;\n          case '/':\n            res -= v;\n            break;\n          default:\n        }\n      }\n    } else if (method === 'exec') {\n      if (term[2].type === Type.OBJECT_TYPE_MEASUREMENT) {\n        res = term[2].Dimension();\n        // If attribute \"dim\" is set, this overrules anything else.\n        if (Type.exists(term[2].visProp.dim)) {\n          d = Type.evaluate(term[2].visProp.dim);\n          if (d !== null) {\n            res = d;\n          }\n        }\n      } else {\n        res = 0;\n      }\n    } else {\n      // Allow shortcut 'V' for 'Value'\n      fun = term[0];\n      switch (fun) {\n        case 'L':\n        case 'Length':\n        case 'Perimeter':\n        case 'Radius':\n        case 'R':\n          res = 1;\n          break;\n        case 'Area':\n        case 'A':\n          res = 2;\n          break;\n        default:\n          // 'V', 'Value'\n          if (term[1].type === Type.OBJECT_TYPE_MEASUREMENT) {\n            res = term[1].Dimension();\n            // If attribute \"dim\" is set, this overrules anything else.\n            if (Type.exists(term[1].visProp.dim)) {\n              d = Type.evaluate(term[1].visProp.dim);\n              if (d !== null) {\n                res = d;\n              }\n            }\n          } else {\n            res = 0;\n            if (fun === 'Value' || fun === 'V') {\n              // The Value method of sector, angle and arc does not have the same dimension\n              // for all units.\n              if ([Const.OBJECT_TYPE_ARC, Const.OBJECT_TYPE_SECTOR, Const.OBJECT_TYPE_ANGLE].indexOf(term[1].type) >= 0) {\n                unit = '';\n                if (term.length === 3 && Type.isString(term[2])) {\n                  unit = term[2].toLowerCase();\n                }\n                if (unit === '') {\n                  // Default values:\n                  if (term[1].type === Const.OBJECT_TYPE_ANGLE) {\n                    // Default for angle.Value() is radians, i.e. dim 0\n                    res = 0;\n                  } else {\n                    // Default for sector|arc.Value() is length, i.e. dim 1\n                    res = 1;\n                  }\n                } else if (unit.indexOf('len') === 0) {\n                  // Length has dim 1\n                  res = 1;\n                } else {\n                  // Angles in various units has dimension 0\n                  res = 0;\n                }\n              }\n            }\n          }\n      }\n    }\n    return res;\n  },\n  /**\n   * Convert a prefix expression into a new prefix expression in which\n   * JSXGraph elements have been replaced by their ids.\n   *\n   * @param {Array|Number} term\n   * @returns {Array|Number}\n   */\n  toPrefix: function (term) {\n    var method, i, le, res;\n    if (Type.isNumber(term)) {\n      return term;\n    }\n    if (!Type.isArray(term) || term.length < 2) {\n      throw new Error('PrefixParser.toPrefix: term is not an array');\n    }\n    method = term[0];\n    le = term.length;\n    res = [method];\n    for (i = 1; i < le; i++) {\n      if (Type.isInArray(['+', '-', '*', '/'], method)) {\n        res.push(this.toPrefix(term[i]));\n      } else {\n        if (method === 'V' && term[i].type === Type.OBJECT_TYPE_MEASUREMENT) {\n          res = term[i].toPrefix();\n        } else if (method === 'exec') {\n          if (i === 1) {\n            res.push(term[i]);\n          } else {\n            res.push(this.toPrefix(term[i]));\n          }\n        } else {\n          res = [method, term[i].id];\n        }\n      }\n    }\n    return res;\n  },\n  /**\n   * Determine parent elements of a prefix expression.\n   * @param {Array|Number} term prefix expression\n   * @returns Array\n   * @private\n   */\n  getParents: function (term) {\n    var method, i, le, res;\n    if (Type.isNumber(term)) {\n      return [];\n    }\n    if (!Type.isArray(term) || term.length < 2) {\n      throw new Error('PrefixParser.getParents: term is not an array');\n    }\n    method = term[0];\n    le = term.length;\n    res = [];\n    for (i = 1; i < le; i++) {\n      if (Type.isInArray(['+', '-', '*', '/'], method)) {\n        res = res.concat(this.getParents(term[i]));\n      } else {\n        if (method === 'V' && term[i].type === Type.OBJECT_TYPE_MEASUREMENT) {\n          res = res.concat(term[i].getParents());\n        } else if (method === 'exec') {\n          if (i > 1) {\n            res = res.concat(this.getParents(term[i]));\n          }\n        } else {\n          res.push(term[i]);\n        }\n      }\n    }\n    return res;\n  }\n};\nexport default JXG.PrefixParser;","map":{"version":3,"names":["JXG","Type","Mat","Const","PrefixParser","parse","term","action","method","i","le","res","fun","v","isNumber","isString","isArray","length","Error","isInArray","push","exists","Math","apply","dimension","d","unit","NaN","type","OBJECT_TYPE_MEASUREMENT","Dimension","visProp","dim","evaluate","OBJECT_TYPE_ARC","OBJECT_TYPE_SECTOR","OBJECT_TYPE_ANGLE","indexOf","toLowerCase","toPrefix","id","getParents","concat"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/parser/prefix.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/**\n * @fileoverview Simple prefix parser for measurements and expressions of measurements.\n * An expression is given as\n * <ul>\n * <li> array starting with an operator as first element, followed\n * by one or more operands,\n * <li> number.\n * </ul>\n * <p>\n * Possible operands are:\n * <ul>\n * <li> '+', '-', '*', '/'\n * </ul>\n *\n * @example\n *\n */\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\nimport Const from \"../base/constants\";\n\n/**\n * Prefix expression parser, i.e. a poor man's parser.\n * This is a simple prefix parser for measurements and expressions of measurements,\n * see {@link Measurement}.\n * An expression is given as\n * <ul>\n * <li> array starting with an operator as first element, followed\n * by one or more operands,\n * <li> number.\n * </ul>\n * <p>\n * Possible operators are:\n * <ul>\n * <li> '+', '-', '*', '/': binary operators\n * <li> 'Area', 'Radius', 'Value', 'V', 'L': arbitrary methods of JSXGraph elements, supplied as strings.\n * <li> 'exec': call a function\n * </ul>\n * <p>\n * Possible operands are:\n * <ul>\n * <li> numbers\n * <li> strings\n * <li> JSXGraph elements in case the operator is a method. Example: ['Area', circle] calls\n * the method circle.Area().\n * <li> prefix expressions (for binary operators)\n * <li> 'exec': call functions. Example: ['exec', 'sin', ['V', slider]] computes 'Math.sin(slider.Value())'.\n * As functions only functions in Math or JXG.Math are allowed.\n * </ul>\n * @namespace\n *\n * @example\n *   ['+', 100, 200]\n * @example\n * var p1 = board.create('point', [1, 1]);\n * var p2 = board.create('point', [1, 3]);\n * var seg = board.create('segment', [[-2,-3], [-2, 3]]);\n *\n * // Valid prefix expression: ['L', seg]\n *\n * @example\n * var p1 = board.create('point', [1, 1]);\n * var p2 = board.create('point', [1, 3]);\n * var seg = board.create('segment', [[-2,-3], [-2, 3]]);\n * var ci = board.create('circle', [p1, 7]);\n *\n * // Valid prefix expression:  ['+', ['Radius', ci], ['L', seg]]\n *\n * @example\n * var ang = board.create('angle', [[4, 0], [0, 0], [2, 2]]);\n * // Valid prefix expression:  ['V', ang, 'degrees']);\n */\nJXG.PrefixParser = {\n    /**\n     * Parse a prefix expression and apply an action.\n     * @param {array|number} term Expression\n     * @param {String} action Determines what to do. So far, the only\n     * action available is 'execute', which evaluates the expression.\n     * @returns {Number} What ever the action does.\n     */\n    parse: function (term, action) {\n        var method, i, le, res, fun, v;\n\n        if (Type.isNumber(term) || Type.isString(term)) {\n            return term;\n        }\n        if (!Type.isArray(term) || term.length < 2) {\n            throw new Error('prefixParser.parse: term is not an array, number or string');\n        }\n\n        method = term[0];\n        le = term.length;\n\n        if (action === 'execute') {\n            if (Type.isInArray(['+', '-', '*', '/'], method)) {\n\n                res = this.parse(term[1], action);\n                for (i = 2; i < le; i++) {\n                    v = this.parse(term[i], action);\n                    switch (method) {\n                        case '+':\n                            res += v;\n                            break;\n                        case '-':\n                            res -= v;\n                            break;\n                        case '*':\n                            res *= v;\n                            break;\n                        case '/':\n                            res /= v;\n                            break;\n                        default:\n                    }\n                }\n            } else if (method === 'exec') {\n                fun = term[1];\n                v = [];\n                for (i = 2; i < le; i++) {\n                    v.push(this.parse(term[i], action));\n                }\n                if (Type.exists(Math[fun])) {\n                    res = Math[fun].apply(this, v);\n                } else if (Type.exists(Mat[fun])) {\n                    res = Mat[fun].apply(this, v);\n                } else {\n                    throw new Error(\"PrefixParser.parse: \" + fun + \" is not allowed\");\n                }\n            } else {\n                // Allow shortcut 'V' for 'Value'\n                fun = term[0];\n                if (fun === 'V') {\n                    fun = 'Value';\n                }\n\n                if (!Type.exists(term[1][fun])) {\n                    throw new Error(\"PrefixParser.parse: \" + fun + \" is not a method of \" + term[1]);\n                }\n                v = [];\n                for (i = 2; i < le; i++) {\n                    v.push(this.parse(term[i], action));\n                }\n                res = term[1][fun].apply(term[1], v);\n            }\n        }\n\n        return res;\n    },\n\n    /**\n     * Determine the dimension of the resulting value, i.e. ['L', obj] as well as\n     * ['+', ['L', obj1], ['L', obj2]] have dimension 1.\n     * <p>\n     * ['+', ['Area', obj1], ['L', obj2]] will retrun NaN, because the two\n     * operands have conflicting dimensions.\n     * <p>\n     * If an element is a measurement element, then it's dimension can be set as attribute.\n     * This overrules the computed dimension.\n     *\n     * @param {Array|Number} term Prefix expression\n     * @returns Number\n     */\n    dimension: function (term) {\n        var method, i, le, res, fun, d, v, unit;\n\n        if (Type.isNumber(term)) {\n            return 0;\n        }\n        if (!Type.isArray(term) || term.length < 2) {\n            throw new Error('PrefixParser.dimension: term is not an array');\n        }\n\n        method = term[0];\n        le = term.length;\n\n        if (Type.isInArray(['+', '-', '*', '/'], method)) {\n\n            res = this.dimension(term[1]);\n            for (i = 2; i < le; i++) {\n                v = this.dimension(term[i]);\n                switch (method) {\n                    case '+':\n                        if (v !== res) {\n                            res = NaN;\n                        }\n                        break;\n                    case '-':\n                        if (v !== res) {\n                            res = NaN;\n                        }\n                        break;\n                    case '*':\n                        res += v;\n                        break;\n                    case '/':\n                        res -= v;\n                        break;\n                    default:\n                }\n            }\n\n        } else if (method === 'exec') {\n            if (term[2].type === Type.OBJECT_TYPE_MEASUREMENT) {\n                res = term[2].Dimension();\n                // If attribute \"dim\" is set, this overrules anything else.\n                if (Type.exists(term[2].visProp.dim)) {\n                    d = Type.evaluate(term[2].visProp.dim);\n                    if (d !== null) {\n                        res = d;\n                    }\n                }\n            } else {\n                res = 0;\n            }\n        } else {\n            // Allow shortcut 'V' for 'Value'\n            fun = term[0];\n\n            switch (fun) {\n                case 'L':\n                case 'Length':\n                case 'Perimeter':\n                case 'Radius':\n                case 'R':\n                    res = 1;\n                    break;\n                case 'Area':\n                case 'A':\n                    res = 2;\n                    break;\n                default: // 'V', 'Value'\n                    if (term[1].type === Type.OBJECT_TYPE_MEASUREMENT) {\n                        res = term[1].Dimension();\n                        // If attribute \"dim\" is set, this overrules anything else.\n                        if (Type.exists(term[1].visProp.dim)) {\n                            d = Type.evaluate(term[1].visProp.dim);\n                            if (d !== null) {\n                                res = d;\n                            }\n                        }\n                    } else {\n                        res = 0;\n\n                        if (fun === 'Value' || fun === 'V') {\n                            // The Value method of sector, angle and arc does not have the same dimension\n                            // for all units.\n                            if ([Const.OBJECT_TYPE_ARC, Const.OBJECT_TYPE_SECTOR, Const.OBJECT_TYPE_ANGLE].indexOf(term[1].type) >= 0) {\n                                unit = '';\n                                if (term.length === 3 && Type.isString(term[2])) {\n                                    unit = term[2].toLowerCase();\n                                }\n                                if (unit === '') {\n                                    // Default values:\n                                    if (term[1].type === Const.OBJECT_TYPE_ANGLE) {\n                                        // Default for angle.Value() is radians, i.e. dim 0\n                                        res = 0;\n                                    } else {\n                                        // Default for sector|arc.Value() is length, i.e. dim 1\n                                        res = 1;\n                                    }\n                                } else if (unit.indexOf('len') === 0) {\n                                    // Length has dim 1\n                                    res = 1;\n                                } else {\n                                    // Angles in various units has dimension 0\n                                    res = 0;\n                                }\n                            }\n                        }\n                    }\n            }\n        }\n\n        return res;\n    },\n\n    /**\n     * Convert a prefix expression into a new prefix expression in which\n     * JSXGraph elements have been replaced by their ids.\n     *\n     * @param {Array|Number} term\n     * @returns {Array|Number}\n     */\n    toPrefix: function (term) {\n        var method, i, le, res;\n\n        if (Type.isNumber(term)) {\n            return term;\n        }\n        if (!Type.isArray(term) || term.length < 2) {\n            throw new Error('PrefixParser.toPrefix: term is not an array');\n        }\n\n        method = term[0];\n        le = term.length;\n        res = [method];\n\n        for (i = 1; i < le; i++) {\n            if (Type.isInArray(['+', '-', '*', '/'], method)) {\n                res.push(this.toPrefix(term[i]));\n            } else {\n                if (method === 'V' && term[i].type === Type.OBJECT_TYPE_MEASUREMENT) {\n                    res = term[i].toPrefix();\n                } else if (method === 'exec') {\n                    if (i === 1) {\n                        res.push(term[i]);\n                    } else {\n                        res.push(this.toPrefix(term[i]));\n                    }\n                } else {\n                    res = [method, term[i].id];\n                }\n            }\n        }\n\n        return res;\n    },\n\n    /**\n     * Determine parent elements of a prefix expression.\n     * @param {Array|Number} term prefix expression\n     * @returns Array\n     * @private\n     */\n    getParents: function (term) {\n        var method, i, le, res;\n\n        if (Type.isNumber(term)) {\n            return [];\n        }\n        if (!Type.isArray(term) || term.length < 2) {\n            throw new Error('PrefixParser.getParents: term is not an array');\n        }\n\n        method = term[0];\n        le = term.length;\n        res = [];\n\n        for (i = 1; i < le; i++) {\n            if (Type.isInArray(['+', '-', '*', '/'], method)) {\n                res = res.concat(this.getParents(term[i]));\n            } else {\n                if (method === 'V' && term[i].type === Type.OBJECT_TYPE_MEASUREMENT) {\n                    res = res.concat(term[i].getParents());\n                } else if (method === 'exec') {\n                    if (i > 1) {\n                        res = res.concat(this.getParents(term[i]));\n                    }\n                } else {\n                    res.push(term[i]);\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nexport default JXG.PrefixParser;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAOA,GAAG,MAAM,QAAQ;AACxB,OAAOC,IAAI,MAAM,eAAe;AAChC,OAAOC,GAAG,MAAM,cAAc;AAC9B,OAAOC,KAAK,MAAM,mBAAmB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,GAAG,CAACI,YAAY,GAAG;EACf;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,KAAK,EAAE,SAAAA,CAAUC,IAAI,EAAEC,MAAM,EAAE;IAC3B,IAAIC,MAAM,EAAEC,CAAC,EAAEC,EAAE,EAAEC,GAAG,EAAEC,GAAG,EAAEC,CAAC;IAE9B,IAAIZ,IAAI,CAACa,QAAQ,CAACR,IAAI,CAAC,IAAIL,IAAI,CAACc,QAAQ,CAACT,IAAI,CAAC,EAAE;MAC5C,OAAOA,IAAI;IACf;IACA,IAAI,CAACL,IAAI,CAACe,OAAO,CAACV,IAAI,CAAC,IAAIA,IAAI,CAACW,MAAM,GAAG,CAAC,EAAE;MACxC,MAAM,IAAIC,KAAK,CAAC,4DAA4D,CAAC;IACjF;IAEAV,MAAM,GAAGF,IAAI,CAAC,CAAC,CAAC;IAChBI,EAAE,GAAGJ,IAAI,CAACW,MAAM;IAEhB,IAAIV,MAAM,KAAK,SAAS,EAAE;MACtB,IAAIN,IAAI,CAACkB,SAAS,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EAAEX,MAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}