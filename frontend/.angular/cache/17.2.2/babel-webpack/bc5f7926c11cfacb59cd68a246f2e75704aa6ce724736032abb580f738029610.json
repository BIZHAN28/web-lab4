{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, Float32Array: true */\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\n/**\n * @fileoverview In this file the namespace JXG.Math is defined, which is the base namespace\n * for namespaces like JXG.Math.Numerics, JXG.Math.Plot, JXG.Math.Statistics, JXG.Math.Clip etc.\n */\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\nvar undef,\n  /*\n   * Dynamic programming approach for recursive functions.\n   * From \"Speed up your JavaScript, Part 3\" by Nicholas C. Zakas.\n   * @see JXG.Math.factorial\n   * @see JXG.Math.binomial\n   * http://blog.thejit.org/2008/09/05/memoization-in-javascript/\n   *\n   * This method is hidden, because it is only used in JXG.Math. If someone wants\n   * to use it in JSXGraph outside of JXG.Math, it should be moved to jsxgraph.js\n   */\n  memoizer = function (f) {\n    var cache, join;\n    if (f.memo) {\n      return f.memo;\n    }\n    cache = {};\n    join = Array.prototype.join;\n    f.memo = function () {\n      var key = join.call(arguments);\n\n      // Seems to be a bit faster than \"if (a in b)\"\n      return cache[key] !== undef ? cache[key] : cache[key] = f.apply(this, arguments);\n    };\n    return f.memo;\n  };\n\n/**\n * Math namespace. Contains mathematics related methods which are\n * specific to JSXGraph or which extend the JavaScript Math class.\n * @namespace\n */\nJXG.Math = {\n  /**\n   * eps defines the closeness to zero. If the absolute value of a given number is smaller\n   * than eps, it is considered to be equal to zero.\n   * @type Number\n   */\n  eps: 0.000001,\n  /**\n   * Determine the relative difference between two numbers.\n   * @param  {Number} a First number\n   * @param  {Number} b Second number\n   * @returns {Number}  Relative difference between a and b: |a-b| / max(|a|, |b|)\n   */\n  relDif: function (a, b) {\n    var c = Math.abs(a),\n      d = Math.abs(b);\n    d = Math.max(c, d);\n    return d === 0.0 ? 0.0 : Math.abs(a - b) / d;\n  },\n  /**\n   * The JavaScript implementation of the % operator returns the symmetric modulo.\n   * mod and \"%\" are both identical if a >= 0 and m >= 0 but the results differ if a or m < 0.\n   * @param {Number} a\n   * @param {Number} m\n   * @returns {Number} Mathematical modulo <tt>a mod m</tt>\n   */\n  mod: function (a, m) {\n    return a - Math.floor(a / m) * m;\n  },\n  /**\n   * Initializes a vector as an array with the coefficients set to the given value resp. zero.\n   * @param {Number} n Length of the vector\n   * @param {Number} [init=0] Initial value for each coefficient\n   * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a\n   * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.\n   */\n  vector: function (n, init) {\n    var r, i;\n    init = init || 0;\n    r = [];\n    for (i = 0; i < n; i++) {\n      r[i] = init;\n    }\n    return r;\n  },\n  /**\n   * Initializes a matrix as an array of rows with the given value.\n   * @param {Number} n Number of rows\n   * @param {Number} [m=n] Number of columns\n   * @param {Number} [init=0] Initial value for each coefficient\n   * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a\n   * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.\n   */\n  matrix: function (n, m, init) {\n    var r, i, j;\n    init = init || 0;\n    m = m || n;\n    r = [];\n    for (i = 0; i < n; i++) {\n      r[i] = [];\n      for (j = 0; j < m; j++) {\n        r[i][j] = init;\n      }\n    }\n    return r;\n  },\n  /**\n   * Generates an identity matrix. If n is a number and m is undefined or not a number, a square matrix is generated,\n   * if n and m are both numbers, an nxm matrix is generated.\n   * @param {Number} n Number of rows\n   * @param {Number} [m=n] Number of columns\n   * @returns {Array} A square matrix of length <tt>n</tt> with all coefficients equal to 0 except a_(i,i), i out of (1, ..., n), if <tt>m</tt> is undefined or not a number\n   * or a <tt>n</tt> times <tt>m</tt>-matrix with a_(i,j) = 0 and a_(i,i) = 1 if m is a number.\n   */\n  identity: function (n, m) {\n    var r, i;\n    if (m === undef && typeof m !== \"number\") {\n      m = n;\n    }\n    r = this.matrix(n, m);\n    for (i = 0; i < Math.min(n, m); i++) {\n      r[i][i] = 1;\n    }\n    return r;\n  },\n  /**\n   * Generates a 4x4 matrix for 3D to 2D projections.\n   * @param {Number} l Left\n   * @param {Number} r Right\n   * @param {Number} t Top\n   * @param {Number} b Bottom\n   * @param {Number} n Near\n   * @param {Number} f Far\n   * @returns {Array} 4x4 Matrix\n   */\n  frustum: function (l, r, b, t, n, f) {\n    var ret = this.matrix(4, 4);\n    ret[0][0] = n * 2 / (r - l);\n    ret[0][1] = 0;\n    ret[0][2] = (r + l) / (r - l);\n    ret[0][3] = 0;\n    ret[1][0] = 0;\n    ret[1][1] = n * 2 / (t - b);\n    ret[1][2] = (t + b) / (t - b);\n    ret[1][3] = 0;\n    ret[2][0] = 0;\n    ret[2][1] = 0;\n    ret[2][2] = -(f + n) / (f - n);\n    ret[2][3] = -(f * n * 2) / (f - n);\n    ret[3][0] = 0;\n    ret[3][1] = 0;\n    ret[3][2] = -1;\n    ret[3][3] = 0;\n    return ret;\n  },\n  /**\n   * Generates a 4x4 matrix for 3D to 2D projections.\n   * @param {Number} fov Field of view in vertical direction, given in rad.\n   * @param {Number} ratio Aspect ratio of the projection plane.\n   * @param {Number} n Near\n   * @param {Number} f Far\n   * @returns {Array} 4x4 Projection Matrix\n   */\n  projection: function (fov, ratio, n, f) {\n    var t = n * Math.tan(fov / 2),\n      r = t * ratio;\n    return this.frustum(-r, r, -t, t, n, f);\n  },\n  /**\n   * Multiplies a vector vec to a matrix mat: mat * vec. The matrix is interpreted by this function as an array of rows. Please note: This\n   * function does not check if the dimensions match.\n   * @param {Array} mat Two dimensional array of numbers. The inner arrays describe the columns, the outer ones the matrix' rows.\n   * @param {Array} vec Array of numbers\n   * @returns {Array} Array of numbers containing the result\n   * @example\n   * var A = [[2, 1],\n   *          [1, 3]],\n   *     b = [4, 5],\n   *     c;\n   * c = JXG.Math.matVecMult(A, b)\n   * // c === [13, 19];\n   */\n  matVecMult: function (mat, vec) {\n    var i,\n      s,\n      k,\n      m = mat.length,\n      n = vec.length,\n      res = [];\n    if (n === 3) {\n      for (i = 0; i < m; i++) {\n        res[i] = mat[i][0] * vec[0] + mat[i][1] * vec[1] + mat[i][2] * vec[2];\n      }\n    } else {\n      for (i = 0; i < m; i++) {\n        s = 0;\n        for (k = 0; k < n; k++) {\n          s += mat[i][k] * vec[k];\n        }\n        res[i] = s;\n      }\n    }\n    return res;\n  },\n  /**\n   * Computes the product of the two matrices mat1*mat2.\n   * @param {Array} mat1 Two dimensional array of numbers\n   * @param {Array} mat2 Two dimensional array of numbers\n   * @returns {Array} Two dimensional Array of numbers containing result\n   */\n  matMatMult: function (mat1, mat2) {\n    var i,\n      j,\n      s,\n      k,\n      m = mat1.length,\n      n = m > 0 ? mat2[0].length : 0,\n      m2 = mat2.length,\n      res = this.matrix(m, n);\n    for (i = 0; i < m; i++) {\n      for (j = 0; j < n; j++) {\n        s = 0;\n        for (k = 0; k < m2; k++) {\n          s += mat1[i][k] * mat2[k][j];\n        }\n        res[i][j] = s;\n      }\n    }\n    return res;\n  },\n  /**\n   * Transposes a matrix given as a two dimensional array.\n   * @param {Array} M The matrix to be transposed\n   * @returns {Array} The transpose of M\n   */\n  transpose: function (M) {\n    var MT, i, j, m, n;\n\n    // number of rows of M\n    m = M.length;\n    // number of columns of M\n    n = M.length > 0 ? M[0].length : 0;\n    MT = this.matrix(n, m);\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < m; j++) {\n        MT[i][j] = M[j][i];\n      }\n    }\n    return MT;\n  },\n  /**\n   * Compute the inverse of an nxn matrix with Gauss elimination.\n   * @param {Array} Ain\n   * @returns {Array} Inverse matrix of Ain\n   */\n  inverse: function (Ain) {\n    var i,\n      j,\n      k,\n      s,\n      ma,\n      r,\n      swp,\n      n = Ain.length,\n      A = [],\n      p = [],\n      hv = [];\n    for (i = 0; i < n; i++) {\n      A[i] = [];\n      for (j = 0; j < n; j++) {\n        A[i][j] = Ain[i][j];\n      }\n      p[i] = i;\n    }\n    for (j = 0; j < n; j++) {\n      // pivot search:\n      ma = Math.abs(A[j][j]);\n      r = j;\n      for (i = j + 1; i < n; i++) {\n        if (Math.abs(A[i][j]) > ma) {\n          ma = Math.abs(A[i][j]);\n          r = i;\n        }\n      }\n\n      // Singular matrix\n      if (ma <= this.eps) {\n        return [];\n      }\n\n      // swap rows:\n      if (r > j) {\n        for (k = 0; k < n; k++) {\n          swp = A[j][k];\n          A[j][k] = A[r][k];\n          A[r][k] = swp;\n        }\n        swp = p[j];\n        p[j] = p[r];\n        p[r] = swp;\n      }\n\n      // transformation:\n      s = 1.0 / A[j][j];\n      for (i = 0; i < n; i++) {\n        A[i][j] *= s;\n      }\n      A[j][j] = s;\n      for (k = 0; k < n; k++) {\n        if (k !== j) {\n          for (i = 0; i < n; i++) {\n            if (i !== j) {\n              A[i][k] -= A[i][j] * A[j][k];\n            }\n          }\n          A[j][k] = -s * A[j][k];\n        }\n      }\n    }\n\n    // swap columns:\n    for (i = 0; i < n; i++) {\n      for (k = 0; k < n; k++) {\n        hv[p[k]] = A[i][k];\n      }\n      for (k = 0; k < n; k++) {\n        A[i][k] = hv[k];\n      }\n    }\n    return A;\n  },\n  /**\n   * Inner product of two vectors a and b. n is the length of the vectors.\n   * @param {Array} a Vector\n   * @param {Array} b Vector\n   * @param {Number} [n] Length of the Vectors. If not given the length of the first vector is taken.\n   * @returns {Number} The inner product of a and b.\n   */\n  innerProduct: function (a, b, n) {\n    var i,\n      s = 0;\n    if (n === undef || !Type.isNumber(n)) {\n      n = a.length;\n    }\n    for (i = 0; i < n; i++) {\n      s += a[i] * b[i];\n    }\n    return s;\n  },\n  /**\n   * Calculates the cross product of two vectors both of length three.\n   * In case of homogeneous coordinates this is either\n   * <ul>\n   * <li>the intersection of two lines</li>\n   * <li>the line through two points</li>\n   * </ul>\n   * @param {Array} c1 Homogeneous coordinates of line or point 1\n   * @param {Array} c2 Homogeneous coordinates of line or point 2\n   * @returns {Array} vector of length 3: homogeneous coordinates of the resulting point / line.\n   */\n  crossProduct: function (c1, c2) {\n    return [c1[1] * c2[2] - c1[2] * c2[1], c1[2] * c2[0] - c1[0] * c2[2], c1[0] * c2[1] - c1[1] * c2[0]];\n  },\n  /**\n   * Euclidean norm of a vector.\n   *\n   * @param {Array} a Array containing a vector.\n   * @param {Number} n (Optional) length of the array.\n   * @returns {Number} Euclidean norm of the vector.\n   */\n  norm: function (a, n) {\n    var i,\n      sum = 0.0;\n    if (n === undef || !Type.isNumber(n)) {\n      n = a.length;\n    }\n    for (i = 0; i < n; i++) {\n      sum += a[i] * a[i];\n    }\n    return Math.sqrt(sum);\n  },\n  /**\n   * Compute a * x + y for a scalar a and vectors x and y.\n   *\n   * @param {Number} a\n   * @param {Array} x\n   * @param {Array} y\n   * @returns\n   */\n  axpy: function (a, x, y) {\n    var i,\n      le = x.length,\n      p = [];\n    for (i = 0; i < le; i++) {\n      p[i] = a * x[i] + y[i];\n    }\n    return p;\n  },\n  /**\n   * Compute the factorial of a positive integer. If a non-integer value\n   * is given, the fraction will be ignored.\n   * @function\n   * @param {Number} n\n   * @returns {Number} n! = n*(n-1)*...*2*1\n   */\n  factorial: memoizer(function (n) {\n    if (n < 0) {\n      return NaN;\n    }\n    n = Math.floor(n);\n    if (n === 0 || n === 1) {\n      return 1;\n    }\n    return n * this.factorial(n - 1);\n  }),\n  /**\n   * Computes the binomial coefficient n over k.\n   * @function\n   * @param {Number} n Fraction will be ignored\n   * @param {Number} k Fraction will be ignored\n   * @returns {Number} The binomial coefficient n over k\n   */\n  binomial: memoizer(function (n, k) {\n    var b, i;\n    if (k > n || k < 0) {\n      return NaN;\n    }\n    k = Math.round(k);\n    n = Math.round(n);\n    if (k === 0 || k === n) {\n      return 1;\n    }\n    b = 1;\n    for (i = 0; i < k; i++) {\n      b *= n - i;\n      b /= i + 1;\n    }\n    return b;\n  }),\n  /**\n   * Calculates the cosine hyperbolicus of x.\n   * @function\n   * @param {Number} x The number the cosine hyperbolicus will be calculated of.\n   * @returns {Number} Cosine hyperbolicus of the given value.\n   */\n  cosh: Math.cosh || function (x) {\n    return (Math.exp(x) + Math.exp(-x)) * 0.5;\n  },\n  /**\n   * Sine hyperbolicus of x.\n   * @function\n   * @param {Number} x The number the sine hyperbolicus will be calculated of.\n   * @returns {Number} Sine hyperbolicus of the given value.\n   */\n  sinh: Math.sinh || function (x) {\n    return (Math.exp(x) - Math.exp(-x)) * 0.5;\n  },\n  /**\n   * Hyperbolic arc-cosine of a number.\n   *\n   * @param {Number} x\n   * @returns {Number}\n   */\n  acosh: Math.acosh || function (x) {\n    return Math.log(x + Math.sqrt(x * x - 1));\n  },\n  /**\n   * Hyperbolic arcsine of a number\n   * @param {Number} x\n   * @returns {Number}\n   */\n  asinh: Math.asinh || function (x) {\n    if (x === -Infinity) {\n      return x;\n    }\n    return Math.log(x + Math.sqrt(x * x + 1));\n  },\n  /**\n   * Computes the cotangent of x.\n   * @function\n   * @param {Number} x The number the cotangent will be calculated of.\n   * @returns {Number} Cotangent of the given value.\n   */\n  cot: function (x) {\n    return 1 / Math.tan(x);\n  },\n  /**\n   * Computes the inverse cotangent of x.\n   * @param {Number} x The number the inverse cotangent will be calculated of.\n   * @returns {Number} Inverse cotangent of the given value.\n   */\n  acot: function (x) {\n    return (x >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(x);\n  },\n  /**\n   * Compute n-th real root of a real number. n must be strictly positive integer.\n   * If n is odd, the real n-th root exists and is negative.\n   * For n even, for negative valuees of x NaN is returned\n   * @param  {Number} x radicand. Must be non-negative, if n even.\n   * @param  {Number} n index of the root. must be strictly positive integer.\n   * @returns {Number} returns real root or NaN\n   *\n   * @example\n   * nthroot(16, 4): 2\n   * nthroot(-27, 3): -3\n   * nthroot(-4, 2): NaN\n   */\n  nthroot: function (x, n) {\n    var inv = 1 / n;\n    if (n <= 0 || Math.floor(n) !== n) {\n      return NaN;\n    }\n    if (x === 0.0) {\n      return 0.0;\n    }\n    if (x > 0) {\n      return Math.exp(inv * Math.log(x));\n    }\n\n    // From here on, x is negative\n    if (n % 2 === 1) {\n      return -Math.exp(inv * Math.log(-x));\n    }\n\n    // x negative, even root\n    return NaN;\n  },\n  /**\n   * Computes cube root of real number\n   * Polyfill for Math.cbrt().\n   *\n   * @function\n   * @param  {Number} x Radicand\n   * @returns {Number} Cube root of x.\n   */\n  cbrt: Math.cbrt || function (x) {\n    return this.nthroot(x, 3);\n  },\n  /**\n   * Compute base to the power of exponent.\n   * @param {Number} base\n   * @param {Number} exponent\n   * @returns {Number} base to the power of exponent.\n   */\n  pow: function (base, exponent) {\n    if (base === 0) {\n      if (exponent === 0) {\n        return 1;\n      }\n      return 0;\n    }\n\n    // exponent is an integer\n    if (Math.floor(exponent) === exponent) {\n      return Math.pow(base, exponent);\n    }\n\n    // exponent is not an integer\n    if (base > 0) {\n      return Math.exp(exponent * Math.log(base));\n    }\n    return NaN;\n  },\n  /**\n   * Compute base to the power of the rational exponent m / n.\n   * This function first reduces the fraction m/n and then computes\n   * JXG.Math.pow(base, m/n).\n   *\n   * This function is necessary to have the same results for e.g.\n   * (-8)^(1/3) = (-8)^(2/6) = -2\n   * @param {Number} base\n   * @param {Number} m numerator of exponent\n   * @param {Number} n denominator of exponent\n   * @returns {Number} base to the power of exponent.\n   */\n  ratpow: function (base, m, n) {\n    var g;\n    if (m === 0) {\n      return 1;\n    }\n    if (n === 0) {\n      return NaN;\n    }\n    g = this.gcd(m, n);\n    return this.nthroot(this.pow(base, m / g), n / g);\n  },\n  /**\n   * Logarithm to base 10.\n   * @param {Number} x\n   * @returns {Number} log10(x) Logarithm of x to base 10.\n   */\n  log10: function (x) {\n    return Math.log(x) / Math.log(10.0);\n  },\n  /**\n   * Logarithm to base 2.\n   * @param {Number} x\n   * @returns {Number} log2(x) Logarithm of x to base 2.\n   */\n  log2: function (x) {\n    return Math.log(x) / Math.log(2.0);\n  },\n  /**\n   * Logarithm to arbitrary base b. If b is not given, natural log is taken, i.e. b = e.\n   * @param {Number} x\n   * @param {Number} b base\n   * @returns {Number} log(x, b) Logarithm of x to base b, that is log(x)/log(b).\n   */\n  log: function (x, b) {\n    if (b !== undefined && Type.isNumber(b)) {\n      return Math.log(x) / Math.log(b);\n    }\n    return Math.log(x);\n  },\n  /**\n   * The sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.\n   *\n   * @function\n   * @param  {Number} x A Number\n   * @returns {Number}  This function has 5 kinds of return values,\n   *    1, -1, 0, -0, NaN, which represent \"positive number\", \"negative number\", \"positive zero\", \"negative zero\"\n   *    and NaN respectively.\n   */\n  sign: Math.sign || function (x) {\n    x = +x; // convert to a number\n    if (x === 0 || isNaN(x)) {\n      return x;\n    }\n    return x > 0 ? 1 : -1;\n  },\n  /**\n   * A square & multiply algorithm to compute base to the power of exponent.\n   * Implementated by Wolfgang Riedl.\n   *\n   * @param {Number} base\n   * @param {Number} exponent\n   * @returns {Number} Base to the power of exponent\n   */\n  squampow: function (base, exponent) {\n    var result;\n    if (Math.floor(exponent) === exponent) {\n      // exponent is integer (could be zero)\n      result = 1;\n      if (exponent < 0) {\n        // invert: base\n        base = 1.0 / base;\n        exponent *= -1;\n      }\n      while (exponent !== 0) {\n        if (exponent & 1) {\n          result *= base;\n        }\n        exponent >>= 1;\n        base *= base;\n      }\n      return result;\n    }\n    return this.pow(base, exponent);\n  },\n  /**\n   * Greatest common divisor (gcd) of two numbers.\n   * @see <a href=\"https://rosettacode.org/wiki/Greatest_common_divisor#JavaScript\">rosettacode.org</a>\n   *\n   * @param  {Number} a First number\n   * @param  {Number} b Second number\n   * @returns {Number}   gcd(a, b) if a and b are numbers, NaN else.\n   */\n  gcd: function (a, b) {\n    var tmp,\n      endless = true;\n    a = Math.abs(a);\n    b = Math.abs(b);\n    if (!(Type.isNumber(a) && Type.isNumber(b))) {\n      return NaN;\n    }\n    if (b > a) {\n      tmp = a;\n      a = b;\n      b = tmp;\n    }\n    while (endless) {\n      a %= b;\n      if (a === 0) {\n        return b;\n      }\n      b %= a;\n      if (b === 0) {\n        return a;\n      }\n    }\n  },\n  /**\n   * Least common multiple (lcm) of two numbers.\n   *\n   * @param  {Number} a First number\n   * @param  {Number} b Second number\n   * @returns {Number}   lcm(a, b) if a and b are numbers, NaN else.\n   */\n  lcm: function (a, b) {\n    var ret;\n    if (!(Type.isNumber(a) && Type.isNumber(b))) {\n      return NaN;\n    }\n    ret = a * b;\n    if (ret !== 0) {\n      return ret / this.gcd(a, b);\n    }\n    return 0;\n  },\n  /**\n   *  Error function, see {@link https://en.wikipedia.org/wiki/Error_function}.\n   *\n   * @see JXG.Math.PropFunc.erf\n   * @param  {Number} x\n   * @returns {Number}\n   */\n  erf: function (x) {\n    return this.ProbFuncs.erf(x);\n  },\n  /**\n   * Complementary error function, i.e. 1 - erf(x).\n   *\n   * @see JXG.Math.erf\n   * @see JXG.Math.PropFunc.erfc\n   * @param  {Number} x\n   * @returns {Number}\n   */\n  erfc: function (x) {\n    return this.ProbFuncs.erfc(x);\n  },\n  /**\n   * Inverse of error function\n   *\n   * @see JXG.Math.erf\n   * @see JXG.Math.PropFunc.erfi\n   * @param  {Number} x\n   * @returns {Number}\n   */\n  erfi: function (x) {\n    return this.ProbFuncs.erfi(x);\n  },\n  /**\n   * Normal distribution function\n   *\n   * @see JXG.Math.PropFunc.ndtr\n   * @param  {Number} x\n   * @returns {Number}\n   */\n  ndtr: function (x) {\n    return this.ProbFuncs.ndtr(x);\n  },\n  /**\n   * Inverse of normal distribution function\n   *\n   * @see JXG.Math.ndtr\n   * @see JXG.Math.PropFunc.ndtri\n   * @param  {Number} x\n   * @returns {Number}\n   */\n  ndtri: function (x) {\n    return this.ProbFuncs.ndtri(x);\n  },\n  /**\n   * Returns sqrt(a * a + b * b) for a variable number of arguments.\n   * This is a naive implementation which might be faster than Math.hypot.\n   * The latter is numerically more stable.\n   *\n   * @param {Number} a Variable number of arguments.\n   * @returns Number\n   */\n  hypot: function () {\n    var i, le, a, sum;\n    le = arguments.length;\n    for (i = 0, sum = 0.0; i < le; i++) {\n      a = arguments[i];\n      sum += a * a;\n    }\n    return Math.sqrt(sum);\n  },\n  /**\n   * Heaviside unit step function. Returns 0 for x &lt;, 1 for x &gt; 0, and 0.5 for x == 0.\n   *\n   * @param {Number} x\n   * @returns Number\n   */\n  hstep: function (x) {\n    return x > 0.0 ? 1 : x < 0.0 ? 0.0 : 0.5;\n  },\n  /* ********************  Comparisons and logical operators ************** */\n\n  /**\n   * Logical test: a < b?\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @returns {Boolean}\n   */\n  lt: function (a, b) {\n    return a < b;\n  },\n  /**\n   * Logical test: a <= b?\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @returns {Boolean}\n   */\n  leq: function (a, b) {\n    return a <= b;\n  },\n  /**\n   * Logical test: a > b?\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @returns {Boolean}\n   */\n  gt: function (a, b) {\n    return a > b;\n  },\n  /**\n   * Logical test: a >= b?\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @returns {Boolean}\n   */\n  geq: function (a, b) {\n    return a >= b;\n  },\n  /**\n   * Logical test: a === b?\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @returns {Boolean}\n   */\n  eq: function (a, b) {\n    return a === b;\n  },\n  /**\n   * Logical test: a !== b?\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @returns {Boolean}\n   */\n  neq: function (a, b) {\n    return a !== b;\n  },\n  /**\n   * Logical operator: a && b?\n   *\n   * @param {Boolean} a\n   * @param {Boolean} b\n   * @returns {Boolean}\n   */\n  and: function (a, b) {\n    return a && b;\n  },\n  /**\n   * Logical operator: !a?\n   *\n   * @param {Boolean} a\n   * @returns {Boolean}\n   */\n  not: function (a) {\n    return !a;\n  },\n  /**\n   * Logical operator: a || b?\n   *\n   * @param {Boolean} a\n   * @param {Boolean} b\n   * @returns {Boolean}\n   */\n  or: function (a, b) {\n    return a || b;\n  },\n  /**\n   * Logical operator: either a or b?\n   *\n   * @param {Boolean} a\n   * @param {Boolean} b\n   * @returns {Boolean}\n   */\n  xor: function (a, b) {\n    return (a || b) && !(a && b);\n  },\n  /* *************************** Normalize *************************** */\n\n  /**\n   * Normalize the standard form [c, b0, b1, a, k, r, q0, q1].\n   * @private\n   * @param {Array} stdform The standard form to be normalized.\n   * @returns {Array} The normalized standard form.\n   */\n  normalize: function (stdform) {\n    var n,\n      signr,\n      a2 = 2 * stdform[3],\n      r = stdform[4] / a2;\n    stdform[5] = r;\n    stdform[6] = -stdform[1] / a2;\n    stdform[7] = -stdform[2] / a2;\n    if (!isFinite(r)) {\n      n = this.hypot(stdform[1], stdform[2]);\n      stdform[0] /= n;\n      stdform[1] /= n;\n      stdform[2] /= n;\n      stdform[3] = 0;\n      stdform[4] = 1;\n    } else if (Math.abs(r) >= 1) {\n      stdform[0] = (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) / (2 * r);\n      stdform[1] = -stdform[6] / r;\n      stdform[2] = -stdform[7] / r;\n      stdform[3] = 1 / (2 * r);\n      stdform[4] = 1;\n    } else {\n      signr = r <= 0 ? -1 : 1;\n      stdform[0] = signr * (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) * 0.5;\n      stdform[1] = -signr * stdform[6];\n      stdform[2] = -signr * stdform[7];\n      stdform[3] = signr / 2;\n      stdform[4] = signr * r;\n    }\n    return stdform;\n  },\n  /**\n   * Converts a two dimensional array to a one dimensional Float32Array that can be processed by WebGL.\n   * @param {Array} m A matrix in a two dimensional array.\n   * @returns {Float32Array} A one dimensional array containing the matrix in column wise notation. Provides a fall\n   * back to the default JavaScript Array if Float32Array is not available.\n   */\n  toGL: function (m) {\n    var v, i, j;\n    if (typeof Float32Array === \"function\") {\n      v = new Float32Array(16);\n    } else {\n      v = new Array(16);\n    }\n    if (m.length !== 4 && m[0].length !== 4) {\n      return v;\n    }\n    for (i = 0; i < 4; i++) {\n      for (j = 0; j < 4; j++) {\n        v[i + 4 * j] = m[i][j];\n      }\n    }\n    return v;\n  },\n  /**\n   * Theorem of Vieta: Given a set of simple zeroes x_0, ..., x_n\n   * of a polynomial f, compute the coefficients s_k, (k=0,...,n-1)\n   * of the polynomial of the form. See {@link https://de.wikipedia.org/wiki/Elementarsymmetrisches_Polynom}.\n   * <p>\n   *  f(x) = (x-x_0)*...*(x-x_n) =\n   *  x^n + sum_{k=1}^{n} (-1)^(k) s_{k-1} x^(n-k)\n   * </p>\n   * @param {Array} x Simple zeroes of the polynomial.\n   * @returns {Array} Coefficients of the polynomial.\n   *\n   */\n  Vieta: function (x) {\n    var n = x.length,\n      s = [],\n      m,\n      k,\n      y;\n    s = x.slice();\n    for (m = 1; m < n; ++m) {\n      y = s[m];\n      s[m] *= s[m - 1];\n      for (k = m - 1; k >= 1; --k) {\n        s[k] += s[k - 1] * y;\n      }\n      s[0] += y;\n    }\n    return s;\n  }\n};\nexport default JXG.Math;","map":{"version":3,"names":["JXG","Type","undef","memoizer","f","cache","join","memo","Array","prototype","key","call","arguments","apply","Math","eps","relDif","a","b","c","abs","d","max","mod","m","floor","vector","n","init","r","i","matrix","j","identity","min","frustum","l","t","ret","projection","fov","ratio","tan","matVecMult","mat","vec","s","k","length","res","matMatMult","mat1","mat2","m2","transpose","M","MT","inverse","Ain","ma","swp","A","p","hv","innerProduct","isNumber","crossProduct","c1","c2","norm","sum","sqrt","axpy","x","y","le","factorial","NaN","binomial","round","cosh","exp","sinh","acosh","log","asinh","Infinity","cot","acot","PI","atan","nthroot","inv","cbrt","pow","base","exponent","ratpow","g","gcd","log10","log2","undefined","sign","isNaN","squampow","result","tmp","endless","lcm","erf","ProbFuncs","erfc","erfi","ndtr","ndtri","hypot","hstep","lt","leq","gt","geq","eq","neq","and","not","or","xor","normalize","stdform","signr","a2","isFinite","toGL","v","Float32Array","Vieta","slice"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/math/math.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, Float32Array: true */\n/*jslint nomen: true, plusplus: true, bitwise: true*/\n\n/**\n * @fileoverview In this file the namespace JXG.Math is defined, which is the base namespace\n * for namespaces like JXG.Math.Numerics, JXG.Math.Plot, JXG.Math.Statistics, JXG.Math.Clip etc.\n */\nimport JXG from \"../jxg\";\nimport Type from \"../utils/type\";\n\nvar undef,\n    /*\n     * Dynamic programming approach for recursive functions.\n     * From \"Speed up your JavaScript, Part 3\" by Nicholas C. Zakas.\n     * @see JXG.Math.factorial\n     * @see JXG.Math.binomial\n     * http://blog.thejit.org/2008/09/05/memoization-in-javascript/\n     *\n     * This method is hidden, because it is only used in JXG.Math. If someone wants\n     * to use it in JSXGraph outside of JXG.Math, it should be moved to jsxgraph.js\n     */\n    memoizer = function (f) {\n        var cache, join;\n\n        if (f.memo) {\n            return f.memo;\n        }\n\n        cache = {};\n        join = Array.prototype.join;\n\n        f.memo = function () {\n            var key = join.call(arguments);\n\n            // Seems to be a bit faster than \"if (a in b)\"\n            return cache[key] !== undef ? cache[key] : (cache[key] = f.apply(this, arguments));\n        };\n\n        return f.memo;\n    };\n\n/**\n * Math namespace. Contains mathematics related methods which are\n * specific to JSXGraph or which extend the JavaScript Math class.\n * @namespace\n */\nJXG.Math = {\n    /**\n     * eps defines the closeness to zero. If the absolute value of a given number is smaller\n     * than eps, it is considered to be equal to zero.\n     * @type Number\n     */\n    eps: 0.000001,\n\n    /**\n     * Determine the relative difference between two numbers.\n     * @param  {Number} a First number\n     * @param  {Number} b Second number\n     * @returns {Number}  Relative difference between a and b: |a-b| / max(|a|, |b|)\n     */\n    relDif: function (a, b) {\n        var c = Math.abs(a),\n            d = Math.abs(b);\n\n        d = Math.max(c, d);\n\n        return d === 0.0 ? 0.0 : Math.abs(a - b) / d;\n    },\n\n    /**\n     * The JavaScript implementation of the % operator returns the symmetric modulo.\n     * mod and \"%\" are both identical if a >= 0 and m >= 0 but the results differ if a or m < 0.\n     * @param {Number} a\n     * @param {Number} m\n     * @returns {Number} Mathematical modulo <tt>a mod m</tt>\n     */\n    mod: function (a, m) {\n        return a - Math.floor(a / m) * m;\n    },\n\n    /**\n     * Initializes a vector as an array with the coefficients set to the given value resp. zero.\n     * @param {Number} n Length of the vector\n     * @param {Number} [init=0] Initial value for each coefficient\n     * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a\n     * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.\n     */\n    vector: function (n, init) {\n        var r, i;\n\n        init = init || 0;\n        r = [];\n\n        for (i = 0; i < n; i++) {\n            r[i] = init;\n        }\n\n        return r;\n    },\n\n    /**\n     * Initializes a matrix as an array of rows with the given value.\n     * @param {Number} n Number of rows\n     * @param {Number} [m=n] Number of columns\n     * @param {Number} [init=0] Initial value for each coefficient\n     * @returns {Array} A <tt>n</tt> times <tt>m</tt>-matrix represented by a\n     * two-dimensional array. The inner arrays hold the columns, the outer array holds the rows.\n     */\n    matrix: function (n, m, init) {\n        var r, i, j;\n\n        init = init || 0;\n        m = m || n;\n        r = [];\n\n        for (i = 0; i < n; i++) {\n            r[i] = [];\n\n            for (j = 0; j < m; j++) {\n                r[i][j] = init;\n            }\n        }\n\n        return r;\n    },\n\n    /**\n     * Generates an identity matrix. If n is a number and m is undefined or not a number, a square matrix is generated,\n     * if n and m are both numbers, an nxm matrix is generated.\n     * @param {Number} n Number of rows\n     * @param {Number} [m=n] Number of columns\n     * @returns {Array} A square matrix of length <tt>n</tt> with all coefficients equal to 0 except a_(i,i), i out of (1, ..., n), if <tt>m</tt> is undefined or not a number\n     * or a <tt>n</tt> times <tt>m</tt>-matrix with a_(i,j) = 0 and a_(i,i) = 1 if m is a number.\n     */\n    identity: function (n, m) {\n        var r, i;\n\n        if (m === undef && typeof m !== \"number\") {\n            m = n;\n        }\n\n        r = this.matrix(n, m);\n\n        for (i = 0; i < Math.min(n, m); i++) {\n            r[i][i] = 1;\n        }\n\n        return r;\n    },\n\n    /**\n     * Generates a 4x4 matrix for 3D to 2D projections.\n     * @param {Number} l Left\n     * @param {Number} r Right\n     * @param {Number} t Top\n     * @param {Number} b Bottom\n     * @param {Number} n Near\n     * @param {Number} f Far\n     * @returns {Array} 4x4 Matrix\n     */\n    frustum: function (l, r, b, t, n, f) {\n        var ret = this.matrix(4, 4);\n\n        ret[0][0] = (n * 2) / (r - l);\n        ret[0][1] = 0;\n        ret[0][2] = (r + l) / (r - l);\n        ret[0][3] = 0;\n\n        ret[1][0] = 0;\n        ret[1][1] = (n * 2) / (t - b);\n        ret[1][2] = (t + b) / (t - b);\n        ret[1][3] = 0;\n\n        ret[2][0] = 0;\n        ret[2][1] = 0;\n        ret[2][2] = -(f + n) / (f - n);\n        ret[2][3] = -(f * n * 2) / (f - n);\n\n        ret[3][0] = 0;\n        ret[3][1] = 0;\n        ret[3][2] = -1;\n        ret[3][3] = 0;\n\n        return ret;\n    },\n\n    /**\n     * Generates a 4x4 matrix for 3D to 2D projections.\n     * @param {Number} fov Field of view in vertical direction, given in rad.\n     * @param {Number} ratio Aspect ratio of the projection plane.\n     * @param {Number} n Near\n     * @param {Number} f Far\n     * @returns {Array} 4x4 Projection Matrix\n     */\n    projection: function (fov, ratio, n, f) {\n        var t = n * Math.tan(fov / 2),\n            r = t * ratio;\n\n        return this.frustum(-r, r, -t, t, n, f);\n    },\n\n    /**\n     * Multiplies a vector vec to a matrix mat: mat * vec. The matrix is interpreted by this function as an array of rows. Please note: This\n     * function does not check if the dimensions match.\n     * @param {Array} mat Two dimensional array of numbers. The inner arrays describe the columns, the outer ones the matrix' rows.\n     * @param {Array} vec Array of numbers\n     * @returns {Array} Array of numbers containing the result\n     * @example\n     * var A = [[2, 1],\n     *          [1, 3]],\n     *     b = [4, 5],\n     *     c;\n     * c = JXG.Math.matVecMult(A, b)\n     * // c === [13, 19];\n     */\n    matVecMult: function (mat, vec) {\n        var i,\n            s,\n            k,\n            m = mat.length,\n            n = vec.length,\n            res = [];\n\n        if (n === 3) {\n            for (i = 0; i < m; i++) {\n                res[i] = mat[i][0] * vec[0] + mat[i][1] * vec[1] + mat[i][2] * vec[2];\n            }\n        } else {\n            for (i = 0; i < m; i++) {\n                s = 0;\n                for (k = 0; k < n; k++) {\n                    s += mat[i][k] * vec[k];\n                }\n                res[i] = s;\n            }\n        }\n        return res;\n    },\n\n    /**\n     * Computes the product of the two matrices mat1*mat2.\n     * @param {Array} mat1 Two dimensional array of numbers\n     * @param {Array} mat2 Two dimensional array of numbers\n     * @returns {Array} Two dimensional Array of numbers containing result\n     */\n    matMatMult: function (mat1, mat2) {\n        var i,\n            j,\n            s,\n            k,\n            m = mat1.length,\n            n = m > 0 ? mat2[0].length : 0,\n            m2 = mat2.length,\n            res = this.matrix(m, n);\n\n        for (i = 0; i < m; i++) {\n            for (j = 0; j < n; j++) {\n                s = 0;\n                for (k = 0; k < m2; k++) {\n                    s += mat1[i][k] * mat2[k][j];\n                }\n                res[i][j] = s;\n            }\n        }\n        return res;\n    },\n\n    /**\n     * Transposes a matrix given as a two dimensional array.\n     * @param {Array} M The matrix to be transposed\n     * @returns {Array} The transpose of M\n     */\n    transpose: function (M) {\n        var MT, i, j, m, n;\n\n        // number of rows of M\n        m = M.length;\n        // number of columns of M\n        n = M.length > 0 ? M[0].length : 0;\n        MT = this.matrix(n, m);\n\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < m; j++) {\n                MT[i][j] = M[j][i];\n            }\n        }\n\n        return MT;\n    },\n\n    /**\n     * Compute the inverse of an nxn matrix with Gauss elimination.\n     * @param {Array} Ain\n     * @returns {Array} Inverse matrix of Ain\n     */\n    inverse: function (Ain) {\n        var i,\n            j,\n            k,\n            s,\n            ma,\n            r,\n            swp,\n            n = Ain.length,\n            A = [],\n            p = [],\n            hv = [];\n\n        for (i = 0; i < n; i++) {\n            A[i] = [];\n            for (j = 0; j < n; j++) {\n                A[i][j] = Ain[i][j];\n            }\n            p[i] = i;\n        }\n\n        for (j = 0; j < n; j++) {\n            // pivot search:\n            ma = Math.abs(A[j][j]);\n            r = j;\n\n            for (i = j + 1; i < n; i++) {\n                if (Math.abs(A[i][j]) > ma) {\n                    ma = Math.abs(A[i][j]);\n                    r = i;\n                }\n            }\n\n            // Singular matrix\n            if (ma <= this.eps) {\n                return [];\n            }\n\n            // swap rows:\n            if (r > j) {\n                for (k = 0; k < n; k++) {\n                    swp = A[j][k];\n                    A[j][k] = A[r][k];\n                    A[r][k] = swp;\n                }\n\n                swp = p[j];\n                p[j] = p[r];\n                p[r] = swp;\n            }\n\n            // transformation:\n            s = 1.0 / A[j][j];\n            for (i = 0; i < n; i++) {\n                A[i][j] *= s;\n            }\n            A[j][j] = s;\n\n            for (k = 0; k < n; k++) {\n                if (k !== j) {\n                    for (i = 0; i < n; i++) {\n                        if (i !== j) {\n                            A[i][k] -= A[i][j] * A[j][k];\n                        }\n                    }\n                    A[j][k] = -s * A[j][k];\n                }\n            }\n        }\n\n        // swap columns:\n        for (i = 0; i < n; i++) {\n            for (k = 0; k < n; k++) {\n                hv[p[k]] = A[i][k];\n            }\n            for (k = 0; k < n; k++) {\n                A[i][k] = hv[k];\n            }\n        }\n\n        return A;\n    },\n\n    /**\n     * Inner product of two vectors a and b. n is the length of the vectors.\n     * @param {Array} a Vector\n     * @param {Array} b Vector\n     * @param {Number} [n] Length of the Vectors. If not given the length of the first vector is taken.\n     * @returns {Number} The inner product of a and b.\n     */\n    innerProduct: function (a, b, n) {\n        var i,\n            s = 0;\n\n        if (n === undef || !Type.isNumber(n)) {\n            n = a.length;\n        }\n\n        for (i = 0; i < n; i++) {\n            s += a[i] * b[i];\n        }\n\n        return s;\n    },\n\n    /**\n     * Calculates the cross product of two vectors both of length three.\n     * In case of homogeneous coordinates this is either\n     * <ul>\n     * <li>the intersection of two lines</li>\n     * <li>the line through two points</li>\n     * </ul>\n     * @param {Array} c1 Homogeneous coordinates of line or point 1\n     * @param {Array} c2 Homogeneous coordinates of line or point 2\n     * @returns {Array} vector of length 3: homogeneous coordinates of the resulting point / line.\n     */\n    crossProduct: function (c1, c2) {\n        return [\n            c1[1] * c2[2] - c1[2] * c2[1],\n            c1[2] * c2[0] - c1[0] * c2[2],\n            c1[0] * c2[1] - c1[1] * c2[0]\n        ];\n    },\n\n    /**\n     * Euclidean norm of a vector.\n     *\n     * @param {Array} a Array containing a vector.\n     * @param {Number} n (Optional) length of the array.\n     * @returns {Number} Euclidean norm of the vector.\n     */\n    norm: function (a, n) {\n        var i,\n            sum = 0.0;\n\n        if (n === undef || !Type.isNumber(n)) {\n            n = a.length;\n        }\n\n        for (i = 0; i < n; i++) {\n            sum += a[i] * a[i];\n        }\n\n        return Math.sqrt(sum);\n    },\n\n    /**\n     * Compute a * x + y for a scalar a and vectors x and y.\n     *\n     * @param {Number} a\n     * @param {Array} x\n     * @param {Array} y\n     * @returns\n     */\n    axpy: function (a, x, y) {\n        var i,\n            le = x.length,\n            p = [];\n        for (i = 0; i < le; i++) {\n            p[i] = a * x[i] + y[i];\n        }\n        return p;\n    },\n\n    /**\n     * Compute the factorial of a positive integer. If a non-integer value\n     * is given, the fraction will be ignored.\n     * @function\n     * @param {Number} n\n     * @returns {Number} n! = n*(n-1)*...*2*1\n     */\n    factorial: memoizer(function (n) {\n        if (n < 0) {\n            return NaN;\n        }\n\n        n = Math.floor(n);\n\n        if (n === 0 || n === 1) {\n            return 1;\n        }\n\n        return n * this.factorial(n - 1);\n    }),\n\n    /**\n     * Computes the binomial coefficient n over k.\n     * @function\n     * @param {Number} n Fraction will be ignored\n     * @param {Number} k Fraction will be ignored\n     * @returns {Number} The binomial coefficient n over k\n     */\n    binomial: memoizer(function (n, k) {\n        var b, i;\n\n        if (k > n || k < 0) {\n            return NaN;\n        }\n\n        k = Math.round(k);\n        n = Math.round(n);\n\n        if (k === 0 || k === n) {\n            return 1;\n        }\n\n        b = 1;\n\n        for (i = 0; i < k; i++) {\n            b *= n - i;\n            b /= i + 1;\n        }\n\n        return b;\n    }),\n\n    /**\n     * Calculates the cosine hyperbolicus of x.\n     * @function\n     * @param {Number} x The number the cosine hyperbolicus will be calculated of.\n     * @returns {Number} Cosine hyperbolicus of the given value.\n     */\n    cosh:\n        Math.cosh ||\n        function (x) {\n            return (Math.exp(x) + Math.exp(-x)) * 0.5;\n        },\n\n    /**\n     * Sine hyperbolicus of x.\n     * @function\n     * @param {Number} x The number the sine hyperbolicus will be calculated of.\n     * @returns {Number} Sine hyperbolicus of the given value.\n     */\n    sinh:\n        Math.sinh ||\n        function (x) {\n            return (Math.exp(x) - Math.exp(-x)) * 0.5;\n        },\n\n    /**\n     * Hyperbolic arc-cosine of a number.\n     *\n     * @param {Number} x\n     * @returns {Number}\n     */\n    acosh:\n        Math.acosh ||\n        function (x) {\n            return Math.log(x + Math.sqrt(x * x - 1));\n        },\n\n    /**\n     * Hyperbolic arcsine of a number\n     * @param {Number} x\n     * @returns {Number}\n     */\n    asinh:\n        Math.asinh ||\n        function (x) {\n            if (x === -Infinity) {\n                return x;\n            }\n            return Math.log(x + Math.sqrt(x * x + 1));\n        },\n\n    /**\n     * Computes the cotangent of x.\n     * @function\n     * @param {Number} x The number the cotangent will be calculated of.\n     * @returns {Number} Cotangent of the given value.\n     */\n    cot: function (x) {\n        return 1 / Math.tan(x);\n    },\n\n    /**\n     * Computes the inverse cotangent of x.\n     * @param {Number} x The number the inverse cotangent will be calculated of.\n     * @returns {Number} Inverse cotangent of the given value.\n     */\n    acot: function (x) {\n        return (x >= 0 ? 0.5 : -0.5) * Math.PI - Math.atan(x);\n    },\n\n    /**\n     * Compute n-th real root of a real number. n must be strictly positive integer.\n     * If n is odd, the real n-th root exists and is negative.\n     * For n even, for negative valuees of x NaN is returned\n     * @param  {Number} x radicand. Must be non-negative, if n even.\n     * @param  {Number} n index of the root. must be strictly positive integer.\n     * @returns {Number} returns real root or NaN\n     *\n     * @example\n     * nthroot(16, 4): 2\n     * nthroot(-27, 3): -3\n     * nthroot(-4, 2): NaN\n     */\n    nthroot: function (x, n) {\n        var inv = 1 / n;\n\n        if (n <= 0 || Math.floor(n) !== n) {\n            return NaN;\n        }\n\n        if (x === 0.0) {\n            return 0.0;\n        }\n\n        if (x > 0) {\n            return Math.exp(inv * Math.log(x));\n        }\n\n        // From here on, x is negative\n        if (n % 2 === 1) {\n            return -Math.exp(inv * Math.log(-x));\n        }\n\n        // x negative, even root\n        return NaN;\n    },\n\n    /**\n     * Computes cube root of real number\n     * Polyfill for Math.cbrt().\n     *\n     * @function\n     * @param  {Number} x Radicand\n     * @returns {Number} Cube root of x.\n     */\n    cbrt:\n        Math.cbrt ||\n        function (x) {\n            return this.nthroot(x, 3);\n        },\n\n    /**\n     * Compute base to the power of exponent.\n     * @param {Number} base\n     * @param {Number} exponent\n     * @returns {Number} base to the power of exponent.\n     */\n    pow: function (base, exponent) {\n        if (base === 0) {\n            if (exponent === 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        // exponent is an integer\n        if (Math.floor(exponent) === exponent) {\n            return Math.pow(base, exponent);\n        }\n\n        // exponent is not an integer\n        if (base > 0) {\n            return Math.exp(exponent * Math.log(base));\n        }\n\n        return NaN;\n    },\n\n    /**\n     * Compute base to the power of the rational exponent m / n.\n     * This function first reduces the fraction m/n and then computes\n     * JXG.Math.pow(base, m/n).\n     *\n     * This function is necessary to have the same results for e.g.\n     * (-8)^(1/3) = (-8)^(2/6) = -2\n     * @param {Number} base\n     * @param {Number} m numerator of exponent\n     * @param {Number} n denominator of exponent\n     * @returns {Number} base to the power of exponent.\n     */\n    ratpow: function (base, m, n) {\n        var g;\n        if (m === 0) {\n            return 1;\n        }\n        if (n === 0) {\n            return NaN;\n        }\n\n        g = this.gcd(m, n);\n        return this.nthroot(this.pow(base, m / g), n / g);\n    },\n\n    /**\n     * Logarithm to base 10.\n     * @param {Number} x\n     * @returns {Number} log10(x) Logarithm of x to base 10.\n     */\n    log10: function (x) {\n        return Math.log(x) / Math.log(10.0);\n    },\n\n    /**\n     * Logarithm to base 2.\n     * @param {Number} x\n     * @returns {Number} log2(x) Logarithm of x to base 2.\n     */\n    log2: function (x) {\n        return Math.log(x) / Math.log(2.0);\n    },\n\n    /**\n     * Logarithm to arbitrary base b. If b is not given, natural log is taken, i.e. b = e.\n     * @param {Number} x\n     * @param {Number} b base\n     * @returns {Number} log(x, b) Logarithm of x to base b, that is log(x)/log(b).\n     */\n    log: function (x, b) {\n        if (b !== undefined && Type.isNumber(b)) {\n            return Math.log(x) / Math.log(b);\n        }\n\n        return Math.log(x);\n    },\n\n    /**\n     * The sign() function returns the sign of a number, indicating whether the number is positive, negative or zero.\n     *\n     * @function\n     * @param  {Number} x A Number\n     * @returns {Number}  This function has 5 kinds of return values,\n     *    1, -1, 0, -0, NaN, which represent \"positive number\", \"negative number\", \"positive zero\", \"negative zero\"\n     *    and NaN respectively.\n     */\n    sign:\n        Math.sign ||\n        function (x) {\n            x = +x; // convert to a number\n            if (x === 0 || isNaN(x)) {\n                return x;\n            }\n            return x > 0 ? 1 : -1;\n        },\n\n    /**\n     * A square & multiply algorithm to compute base to the power of exponent.\n     * Implementated by Wolfgang Riedl.\n     *\n     * @param {Number} base\n     * @param {Number} exponent\n     * @returns {Number} Base to the power of exponent\n     */\n    squampow: function (base, exponent) {\n        var result;\n\n        if (Math.floor(exponent) === exponent) {\n            // exponent is integer (could be zero)\n            result = 1;\n\n            if (exponent < 0) {\n                // invert: base\n                base = 1.0 / base;\n                exponent *= -1;\n            }\n\n            while (exponent !== 0) {\n                if (exponent & 1) {\n                    result *= base;\n                }\n\n                exponent >>= 1;\n                base *= base;\n            }\n            return result;\n        }\n\n        return this.pow(base, exponent);\n    },\n\n    /**\n     * Greatest common divisor (gcd) of two numbers.\n     * @see <a href=\"https://rosettacode.org/wiki/Greatest_common_divisor#JavaScript\">rosettacode.org</a>\n     *\n     * @param  {Number} a First number\n     * @param  {Number} b Second number\n     * @returns {Number}   gcd(a, b) if a and b are numbers, NaN else.\n     */\n    gcd: function (a, b) {\n        var tmp,\n            endless = true;\n\n        a = Math.abs(a);\n        b = Math.abs(b);\n\n        if (!(Type.isNumber(a) && Type.isNumber(b))) {\n            return NaN;\n        }\n        if (b > a) {\n            tmp = a;\n            a = b;\n            b = tmp;\n        }\n\n        while (endless) {\n            a %= b;\n            if (a === 0) {\n                return b;\n            }\n            b %= a;\n            if (b === 0) {\n                return a;\n            }\n        }\n    },\n\n    /**\n     * Least common multiple (lcm) of two numbers.\n     *\n     * @param  {Number} a First number\n     * @param  {Number} b Second number\n     * @returns {Number}   lcm(a, b) if a and b are numbers, NaN else.\n     */\n    lcm: function (a, b) {\n        var ret;\n\n        if (!(Type.isNumber(a) && Type.isNumber(b))) {\n            return NaN;\n        }\n\n        ret = a * b;\n        if (ret !== 0) {\n            return ret / this.gcd(a, b);\n        }\n\n        return 0;\n    },\n\n    /**\n     *  Error function, see {@link https://en.wikipedia.org/wiki/Error_function}.\n     *\n     * @see JXG.Math.PropFunc.erf\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erf: function (x) {\n        return this.ProbFuncs.erf(x);\n    },\n\n    /**\n     * Complementary error function, i.e. 1 - erf(x).\n     *\n     * @see JXG.Math.erf\n     * @see JXG.Math.PropFunc.erfc\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erfc: function (x) {\n        return this.ProbFuncs.erfc(x);\n    },\n\n    /**\n     * Inverse of error function\n     *\n     * @see JXG.Math.erf\n     * @see JXG.Math.PropFunc.erfi\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    erfi: function (x) {\n        return this.ProbFuncs.erfi(x);\n    },\n\n    /**\n     * Normal distribution function\n     *\n     * @see JXG.Math.PropFunc.ndtr\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    ndtr: function (x) {\n        return this.ProbFuncs.ndtr(x);\n    },\n\n    /**\n     * Inverse of normal distribution function\n     *\n     * @see JXG.Math.ndtr\n     * @see JXG.Math.PropFunc.ndtri\n     * @param  {Number} x\n     * @returns {Number}\n     */\n    ndtri: function (x) {\n        return this.ProbFuncs.ndtri(x);\n    },\n\n    /**\n     * Returns sqrt(a * a + b * b) for a variable number of arguments.\n     * This is a naive implementation which might be faster than Math.hypot.\n     * The latter is numerically more stable.\n     *\n     * @param {Number} a Variable number of arguments.\n     * @returns Number\n     */\n    hypot: function() {\n        var i, le, a, sum;\n\n        le = arguments.length;\n        for (i = 0, sum = 0.0; i < le; i++) {\n            a = arguments[i];\n            sum += a * a;\n        }\n        return Math.sqrt(sum);\n    },\n\n    /**\n     * Heaviside unit step function. Returns 0 for x &lt;, 1 for x &gt; 0, and 0.5 for x == 0.\n     *\n     * @param {Number} x\n     * @returns Number\n     */\n    hstep: function(x) {\n        return (x > 0.0) ? 1 :\n            ((x < 0.0) ? 0.0 : 0.5);\n    },\n\n    /* ********************  Comparisons and logical operators ************** */\n\n    /**\n     * Logical test: a < b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    lt: function (a, b) {\n        return a < b;\n    },\n\n    /**\n     * Logical test: a <= b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    leq: function (a, b) {\n        return a <= b;\n    },\n\n    /**\n     * Logical test: a > b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    gt: function (a, b) {\n        return a > b;\n    },\n\n    /**\n     * Logical test: a >= b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    geq: function (a, b) {\n        return a >= b;\n    },\n\n    /**\n     * Logical test: a === b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    eq: function (a, b) {\n        return a === b;\n    },\n\n    /**\n     * Logical test: a !== b?\n     *\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {Boolean}\n     */\n    neq: function (a, b) {\n        return a !== b;\n    },\n\n    /**\n     * Logical operator: a && b?\n     *\n     * @param {Boolean} a\n     * @param {Boolean} b\n     * @returns {Boolean}\n     */\n    and: function (a, b) {\n        return a && b;\n    },\n\n    /**\n     * Logical operator: !a?\n     *\n     * @param {Boolean} a\n     * @returns {Boolean}\n     */\n    not: function (a) {\n        return !a;\n    },\n\n    /**\n     * Logical operator: a || b?\n     *\n     * @param {Boolean} a\n     * @param {Boolean} b\n     * @returns {Boolean}\n     */\n    or: function (a, b) {\n        return a || b;\n    },\n\n    /**\n     * Logical operator: either a or b?\n     *\n     * @param {Boolean} a\n     * @param {Boolean} b\n     * @returns {Boolean}\n     */\n    xor: function (a, b) {\n        return (a || b) && !(a && b);\n    },\n\n    /* *************************** Normalize *************************** */\n\n    /**\n     * Normalize the standard form [c, b0, b1, a, k, r, q0, q1].\n     * @private\n     * @param {Array} stdform The standard form to be normalized.\n     * @returns {Array} The normalized standard form.\n     */\n    normalize: function (stdform) {\n        var n,\n            signr,\n            a2 = 2 * stdform[3],\n            r = stdform[4] / a2;\n\n        stdform[5] = r;\n        stdform[6] = -stdform[1] / a2;\n        stdform[7] = -stdform[2] / a2;\n\n        if (!isFinite(r)) {\n            n = this.hypot(stdform[1], stdform[2]);\n\n            stdform[0] /= n;\n            stdform[1] /= n;\n            stdform[2] /= n;\n            stdform[3] = 0;\n            stdform[4] = 1;\n        } else if (Math.abs(r) >= 1) {\n            stdform[0] = (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) / (2 * r);\n            stdform[1] = -stdform[6] / r;\n            stdform[2] = -stdform[7] / r;\n            stdform[3] = 1 / (2 * r);\n            stdform[4] = 1;\n        } else {\n            signr = r <= 0 ? -1 : 1;\n            stdform[0] =\n                signr * (stdform[6] * stdform[6] + stdform[7] * stdform[7] - r * r) * 0.5;\n            stdform[1] = -signr * stdform[6];\n            stdform[2] = -signr * stdform[7];\n            stdform[3] = signr / 2;\n            stdform[4] = signr * r;\n        }\n\n        return stdform;\n    },\n\n    /**\n     * Converts a two dimensional array to a one dimensional Float32Array that can be processed by WebGL.\n     * @param {Array} m A matrix in a two dimensional array.\n     * @returns {Float32Array} A one dimensional array containing the matrix in column wise notation. Provides a fall\n     * back to the default JavaScript Array if Float32Array is not available.\n     */\n    toGL: function (m) {\n        var v, i, j;\n\n        if (typeof Float32Array === \"function\") {\n            v = new Float32Array(16);\n        } else {\n            v = new Array(16);\n        }\n\n        if (m.length !== 4 && m[0].length !== 4) {\n            return v;\n        }\n\n        for (i = 0; i < 4; i++) {\n            for (j = 0; j < 4; j++) {\n                v[i + 4 * j] = m[i][j];\n            }\n        }\n\n        return v;\n    },\n\n    /**\n     * Theorem of Vieta: Given a set of simple zeroes x_0, ..., x_n\n     * of a polynomial f, compute the coefficients s_k, (k=0,...,n-1)\n     * of the polynomial of the form. See {@link https://de.wikipedia.org/wiki/Elementarsymmetrisches_Polynom}.\n     * <p>\n     *  f(x) = (x-x_0)*...*(x-x_n) =\n     *  x^n + sum_{k=1}^{n} (-1)^(k) s_{k-1} x^(n-k)\n     * </p>\n     * @param {Array} x Simple zeroes of the polynomial.\n     * @returns {Array} Coefficients of the polynomial.\n     *\n     */\n    Vieta: function (x) {\n        var n = x.length,\n            s = [],\n            m,\n            k,\n            y;\n\n        s = x.slice();\n        for (m = 1; m < n; ++m) {\n            y = s[m];\n            s[m] *= s[m - 1];\n            for (k = m - 1; k >= 1; --k) {\n                s[k] += s[k - 1] * y;\n            }\n            s[0] += y;\n        }\n        return s;\n    }\n};\n\nexport default JXG.Math;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}