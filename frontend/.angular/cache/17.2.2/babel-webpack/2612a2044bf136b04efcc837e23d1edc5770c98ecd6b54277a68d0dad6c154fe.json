{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\nconsole.log(\"P:\", P.coords.usrCoords, P.data.type)\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains the Math.Clip namespace for clipping and computing boolean operations\n * on polygons and curves\n *\n * // TODO:\n * * Check if input polygons are closed. If not, handle this case.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Type from \"../utils/type\";\n\n/**\n * Math.Clip namespace definition. This namespace contains algorithms for Boolean operations on paths, i.e.\n * intersection, union and difference of paths. Base is the Greiner-Hormann algorithm.\n * @name JXG.Math.Clip\n * @exports Mat.Clip as JXG.Math.Clip\n * @namespace\n */\n// Mat.Clip = function () {\n// };\n\n// JXG.extend(Mat.Clip.prototype, /** @lends JXG.Curve.prototype */ {\n\nMat.Clip = {\n  _isSeparator: function (node) {\n    return isNaN(node.coords.usrCoords[1]) && isNaN(node.coords.usrCoords[2]);\n  },\n  /**\n   * Add pointers to an array S such that it is a circular doubly-linked list.\n   *\n   * @private\n   * @param  {Array} S Array\n   * @return {Array} return containing the starter indices of each component.\n   */\n  makeDoublyLinkedList: function (S) {\n    var i,\n      first = null,\n      components = [],\n      le = S.length;\n    if (le > 0) {\n      for (i = 0; i < le; i++) {\n        // S[i]._next = S[(i + 1) % le];\n        // S[i]._prev = S[(le + i - 1) % le];\n\n        // If S[i] is component separator we proceed with the next node.\n        if (this._isSeparator(S[i])) {\n          S[i]._next = S[(i + 1) % le];\n          S[i]._prev = S[(le + i - 1) % le];\n          continue;\n        }\n\n        // Now we know that S[i] is a path component\n        if (first === null) {\n          // Start the component if it is not yet started.\n          first = i;\n          components.push(first);\n        }\n        if (this._isSeparator(S[(i + 1) % le]) || i === le - 1) {\n          // If the next node is a component separator or if the node is the last node,\n          // then we close the loop\n\n          S[i]._next = S[first];\n          S[first]._prev = S[i];\n          S[i]._end = true;\n          first = null;\n        } else {\n          // Here, we are not at the end of component\n          S[i]._next = S[(i + 1) % le];\n          S[first]._prev = S[i];\n        }\n        if (!this._isSeparator(S[(le + i - 1) % le])) {\n          S[i]._prev = S[(le + i - 1) % le];\n        }\n      }\n    }\n    return components;\n  },\n  /**\n   * JavaScript object containing the intersection of two paths. Every intersection point is on one path, but\n   * comes with a neighbour point having the same coordinates and being on the other path.\n   *\n   * The intersection point is inserted into the doubly linked list of the path.\n   *\n   * @private\n   * @param  {JXG.Coords} coords JSXGraph Coords object containing the coordinates of the intersection\n   * @param  {Number} i        Number of the segment of the subject path (first path) containing the intersection.\n   * @param  {Number} alpha    The intersection is a p_1 + alpha*(p_2 - p_1), where p_1 and p_2 are the end points\n   *      of the i-th segment.\n   * @param  {Array} path      Pointer to the path containing the intersection point\n   * @param  {String} pathname Name of the path: 'S' or 'C'.\n   */\n  Vertex: function (coords, i, alpha, path, pathname, type) {\n    this.pos = i;\n    this.intersection = true;\n    this.coords = coords;\n    this.elementClass = Const.OBJECT_CLASS_POINT;\n    this.data = {\n      alpha: alpha,\n      path: path,\n      pathname: pathname,\n      done: false,\n      type: type,\n      idx: 0\n    };\n\n    // Set after initialisation\n    this.neighbour = null;\n    this.entry_exit = false;\n  },\n  _addToList: function (list, coords, pos) {\n    var len = list.length,\n      eps = Mat.eps * Mat.eps;\n    if (len > 0 && Math.abs(list[len - 1].coords.usrCoords[0] - coords.usrCoords[0]) < eps && Math.abs(list[len - 1].coords.usrCoords[1] - coords.usrCoords[1]) < eps && Math.abs(list[len - 1].coords.usrCoords[2] - coords.usrCoords[2]) < eps) {\n      // Skip point\n      return;\n    }\n    list.push({\n      pos: pos,\n      intersection: false,\n      coords: coords,\n      elementClass: Const.OBJECT_CLASS_POINT\n    });\n  },\n  /**\n   * Sort the intersection points into their path.\n   * @private\n   * @param  {Array} P_crossings Array of arrays. Each array contains the intersections of the path\n   *      with one segment of the other path.\n   * @return {Array}  Array of intersection points ordered by first occurrence in the path.\n   */\n  sortIntersections: function (P_crossings) {\n    var i,\n      j,\n      P,\n      Q,\n      last,\n      next_node,\n      P_intersect = [],\n      P_le = P_crossings.length;\n    for (i = 0; i < P_le; i++) {\n      P_crossings[i].sort(function (a, b) {\n        return a.data.alpha > b.data.alpha ? 1 : -1;\n      });\n      if (P_crossings[i].length > 0) {\n        // console.log(\"Crossings\", P_crossings[i])\n        last = P_crossings[i].length - 1;\n        P = P_crossings[i][0];\n\n        //console.log(\"SORT\", P.coords.usrCoords)\n        Q = P.data.path[P.pos];\n        next_node = Q._next; // Store the next \"normal\" node\n\n        if (i === P_le - 1) {\n          Q._end = false;\n        }\n        if (P.data.alpha === 0.0 && P.data.type === \"T\") {\n          // console.log(\"SKIP\", P.coords.usrCoords, P.data.type, P.neighbour.data.type);\n          Q.intersection = true;\n          Q.data = P.data;\n          Q.neighbour = P.neighbour;\n          Q.neighbour.neighbour = Q;\n          Q.entry_exit = false;\n          P_crossings[i][0] = Q;\n        } else {\n          // Insert the first intersection point\n          P._prev = Q;\n          P._prev._next = P;\n        }\n\n        // Insert the other intersection points, but the last\n        for (j = 1; j <= last; j++) {\n          P = P_crossings[i][j];\n          P._prev = P_crossings[i][j - 1];\n          P._prev._next = P;\n        }\n\n        // Link last intersection point to the next node\n        P = P_crossings[i][last];\n        P._next = next_node;\n        P._next._prev = P;\n        if (i === P_le - 1) {\n          P._end = true;\n          //console.log(\"END\", P._end, P.coords.usrCoords, P._prev.coords.usrCoords, P._next.coords.usrCoords);\n        }\n        P_intersect = P_intersect.concat(P_crossings[i]);\n      }\n    }\n    return P_intersect;\n  },\n  _inbetween: function (q, p1, p2) {\n    var alpha,\n      eps = Mat.eps * Mat.eps,\n      px = p2[1] - p1[1],\n      py = p2[2] - p1[2],\n      qx = q[1] - p1[1],\n      qy = q[2] - p1[2];\n    if (px === 0 && py === 0 && qx === 0 && qy === 0) {\n      // All three points are equal\n      return true;\n    }\n    if (Math.abs(qx) < eps && Math.abs(px) < eps) {\n      alpha = qy / py;\n    } else {\n      alpha = qx / px;\n    }\n    if (Math.abs(alpha) < eps) {\n      alpha = 0.0;\n    }\n    return alpha;\n  },\n  _print_array: function (arr) {\n    var i, end;\n    for (i = 0; i < arr.length; i++) {\n      //console.log(i, arr[i].coords.usrCoords,  arr[i].data.type);\n      try {\n        end = \"\";\n        if (arr[i]._end) {\n          end = \" end\";\n        }\n        console.log(i, arr[i].coords.usrCoords, arr[i].data.type, \"\\t\", \"prev\", arr[i]._prev.coords.usrCoords, \"next\", arr[i]._next.coords.usrCoords + end);\n      } catch (e) {\n        console.log(i, arr[i].coords.usrCoords);\n      }\n    }\n  },\n  _print_list: function (P) {\n    var cnt = 0,\n      alpha;\n    while (cnt < 100) {\n      if (P.data) {\n        alpha = P.data.alpha;\n      } else {\n        alpha = \"-\";\n      }\n      console.log(\"\\t\", P.coords.usrCoords, \"\\n\\t\\tis:\", P.intersection, \"end:\", P._end, alpha, \"\\n\\t\\t-:\", P._prev.coords.usrCoords, \"\\n\\t\\t+:\", P._next.coords.usrCoords, \"\\n\\t\\tn:\", P.intersection ? P.neighbour.coords.usrCoords : \"-\");\n      if (P._end) {\n        break;\n      }\n      P = P._next;\n      cnt++;\n    }\n  },\n  _noOverlap: function (p1, p2, q1, q2) {\n    var k,\n      eps = Math.sqrt(Mat.eps),\n      minp,\n      maxp,\n      minq,\n      maxq,\n      no_overlap = false;\n    for (k = 0; k < 3; k++) {\n      minp = Math.min(p1[k], p2[k]);\n      maxp = Math.max(p1[k], p2[k]);\n      minq = Math.min(q1[k], q2[k]);\n      maxq = Math.max(q1[k], q2[k]);\n      if (maxp < minq - eps || minp > maxq + eps) {\n        no_overlap = true;\n        break;\n      }\n    }\n    return no_overlap;\n  },\n  /**\n   * Find all intersections between two paths.\n   * @private\n   * @param  {Array} S     Subject path\n   * @param  {Array} C     Clip path\n   * @param  {JXG.Board} board JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}  Array containing two arrays. The first array contains the intersection vertices\n   * of the subject path and the second array contains the intersection vertices of the clip path.\n   * @see JXG.Clip#Vertex\n   */\n  findIntersections: function (S, C, board) {\n    var res = [],\n      eps = Mat.eps * 100,\n      i,\n      j,\n      crds,\n      S_le = S.length,\n      C_le = C.length,\n      Si,\n      Si1,\n      Cj,\n      Cj1,\n      d1,\n      d2,\n      alpha,\n      type,\n      IS,\n      IC,\n      S_intersect = [],\n      C_intersect = [],\n      S_crossings = [],\n      C_crossings = [],\n      hasMultCompsS = false,\n      hasMultCompsC = false,\n      DEBUG = false;\n    for (j = 0; j < C_le; j++) {\n      C_crossings.push([]);\n    }\n\n    // Run through the subject path.\n    for (i = 0; i < S_le; i++) {\n      S_crossings.push([]);\n\n      // Test if S[i] or its successor is a path separator.\n      // If yes, we know that the path consists of multiple components.\n      // We immediately jump to the next segment.\n      if (this._isSeparator(S[i]) || this._isSeparator(S[(i + 1) % S_le])) {\n        hasMultCompsS = true;\n        continue;\n      }\n\n      // If the path consists of multiple components then there is\n      // no path-closing segment between the last node and the first\n      // node. In this case we can leave the loop now.\n      if (hasMultCompsS && i === S_le - 1) {\n        break;\n      }\n      Si = S[i].coords.usrCoords;\n      Si1 = S[(i + 1) % S_le].coords.usrCoords;\n      // Run through the clip path.\n      for (j = 0; j < C_le; j++) {\n        // Test if C[j] or its successor is a path separator.\n        // If yes, we know that the path consists of multiple components.\n        // We immediately jump to the next segment.\n        if (this._isSeparator(C[j]) || this._isSeparator(C[(j + 1) % C_le])) {\n          hasMultCompsC = true;\n          continue;\n        }\n\n        // If the path consists of multiple components then there is\n        // no path-closing segment between the last node and the first\n        // node. In this case we can leave the loop now.\n        if (hasMultCompsC && j === C_le - 1) {\n          break;\n        }\n\n        // Test if bounding boxes of the two curve segments overlap\n        // If not, the expensive intersection test can be skipped.\n        Cj = C[j].coords.usrCoords;\n        Cj1 = C[(j + 1) % C_le].coords.usrCoords;\n        if (this._noOverlap(Si, Si1, Cj, Cj1)) {\n          continue;\n        }\n\n        // Intersection test\n        res = Geometry.meetSegmentSegment(Si, Si1, Cj, Cj1);\n        d1 = Geometry.distance(Si, Si1, 3);\n        d2 = Geometry.distance(Cj, Cj1, 3);\n\n        // Found an intersection point\n        if (\n        // \"Regular\" intersection\n        res[1] * d1 > -eps && res[1] < 1 - eps / d1 && res[2] * d2 > -eps && res[2] < 1 - eps / d2 ||\n        // Collinear segments\n        res[1] === Infinity && res[2] === Infinity && Mat.norm(res[0], 3) < eps) {\n          crds = new Coords(Const.COORDS_BY_USER, res[0], board);\n          type = \"X\";\n\n          // Handle degenerated cases\n          if (Math.abs(res[1]) * d1 < eps || Math.abs(res[2]) * d2 < eps) {\n            // Crossing / bouncing at vertex or\n            // end of delayed crossing / bouncing\n            type = \"T\";\n            if (Math.abs(res[1]) * d1 < eps) {\n              res[1] = 0;\n            }\n            if (Math.abs(res[2]) * d2 < eps) {\n              res[2] = 0;\n            }\n            if (res[1] === 0) {\n              crds = new Coords(Const.COORDS_BY_USER, Si, board);\n            } else {\n              crds = new Coords(Const.COORDS_BY_USER, Cj, board);\n            }\n            if (DEBUG) {\n              console.log(\"Degenerate case I\", res[1], res[2], crds.usrCoords, \"type\", type);\n            }\n          } else if (res[1] === Infinity && res[2] === Infinity && Mat.norm(res[0], 3) < eps) {\n            // console.log(C_intersect);\n\n            // Collinear segments\n            // Here, there might be two intersection points to be added\n\n            alpha = this._inbetween(Si, Cj, Cj1);\n            if (DEBUG) {\n              // console.log(\"alpha Si\", alpha, Si);\n              // console.log(j, Cj)\n              // console.log((j + 1) % C_le, Cj1)\n            }\n            if (alpha >= 0 && alpha < 1) {\n              type = \"T\";\n              crds = new Coords(Const.COORDS_BY_USER, Si, board);\n              res[1] = 0;\n              res[2] = alpha;\n              IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n              IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n              IS.neighbour = IC;\n              IC.neighbour = IS;\n              S_crossings[i].push(IS);\n              C_crossings[j].push(IC);\n              if (DEBUG) {\n                console.log(\"Degenerate case II\", res[1], res[2], crds.usrCoords, \"type T\");\n              }\n            }\n            alpha = this._inbetween(Cj, Si, Si1);\n            if (DEBUG) {\n              // console.log(\"alpha Cj\", alpha, Si, Geometry.distance(Si, Cj, 3));\n            }\n            if (Geometry.distance(Si, Cj, 3) > eps && alpha >= 0 && alpha < 1) {\n              type = \"T\";\n              crds = new Coords(Const.COORDS_BY_USER, Cj, board);\n              res[1] = alpha;\n              res[2] = 0;\n              IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n              IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n              IS.neighbour = IC;\n              IC.neighbour = IS;\n              S_crossings[i].push(IS);\n              C_crossings[j].push(IC);\n              if (DEBUG) {\n                console.log(\"Degenerate case III\", res[1], res[2], crds.usrCoords, \"type T\");\n              }\n            }\n            continue;\n          }\n          if (DEBUG) {\n            console.log(\"IS\", i, j, crds.usrCoords, type);\n          }\n          IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n          IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n          IS.neighbour = IC;\n          IC.neighbour = IS;\n          S_crossings[i].push(IS);\n          C_crossings[j].push(IC);\n        }\n      }\n    }\n\n    // For both paths, sort their intersection points\n    S_intersect = this.sortIntersections(S_crossings);\n    if (DEBUG) {\n      console.log(\">>>>>> Intersections \");\n      console.log(\"S_intersect\");\n      this._print_array(S_intersect);\n      console.log(\"----------\");\n    }\n    for (i = 0; i < S_intersect.length; i++) {\n      S_intersect[i].data.idx = i;\n      S_intersect[i].neighbour.data.idx = i;\n    }\n    C_intersect = this.sortIntersections(C_crossings);\n    if (DEBUG) {\n      console.log(\"C_intersect\");\n      this._print_array(C_intersect);\n      console.log(\"<<<<<< Phase 1 done\");\n    }\n    return [S_intersect, C_intersect];\n  },\n  /**\n   * It is testedd if the point q lies to the left or right\n   * of the poylgonal chain [p1, p2, p3].\n   * @param {Array} q User coords array\n   * @param {Array} p1 User coords array\n   * @param {Array} p2 User coords array\n   * @param {Array} p3 User coords array\n   * @returns string 'left' or 'right'\n   * @private\n   */\n  _getPosition: function (q, p1, p2, p3) {\n    var s1 = Geometry.det3p(q, p1, p2),\n      s2 = Geometry.det3p(q, p2, p3),\n      s3 = Geometry.det3p(p1, p2, p3);\n\n    // Left turn\n    if (s3 >= 0) {\n      if (s1 >= 0 && s2 >= 0) {\n        return \"left\";\n      }\n      return \"right\";\n    }\n    // Right turn\n    if (s1 >= 0 || s2 >= 0) {\n      return \"left\";\n    }\n    return \"right\";\n  },\n  /**\n   * Determine the delayed status of degenerated intersection points.\n   * It is of the form\n   *   ['on|left|right', 'on|left|right']\n   * <p>\n   * If all four determinants are zero, we add random noise to the point.\n   *\n   * @param {JXG.Math.Clip.Vertex} P Start of path\n   * @private\n   * @see JXG.Math.Clip#markEntryExit\n   * @see JXG.Math.Clip#_handleIntersectionChains\n   */\n  _classifyDegenerateIntersections: function (P) {\n    var Pp,\n      Pm,\n      Qp,\n      Qm,\n      Q,\n      side,\n      cnt,\n      tmp,\n      det,\n      oppositeDir,\n      s1,\n      s2,\n      s3,\n      s4,\n      endless = true,\n      DEBUG = false;\n    if (DEBUG) {\n      console.log(\"\\n-------------- _classifyDegenerateIntersections()\", Type.exists(P.data) ? P.data.pathname : \" \");\n    }\n    det = Geometry.det3p;\n    cnt = 0;\n    P._tours = 0;\n    while (endless) {\n      if (DEBUG) {\n        console.log(\"Inspect P:\", P.coords.usrCoords, P.data ? P.data.type : \" \");\n      }\n      if (P.intersection && P.data.type === \"T\") {\n        // Handle the degenerate cases\n        // Decide if they are (delayed) bouncing or crossing intersections\n        Pp = P._next.coords.usrCoords; // P+\n        Pm = P._prev.coords.usrCoords; // P-\n\n        // If the intersection point is degenerated and\n        // equal to the start and end of one component,\n        // then there will be two adjacent points with\n        // the same coordinate.\n        // In that case, we proceed to the next node.\n        if (Geometry.distance(P.coords.usrCoords, Pp, 3) < Mat.eps) {\n          Pp = P._next._next.coords.usrCoords;\n        }\n        if (Geometry.distance(P.coords.usrCoords, Pm, 3) < Mat.eps) {\n          Pm = P._prev._prev.coords.usrCoords;\n        }\n        Q = P.neighbour;\n        Qm = Q._prev.coords.usrCoords; // Q-\n        Qp = Q._next.coords.usrCoords; // Q+\n        if (Geometry.distance(Q.coords.usrCoords, Qp, 3) < Mat.eps) {\n          Qp = Q._next._next.coords.usrCoords;\n        }\n        if (Geometry.distance(Q.coords.usrCoords, Qm, 3) < Mat.eps) {\n          Qm = Q._prev._prev.coords.usrCoords;\n        }\n        if (DEBUG) {\n          console.log(\"P chain:\", Pm, P.coords.usrCoords, Pp);\n          console.log(\"Q chain:\", Qm, P.neighbour.coords.usrCoords, Qp);\n          console.log(\"Pm\", this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp));\n          console.log(\"Pp\", this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp));\n        }\n        s1 = det(P.coords.usrCoords, Pm, Qm);\n        s2 = det(P.coords.usrCoords, Pp, Qp);\n        s3 = det(P.coords.usrCoords, Pm, Qp);\n        s4 = det(P.coords.usrCoords, Pp, Qm);\n        if (s1 === 0 && s2 === 0 && s3 === 0 && s4 === 0) {\n          P.coords.usrCoords[1] *= 1 + Math.random() * Mat.eps;\n          P.coords.usrCoords[2] *= 1 + Math.random() * Mat.eps;\n          Q.coords.usrCoords[1] = P.coords.usrCoords[1];\n          Q.coords.usrCoords[2] = P.coords.usrCoords[2];\n          s1 = det(P.coords.usrCoords, Pm, Qm);\n          s2 = det(P.coords.usrCoords, Pp, Qp);\n          s3 = det(P.coords.usrCoords, Pm, Qp);\n          s4 = det(P.coords.usrCoords, Pp, Qm);\n          if (DEBUG) {\n            console.log(\"Random shift\", P.coords.usrCoords);\n            console.log(s1, s2, s3, s4, s2 === 0);\n            console.log(this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp), this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp));\n          }\n        }\n        oppositeDir = false;\n        if (s1 === 0) {\n          // Q-, Q=P, P- on straight line\n          if (Geometry.affineRatio(P.coords.usrCoords, Pm, Qm) < 0) {\n            oppositeDir = true;\n          }\n        } else if (s2 === 0) {\n          if (Geometry.affineRatio(P.coords.usrCoords, Pp, Qp) < 0) {\n            oppositeDir = true;\n          }\n        } else if (s3 === 0) {\n          if (Geometry.affineRatio(P.coords.usrCoords, Pm, Qp) > 0) {\n            oppositeDir = true;\n          }\n        } else if (s4 === 0) {\n          if (Geometry.affineRatio(P.coords.usrCoords, Pp, Qm) > 0) {\n            oppositeDir = true;\n          }\n        }\n        if (oppositeDir) {\n          // Swap Qm and Qp\n          // Then Qm Q Qp has the same direction as Pm P Pp\n          tmp = Qm;\n          Qm = Qp;\n          Qp = tmp;\n          tmp = s1;\n          s1 = s3;\n          s3 = tmp;\n          tmp = s2;\n          s2 = s4;\n          s4 = tmp;\n        }\n        if (DEBUG) {\n          console.log(s1, s2, s3, s4, oppositeDir);\n        }\n        if (!Type.exists(P.delayedStatus)) {\n          P.delayedStatus = [];\n        }\n        if (s1 === 0 && s2 === 0) {\n          // Line [P-,P] equals [Q-,Q] and line [P,P+] equals [Q,Q+]\n          // Interior of delayed crossing / bouncing\n          P.delayedStatus = [\"on\", \"on\"];\n        } else if (s1 === 0) {\n          // P- on line [Q-,Q], P+ not on line [Q,Q+]\n          // Begin / end of delayed crossing / bouncing\n          side = this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp);\n          P.delayedStatus = [\"on\", side];\n        } else if (s2 === 0) {\n          // P+ on line [Q,Q+], P- not on line [Q-,Q]\n          // Begin / end of delayed crossing / bouncing\n          side = this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp);\n          P.delayedStatus = [side, \"on\"];\n        } else {\n          // Neither P+ on line [Q,Q+], nor P- on line [Q-,Q]\n          // No delayed crossing / bouncing\n          if (P.delayedStatus.length === 0) {\n            if (this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp) !== this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)) {\n              P.data.type = \"X\";\n            } else {\n              P.data.type = \"B\";\n            }\n          }\n        }\n        if (DEBUG) {\n          console.log(\">>>> P:\", P.coords.usrCoords, \"delayedStatus:\", P.delayedStatus.toString(), P.data ? P.data.type : \" \", \"\\n---\");\n        }\n      }\n      if (Type.exists(P._tours)) {\n        P._tours++;\n      }\n      if (P._tours > 3 || P._end || cnt > 1000) {\n        // Jump out if either\n        // - we reached the end\n        // - there are more than 1000 intersection points\n        // - P._tours > 3: We went already 4 times through this path.\n        if (cnt > 1000) {\n          console.log(\"Clipping: _classifyDegenerateIntersections exit\");\n        }\n        if (Type.exists(P._tours)) {\n          delete P._tours;\n        }\n        break;\n      }\n      if (P.intersection) {\n        cnt++;\n      }\n      P = P._next;\n    }\n    if (DEBUG) {\n      console.log(\"------------------------\");\n    }\n  },\n  /**\n   * At this point the degenerated intersections have been classified.\n   * Now we decide if the intersection chains of the given path\n   * ultimatively cross the other path or bounce.\n   *\n   * @param {JXG.Math.Clip.Vertex} P Start of path\n   *\n   * @see JXG.Math.Clip#markEntryExit\n   * @see JXG.Math.Clip#_classifyDegenerateIntersections\n   * @private\n   */\n  _handleIntersectionChains: function (P) {\n    var cnt = 0,\n      start_status = \"Null\",\n      P_start,\n      endless = true,\n      intersection_chain = false,\n      wait_for_exit = false,\n      DEBUG = false;\n    if (DEBUG) {\n      console.log(\"\\n-------------- _handleIntersectionChains()\", Type.exists(P.data) ? P.data.pathname : \" \");\n    }\n    while (endless) {\n      if (P.intersection === true) {\n        if (DEBUG) {\n          if (P.data.type === \"T\") {\n            console.log(\"Degenerate point\", P.coords.usrCoords, P.data.type, P.data.type === \"T\" ? P.delayedStatus : \" \");\n          } else {\n            console.log(\"Intersection point\", P.coords.usrCoords, P.data.type);\n          }\n        }\n        if (P.data.type === \"T\") {\n          if (P.delayedStatus[0] !== \"on\" && P.delayedStatus[1] === \"on\") {\n            // First point of intersection chain\n            intersection_chain = true;\n            P_start = P;\n            start_status = P.delayedStatus[0];\n          } else if (intersection_chain && P.delayedStatus[0] === \"on\" && P.delayedStatus[1] === \"on\") {\n            // Interior of intersection chain\n            P.data.type = \"B\";\n            if (DEBUG) {\n              console.log(\"Interior\", P.coords.usrCoords);\n            }\n          } else if (intersection_chain && P.delayedStatus[0] === \"on\" && P.delayedStatus[1] !== \"on\") {\n            // Last point of intersection chain\n            intersection_chain = false;\n            if (start_status === P.delayedStatus[1]) {\n              // Intersection chain is delayed bouncing\n              P_start.data.type = \"DB\";\n              P.data.type = \"DB\";\n              if (DEBUG) {\n                console.log(\"Chain: delayed bouncing\", P_start.coords.usrCoords, \"...\", P.coords.usrCoords);\n              }\n            } else {\n              // Intersection chain is delayed crossing\n              P_start.data.type = \"DX\";\n              P.data.type = \"DX\";\n              if (DEBUG) {\n                console.log(\"Chain: delayed crossing\", P_start.coords.usrCoords, \"...\", P.coords.usrCoords);\n              }\n            }\n          }\n        }\n        cnt++;\n      }\n      if (P._end) {\n        wait_for_exit = true;\n      }\n      if (wait_for_exit && !intersection_chain) {\n        break;\n      }\n      if (cnt > 1000) {\n        console.log(\"Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations\");\n        break;\n      }\n      P = P._next;\n    }\n  },\n  /**\n   * Handle the case that all vertices of one path are contained\n   * in the other path. In this case we search for a midpoint of an edge\n   * which is not contained in the other path and add it to the path.\n   * It will be used as starting point for the entry/exit algorithm.\n   *\n   * @private\n   * @param {Array} S Subject path\n   * @param {Array} C Clip path\n   * @param {JXG.board} board JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   */\n  _handleFullyDegenerateCase: function (S, C, board) {\n    var P,\n      Q,\n      l,\n      M,\n      crds,\n      q1,\n      q2,\n      node,\n      i,\n      j,\n      leP,\n      leQ,\n      is_on_Q,\n      tmp,\n      is_fully_degenerated,\n      arr = [S, C];\n    for (l = 0; l < 2; l++) {\n      P = arr[l];\n      leP = P.length;\n      for (i = 0, is_fully_degenerated = true; i < leP; i++) {\n        if (!P[i].intersection) {\n          is_fully_degenerated = false;\n          break;\n        }\n      }\n      if (is_fully_degenerated) {\n        // All nodes of P are also on the other path.\n        Q = arr[(l + 1) % 2];\n        leQ = Q.length;\n\n        // We search for a midpoint of one edge of P which is not the other path and\n        // we add that midpoint to P.\n        for (i = 0; i < leP; i++) {\n          q1 = P[i].coords.usrCoords;\n          q2 = P[i]._next.coords.usrCoords;\n\n          // M is the midpoint\n          M = [(q1[0] + q2[0]) * 0.5, (q1[1] + q2[1]) * 0.5, (q1[2] + q2[2]) * 0.5];\n\n          // Test if M is on path Q. If this is not the case,\n          // we take M as additional point of P.\n          for (j = 0, is_on_Q = false; j < leQ; j++) {\n            if (Math.abs(Geometry.det3p(Q[j].coords.usrCoords, Q[(j + 1) % leQ].coords.usrCoords, M)) < Mat.eps) {\n              is_on_Q = true;\n              break;\n            }\n          }\n          if (!is_on_Q) {\n            // The midpoint is added to the doubly-linked list.\n            crds = new Coords(Const.COORDS_BY_USER, M, board);\n            node = {\n              pos: i,\n              intersection: false,\n              coords: crds,\n              elementClass: Const.OBJECT_CLASS_POINT\n            };\n            tmp = P[i]._next;\n            P[i]._next = node;\n            node._prev = P[i];\n            node._next = tmp;\n            tmp._prev = node;\n            if (P[i]._end) {\n              P[i]._end = false;\n              node._end = true;\n            }\n            break;\n          }\n        }\n      }\n    }\n  },\n  _getStatus: function (P, path) {\n    var status;\n    while (P.intersection) {\n      if (P._end) {\n        break;\n      }\n      P = P._next;\n    }\n    if (Geometry.windingNumber(P.coords.usrCoords, path) === 0) {\n      // Outside\n      status = \"entry\";\n      // console.log(P.coords.usrCoords, ' is outside')\n    } else {\n      // Inside\n      status = \"exit\";\n      // console.log(P.coords.usrCoords, ' is inside')\n    }\n    return [P, status];\n  },\n  /**\n   * Mark the intersection vertices of path1 as entry points or as exit points\n   * in respect to path2.\n   * <p>\n   * This is the simple algorithm as in\n   * Greiner, Günther; Kai Hormann (1998). \"Efficient clipping of arbitrary polygons\".\n   * ACM Transactions on Graphics. 17 (2): 71–83\n   * <p>\n   * The algorithm handles also \"delayed crossings\" from\n   * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n   * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n   * and - as an additional improvement -\n   * handles self intersections of delayed crossings (A.W. 2021).\n   *\n   * @private\n   * @param  {Array} path1 First path\n   * @param  {Array} path2 Second path\n   */\n  markEntryExit: function (path1, path2, starters) {\n    var status,\n      P,\n      cnt,\n      res,\n      i,\n      len,\n      start,\n      endless = true,\n      chain_start = null,\n      intersection_chain = 0,\n      DEBUG = false;\n    len = starters.length;\n    for (i = 0; i < len; i++) {\n      start = starters[i];\n      if (DEBUG) {\n        console.log(\"\\n;;;;;;;;;; Labelling phase\", Type.exists(path1[start].data) ? path1[start].data.pathname : \" \", path1[start].coords.usrCoords);\n      }\n      this._classifyDegenerateIntersections(path1[start]);\n      this._handleIntersectionChains(path1[start]);\n      if (DEBUG) {\n        console.log(\"\\n---- back to markEntryExit\");\n      }\n\n      // Decide if the first point of the component is inside or outside\n      // of the other path.\n      res = this._getStatus(path1[start], path2);\n      P = res[0];\n      status = res[1];\n      if (DEBUG) {\n        console.log(\"Start node:\", P.coords.usrCoords, status);\n      }\n      P._starter = true;\n\n      // Greiner-Hormann entry/exit algorithm\n      // with additional handling of delayed crossing / bouncing\n      cnt = 0;\n      chain_start = null;\n      intersection_chain = 0;\n      while (endless) {\n        if (P.intersection === true) {\n          if (P.data.type === \"X\" && intersection_chain === 1) {\n            // While we are in an intersection chain, i.e. a delayed crossing,\n            // we stumble on a crossing intersection.\n            // Probably, the other path is self intersecting.\n            // We end the intersection chain here and\n            // mark this event by setting intersection_chain = 2.\n            chain_start.entry_exit = status;\n            if (status === \"exit\") {\n              chain_start.data.type = \"X\";\n            }\n            intersection_chain = 2;\n          }\n          if (P.data.type === \"X\" || P.data.type === \"DB\") {\n            P.entry_exit = status;\n            status = status === \"entry\" ? \"exit\" : \"entry\";\n            if (DEBUG) {\n              console.log(\"mark:\", P.coords.usrCoords, P.data.type, P.entry_exit);\n            }\n          }\n          if (P.data.type === \"DX\") {\n            if (intersection_chain === 0) {\n              // Start of intersection chain.\n              // No active intersection chain yet,\n              // i.e. we did not pass a the first node of a delayed crossing.\n              chain_start = P;\n              intersection_chain = 1;\n              if (DEBUG) {\n                console.log(\"Start intersection chain:\", P.coords.usrCoords, P.data.type, status);\n              }\n            } else if (intersection_chain === 1) {\n              // Active intersection chain (intersection_chain===1)!\n              // End of delayed crossing chain reached\n              P.entry_exit = status;\n              chain_start.entry_exit = status;\n              if (status === \"exit\") {\n                chain_start.data.type = \"X\";\n              } else {\n                P.data.type = \"X\";\n              }\n              status = status === \"entry\" ? \"exit\" : \"entry\";\n              if (DEBUG) {\n                console.log(\"mark':\", chain_start.coords.usrCoords, chain_start.data.type, chain_start.entry_exit);\n                console.log(\"mark:\", P.coords.usrCoords, P.data.type, P.entry_exit);\n              }\n              chain_start = null;\n              intersection_chain = 0;\n            } else if (intersection_chain === 2) {\n              // The delayed crossing had been interrupted by a crossing intersection.\n              // Now we treat the end of the delayed crossing as regular crossing.\n              P.entry_exit = status;\n              P.data.type = \"X\";\n              status = status === \"entry\" ? \"exit\" : \"entry\";\n              chain_start = null;\n              intersection_chain = 0;\n            }\n          }\n        }\n        P = P._next;\n        if (Type.exists(P._starter) || cnt > 10000) {\n          break;\n        }\n        cnt++;\n      }\n    }\n  },\n  /**\n   *\n   * @private\n   * @param {Array} P\n   * @param {Boolean} isBackward\n   * @returns {Boolean} True, if the node is an intersection and is of type 'X'\n   */\n  _stayOnPath: function (P, status) {\n    var stay = true;\n    if (P.intersection && P.data.type !== \"B\") {\n      stay = status === P.entry_exit;\n    }\n    return stay;\n  },\n  /**\n   * Add a point to the clipping path and returns if the algorithms\n   * arrived at an intersection point which has already been visited.\n   * In this case, true is returned.\n   *\n   * @param {Array} path Resulting path\n   * @param {JXG.Math.Clip.Vertex} vertex Point to be added\n   * @param {Boolean} DEBUG debug output to console.log\n   * @returns {Boolean} true: point has been visited before, false otherwise\n   * @private\n   */\n  _addVertex: function (path, vertex, DEBUG) {\n    if (!isNaN(vertex.coords.usrCoords[1]) && !isNaN(vertex.coords.usrCoords[2])) {\n      path.push(vertex);\n    }\n    if (vertex.intersection && vertex.data.done) {\n      if (DEBUG) {\n        console.log(\"Add last intersection point\", vertex.coords.usrCoords, \"on\", vertex.data.pathname, vertex.entry_exit, vertex.data.type);\n      }\n      return true;\n    }\n    if (vertex.intersection) {\n      vertex.data.done = true;\n      if (DEBUG) {\n        console.log(\"Add intersection point\", vertex.coords.usrCoords, \"on\", vertex.data.pathname, vertex.entry_exit, vertex.data.type);\n      }\n    }\n    return false;\n  },\n  /**\n   * Tracing phase of the Greiner-Hormann algorithm, see\n   * Greiner, Günther; Kai Hormann (1998).\n   * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71–83\n   *\n   * Boolean operations on polygons are distinguished: 'intersection', 'union', 'difference'.\n   *\n   * @private\n   * @param  {Array} S           Subject path\n   * @param  {Array} S_intersect Array containing the intersection vertices of the subject path\n   * @param  {String} clip_type  contains the Boolean operation: 'intersection', 'union', or 'difference'\n   * @return {Array}             Array consisting of two arrays containing the x-coordinates and the y-coordintaes of\n   *      the resulting path.\n   */\n  tracing: function (S, S_intersect, clip_type) {\n    var P,\n      status,\n      current,\n      start,\n      cnt = 0,\n      maxCnt = 10000,\n      S_idx = 0,\n      path = [],\n      done = false,\n      DEBUG = false;\n    if (DEBUG) {\n      console.log(\"\\n------ Start Phase 3\");\n    }\n\n    // reverse = (clip_type === 'difference' || clip_type === 'union') ? true : false;\n    while (S_idx < S_intersect.length && cnt < maxCnt) {\n      // Take the first intersection node of the subject path\n      // which is not yet included as start point.\n      current = S_intersect[S_idx];\n      if (current.data.done || current.data.type !== \"X\" /*|| !this._isCrossing(current, reverse)*/) {\n        S_idx++;\n        continue;\n      }\n      if (DEBUG) {\n        console.log(\"\\nStart\", current.data.pathname, current.coords.usrCoords, current.data.type, current.entry_exit, S_idx);\n      }\n      if (path.length > 0) {\n        // Add a new path\n        path.push([NaN, NaN]);\n      }\n\n      // Start now the tracing with that node of the subject path\n      start = current.data.idx;\n      P = S;\n      done = this._addVertex(path, current, DEBUG);\n      status = current.entry_exit;\n      do {\n        if (done) {\n          break;\n        }\n        //\n        // Decide if we follow the current path forward or backward.\n        // for example, in case the clipping is of type \"intersection\"\n        // and the current intersection node is of type entry, we go forward.\n        //\n        if (clip_type === \"intersection\" && current.entry_exit === \"entry\" || clip_type === \"union\" && current.entry_exit === \"exit\" || clip_type === \"difference\" && P === S === (current.entry_exit === \"exit\")) {\n          if (DEBUG) {\n            console.log(\"Go forward on\", current.data.pathname, current.entry_exit);\n          }\n\n          //\n          // Take the next nodes and add them to the path\n          // as long as they are not intersection nodes of type 'X'.\n          //\n          do {\n            current = current._next;\n            done = this._addVertex(path, current, DEBUG);\n            if (done) {\n              break;\n            }\n          } while (this._stayOnPath(current, status));\n          cnt++;\n        } else {\n          if (DEBUG) {\n            console.log(\"Go backward on\", current.data.pathname);\n          }\n          //\n          // Here, we go backward:\n          // Take the previous nodes and add them to the path\n          // as long as they are not intersection nodes of type 'X'.\n          //\n          do {\n            current = current._prev;\n            done = this._addVertex(path, current, DEBUG);\n            if (done) {\n              break;\n            }\n          } while (this._stayOnPath(current, status));\n          cnt++;\n        }\n        if (done) {\n          break;\n        }\n        if (!current.neighbour) {\n          console.log(\"Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!\", cnt);\n          return [[0], [0]];\n        }\n        //\n        // We stopped the forward or backward loop, because we've\n        // arrived at a crossing intersection node, i.e. we have to\n        // switch to the other path now.\n        if (DEBUG) {\n          console.log(\"Switch from\", current.coords.usrCoords, current.data.pathname, \"to\", current.neighbour.coords.usrCoords, \"on\", current.neighbour.data.pathname);\n        }\n        current = current.neighbour;\n        if (current.data.done) {\n          break;\n        }\n        current.data.done = true;\n        status = current.entry_exit;\n\n        // if (current.data.done) {\n        //     // We arrived at an intersection node which is already\n        //     // added to the clipping path.\n        //     // We add it again to close the clipping path and jump out of the\n        //     // loop.\n        //     path.push(current);\n        //     if (DEBUG) {\n        //         console.log(\"Push last\", current.coords.usrCoords);\n        //     }\n        //     break;\n        // }\n        P = current.data.path;\n\n        // Polygon closed:\n        // if (DEBUG) {\n        //     console.log(\"End of loop:\", \"start=\", start, \"idx=\", current.data.idx);\n        // }\n        // } while (!(current.data.pathname === 'S' && current.data.idx === start) && cnt < maxCnt);\n      } while (current.data.idx !== start && cnt < maxCnt);\n      if (cnt >= maxCnt) {\n        console.log(\"Tracing: stopping an infinite loop!\", cnt);\n      }\n      S_idx++;\n    }\n    return this._getCoordsArrays(path, false);\n  },\n  /**\n   * Handle path clipping if one of the two paths is empty.\n   * @private\n   * @param  {Array} S        First path, array of JXG.Coords\n   * @param  {Array} C        Second path, array of JXG.Coords\n   * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n   * @return {Boolean}        true, if one of the input paths is empty, false otherwise.\n   */\n  isEmptyCase: function (S, C, clip_type) {\n    if (clip_type === \"intersection\" && (S.length === 0 || C.length === 0)) {\n      return true;\n    }\n    if (clip_type === \"union\" && S.length === 0 && C.length === 0) {\n      return true;\n    }\n    if (clip_type === \"difference\" && S.length === 0) {\n      return true;\n    }\n    return false;\n  },\n  _getCoordsArrays: function (path, doClose) {\n    var pathX = [],\n      pathY = [],\n      i,\n      le = path.length;\n    for (i = 0; i < le; i++) {\n      if (path[i].coords) {\n        pathX.push(path[i].coords.usrCoords[1]);\n        pathY.push(path[i].coords.usrCoords[2]);\n      } else {\n        pathX.push(path[i][0]);\n        pathY.push(path[i][1]);\n      }\n    }\n    if (doClose && le > 0) {\n      if (path[0].coords) {\n        pathX.push(path[0].coords.usrCoords[1]);\n        pathY.push(path[0].coords.usrCoords[2]);\n      } else {\n        pathX.push(path[0][0]);\n        pathY.push(path[0][1]);\n      }\n    }\n    return [pathX, pathY];\n  },\n  /**\n   * Handle cases when there are no intersection points of the two paths. This is the case if the\n   * paths are disjoint or one is contained in the other.\n   * @private\n   * @param  {Array} S        First path, array of JXG.Coords\n   * @param  {Array} C        Second path, array of JXG.Coords\n   * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   */\n  handleEmptyIntersection: function (S, C, clip_type) {\n    var P,\n      Q,\n      doClose = false,\n      path = [];\n\n    // Handle trivial cases\n    if (S.length === 0) {\n      if (clip_type === \"union\") {\n        // S cup C = C\n        path = C;\n      } else {\n        // S cap C = S \\ C = {}\n        path = [];\n      }\n      return this._getCoordsArrays(path, true);\n    }\n    if (C.length === 0) {\n      if (clip_type === \"intersection\") {\n        // S cap C = {}\n        path = [];\n      } else {\n        // S cup C = S \\ C = S\n        path = S;\n      }\n      return this._getCoordsArrays(path, true);\n    }\n\n    // From now on, both paths have non-zero length.\n    // The two paths have no crossing intersections,\n    // but there might be bouncing intersections.\n\n    // First, we find -- if possible -- on each path a point which is not an intersection point.\n    if (S.length > 0) {\n      P = S[0];\n      while (P.intersection) {\n        P = P._next;\n        if (P._end) {\n          break;\n        }\n      }\n    }\n    if (C.length > 0) {\n      Q = C[0];\n      while (Q.intersection) {\n        Q = Q._next;\n        if (Q._end) {\n          break;\n        }\n      }\n    }\n\n    // Test if one curve is contained by the other\n    if (Geometry.windingNumber(P.coords.usrCoords, C) === 0) {\n      // P is outside of C:\n      // Either S is disjoint from C or C is inside of S\n      if (Geometry.windingNumber(Q.coords.usrCoords, S) !== 0) {\n        // C is inside of S, i.e. C subset of S\n\n        if (clip_type === \"union\") {\n          path = path.concat(S);\n          path.push(S[0]);\n        } else if (clip_type === \"difference\") {\n          path = path.concat(S);\n          path.push(S[0]);\n          if (Geometry.signedPolygon(S) * Geometry.signedPolygon(C) > 0) {\n            // Pathes have same orientation, we have to revert one.\n            path.reverse();\n          }\n          path.push([NaN, NaN]);\n        }\n        if (clip_type === \"difference\" || clip_type === \"intersection\") {\n          path = path.concat(C);\n          path.push(C[0]);\n          doClose = false;\n        }\n      } else {\n        // The curves are disjoint\n        if (clip_type === \"difference\") {\n          path = path.concat(S);\n          doClose = true;\n        } else if (clip_type === \"union\") {\n          path = path.concat(S);\n          path.push(S[0]);\n          path.push([NaN, NaN]);\n          path = path.concat(C);\n          path.push(C[0]);\n        }\n      }\n    } else {\n      // S inside of C, i.e. S subset of C\n      if (clip_type === \"intersection\") {\n        path = path.concat(S);\n        doClose = true;\n      } else if (clip_type === \"union\") {\n        path = path.concat(C);\n        path.push(C[0]);\n      }\n\n      // 'difference': path is empty\n    }\n    return this._getCoordsArrays(path, doClose);\n  },\n  /**\n   * Count intersection points of type 'X'.\n   * @param {JXG.Mat.Clip.Vertex} intersections\n   * @returns Number\n   * @private\n   */\n  _countCrossingIntersections: function (intersections) {\n    var i,\n      le = intersections.length,\n      sum = 0;\n    for (i = 0; i < le; i++) {\n      if (intersections[i].data.type === \"X\") {\n        sum++;\n      }\n    }\n    return sum;\n  },\n  /**\n   * Create path from all sorts of input elements and convert it\n   * to a suitable input path for greinerHormann().\n   *\n   * @private\n   * @param {Object} obj Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n   * array of coordinate pairs.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @returns {Array} Array of JXG.Coords elements containing a path.\n   * @see JXG.Math.Clip#greinerHormann\n   */\n  _getPath: function (obj, board) {\n    var i,\n      len,\n      r,\n      rad,\n      angle,\n      alpha,\n      steps,\n      S = [];\n\n    // Collect all points into path array S\n    if (obj.elementClass === Const.OBJECT_CLASS_CURVE && (obj.type === Const.OBJECT_TYPE_ARC || obj.type === Const.OBJECT_TYPE_SECTOR)) {\n      angle = Geometry.rad(obj.radiuspoint, obj.center, obj.anglepoint);\n      steps = Math.floor(angle * 180 / Math.PI);\n      r = obj.Radius();\n      rad = angle / steps;\n      alpha = Math.atan2(obj.radiuspoint.coords.usrCoords[2] - obj.center.coords.usrCoords[2], obj.radiuspoint.coords.usrCoords[1] - obj.center.coords.usrCoords[1]);\n      if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n        this._addToList(S, obj.center.coords, 0);\n      }\n      for (i = 0; i <= steps; i++) {\n        this._addToList(S, new Coords(Const.COORDS_BY_USER, [obj.center.coords.usrCoords[0], obj.center.coords.usrCoords[1] + Math.cos(i * rad + alpha) * r, obj.center.coords.usrCoords[2] + Math.sin(i * rad + alpha) * r], board), i + 1);\n      }\n      if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n        this._addToList(S, obj.center.coords, steps + 2);\n      }\n    } else if (obj.elementClass === Const.OBJECT_CLASS_CURVE && Type.exists(obj.points)) {\n      len = obj.numberPoints;\n      for (i = 0; i < len; i++) {\n        this._addToList(S, obj.points[i], i);\n      }\n    } else if (obj.type === Const.OBJECT_TYPE_POLYGON) {\n      for (i = 0; i < obj.vertices.length; i++) {\n        this._addToList(S, obj.vertices[i].coords, i);\n      }\n    } else if (obj.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n      steps = 359;\n      r = obj.Radius();\n      rad = 2 * Math.PI / steps;\n      for (i = 0; i <= steps; i++) {\n        this._addToList(S, new Coords(Const.COORDS_BY_USER, [obj.center.coords.usrCoords[0], obj.center.coords.usrCoords[1] + Math.cos(i * rad) * r, obj.center.coords.usrCoords[2] + Math.sin(i * rad) * r], board), i);\n      }\n    } else if (Type.isArray(obj)) {\n      len = obj.length;\n      for (i = 0; i < len; i++) {\n        if (Type.exists(obj[i].coords)) {\n          // Point type\n          this._addToList(S, obj[i].coords, i);\n        } else if (Type.isArray(obj[i])) {\n          // Coordinate pair\n          this._addToList(S, new Coords(Const.COORDS_BY_USER, obj[i], board), i);\n        } else if (Type.exists(obj[i].usrCoords)) {\n          // JXG.Coordinates\n          this._addToList(S, obj[i], i);\n        }\n      }\n    }\n    return S;\n  },\n  /**\n   * Determine the intersection, union or difference of two closed paths.\n   * <p>\n   * This is an implementation of the Greiner-Hormann algorithm, see\n   * Günther Greiner and Kai Hormann (1998).\n   * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71–83.\n   * and\n   * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n   * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n   * <p>\n   * It is assumed that the pathes are closed, whereby it does not matter if the last point indeed\n   * equals the first point. In contrast to the original Greiner-Hormann algorithm,\n   * this algorithm can cope with many degenerate cases. A degenerate case is a vertext of one path\n   * which is contained in the other path.\n   * <p>\n   *\n   * <p>Problematic are:\n   * <ul>\n   *   <li>degenerate cases where one path additionally has self-intersections\n   *   <li>differences with one path having self-intersections.\n   * </ul>\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path, usually called 'subject'.\n   * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n   * array of coordinate pairs.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path, usually called 'clip'.\n   * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n   * array of coordinate pairs.\n   * @param  {String} clip_type Determines the type of boolean operation on the two paths.\n   *  Possible values are 'intersection', 'union', or 'difference'.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#intersection\n   * @see JXG.Math.Clip#union\n   * @see JXG.Math.Clip#difference\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-3, 3, 0, -3],\n   *             [3, 3, 0, 3]\n   *         ],\n   *         {strokeColor: 'black'});\n   *\n   *     var curve2 = board.create('curve', [\n   *             [-4, 4, 0, -4],\n   *             [2, 2, 4, 2]\n   *         ],\n   *         {strokeColor: 'blue'});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n   *\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *\n   *         var curve1 = board.create('curve', [\n   *                 [-3, 3, 0, -3],\n   *                 [3, 3, 0, 3]\n   *             ],\n   *             {strokeColor: 'black'});\n   *\n   *         var curve2 = board.create('curve', [\n   *                 [-4, 4, 0, -4],\n   *                 [2, 2, 4, 2]\n   *             ],\n   *             {strokeColor: 'blue'});\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n   *\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-3, 3, 0, -3],\n   *             [3, 3, 0, 3]\n   *         ],\n   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *             {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG6075c918-4d57-4b72-b600-6597a6a4f44e\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG6075c918-4d57-4b72-b600-6597a6a4f44e',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('curve', [\n   *                 [-3, 3, 0, -3],\n   *                 [3, 3, 0, 3]\n   *             ],\n   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *                 {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-4, 4, 0, -4],\n   *             [4, 4, -2, 4]\n   *         ],\n   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *     var curve2 = board.create('circle', [[0, 0], [0, -2]],\n   *             {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n   *             center: {visible: true, size: 5}, point2: {size: 5}});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n   *\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG46b3316b-5ab9-4928-9473-ccb476ca4185\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG46b3316b-5ab9-4928-9473-ccb476ca4185',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('curve', [\n   *                 [-4, 4, 0, -4],\n   *                 [4, 4, -2, 4]\n   *             ],\n   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *         var curve2 = board.create('circle', [[0, 0], [0, -2]],\n   *                 {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n   *                 center: {visible: true, size: 5}, point2: {size: 5}});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n   *\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   * @example\n   * var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n   * clip_path.updateDataArray = function() {\n   *     var bbox = this.board.getBoundingBox(),\n   *         canvas, triangle;\n   *\n   *     canvas = [[bbox[0], bbox[1]], // ul\n   *          [bbox[0], bbox[3]], // ll\n   *          [bbox[2], bbox[3]], // lr\n   *          [bbox[2], bbox[1]], // ur\n   *          [bbox[0], bbox[1]]] // ul\n   *     triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n   *\n   *     var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n   *     this.dataX = a[0];\n   *     this.dataY = a[1];\n   * };\n   *\n   * </pre><div id=\"JXGe94da07a-2a01-4498-ad62-f71a327f8e25\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXGe94da07a-2a01-4498-ad62-f71a327f8e25',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var bbox = this.board.getBoundingBox(),\n   *             canvas, triangle;\n   *\n   *         canvas = [[bbox[0], bbox[1]], // ul\n   *              [bbox[0], bbox[3]], // ll\n   *              [bbox[2], bbox[3]], // lr\n   *              [bbox[2], bbox[1]], // ur\n   *              [bbox[0], bbox[1]]] // ul\n   *         triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n   *\n   *         var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   */\n  greinerHormann: function (subject, clip, clip_type, board) {\n    //},\n    // subject_first_point_type, clip_first_point_type) {\n\n    var len,\n      S = [],\n      C = [],\n      S_intersect = [],\n      // C_intersect = [],\n      S_starters,\n      C_starters,\n      res = [],\n      DEBUG = false;\n    if (DEBUG) {\n      console.log(\"\\n------------ GREINER-HORMANN --------------\");\n    }\n    // Collect all subject points into subject array S\n    S = this._getPath(subject, board);\n    len = S.length;\n    if (len > 0 && Geometry.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < Mat.eps) {\n      S.pop();\n    }\n\n    // Collect all points into clip array C\n    C = this._getPath(clip, board);\n    len = C.length;\n    if (len > 0 && Geometry.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) < Mat.eps * Mat.eps) {\n      C.pop();\n    }\n\n    // Handle cases where at least one of the paths is empty\n    if (this.isEmptyCase(S, C, clip_type)) {\n      return [[], []];\n    }\n\n    // Add pointers for doubly linked lists\n    S_starters = this.makeDoublyLinkedList(S);\n    C_starters = this.makeDoublyLinkedList(C);\n    if (DEBUG) {\n      this._print_array(S);\n      console.log(\"Components:\", S_starters);\n      this._print_array(C);\n      console.log(\"Components:\", C_starters);\n    }\n    res = this.findIntersections(S, C, board);\n    S_intersect = res[0];\n    this._handleFullyDegenerateCase(S, C, board);\n\n    // Phase 2: mark intersection points as entry or exit points\n    this.markEntryExit(S, C, S_starters);\n\n    // if (S[0].coords.distance(Const.COORDS_BY_USER, C[0].coords) === 0) {\n    //     // Randomly disturb the first point of the second path\n    //     // if both paths start at the same point.\n    //     C[0].usrCoords[1] *= 1 + Math.random() * 0.0001 - 0.00005;\n    //     C[0].usrCoords[2] *= 1 + Math.random() * 0.0001 - 0.00005;\n    // }\n    this.markEntryExit(C, S, C_starters);\n\n    // Handle cases without intersections\n    if (this._countCrossingIntersections(S_intersect) === 0) {\n      return this.handleEmptyIntersection(S, C, clip_type);\n    }\n\n    // Phase 3: tracing\n    return this.tracing(S, S_intersect, clip_type);\n  },\n  /**\n   * Union of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n   * Computed by the Greiner-Hormann algorithm.\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#greinerHormann\n   * @see JXG.Math.Clip#intersection\n   * @see JXG.Math.Clip#difference\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-3, 3, 0, -3],\n   *             [3, 3, 0, 3]\n   *         ],\n   *         {strokeColor: 'black'});\n   *\n   *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *             {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG7c5204aa-3824-4464-819c-80df7bf1d917\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG7c5204aa-3824-4464-819c-80df7bf1d917',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('curve', [\n   *                 [-3, 3, 0, -3],\n   *                 [3, 3, 0, 3]\n   *             ],\n   *             {strokeColor: 'black'});\n   *\n   *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *                 {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   */\n  union: function (path1, path2, board) {\n    return this.greinerHormann(path1, path2, \"union\", board);\n  },\n  /**\n   * Intersection of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n   * Computed by the Greiner-Hormann algorithm.\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#greinerHormann\n   * @see JXG.Math.Clip#union\n   * @see JXG.Math.Clip#difference\n   *\n   * @example\n   * var p = [];\n   * p.push(board.create('point', [0, -5]));\n   * p.push(board.create('point', [-5, 0]));\n   * p.push(board.create('point', [-3, 3]));\n   *\n   * var curve1 = board.create('ellipse', p,\n   *                 {strokeColor: 'black'});\n   *\n   * var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n   *                                     [0, 0],\n   *                                     0, 2 * Math.PI],\n   *                       {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n   *\n   * var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   * clip_path.updateDataArray = function() {\n   *     var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n   *\n   *     this.dataX = a[0];\n   *     this.dataY = a[1];\n   * };\n   *\n   * board.update();\n   *\n   * </pre><div id=\"JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *     var p = [];\n   *     p.push(board.create('point', [0, -5]));\n   *     p.push(board.create('point', [-5, 0]));\n   *     p.push(board.create('point', [-3, 3]));\n   *\n   *     var curve1 = board.create('ellipse', p,\n   *                     {strokeColor: 'black'});\n   *\n   *     var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n   *                                         [0, 0],\n   *                                         0, 2 * Math.PI],\n   *                           {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n   *\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n   *\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   *\n   */\n  intersection: function (path1, path2, board) {\n    return this.greinerHormann(path1, path2, \"intersection\", board);\n  },\n  /**\n   * Difference of two closed paths, i.e. path1 minus path2.\n   * The paths could be JSXGraph elements circle, curve, or polygon.\n   * Computed by the Greiner-Hormann algorithm.\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#greinerHormann\n   * @see JXG.Math.Clip#intersection\n   * @see JXG.Math.Clip#union\n   *\n   * @example\n   *     var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n   *             {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *     var curve2 = board.create('curve', [\n   *             [-1, 1, 0, -1],\n   *             [1, 1, 3, 1]\n   *         ],\n   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n   *                 {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *         var curve2 = board.create('curve', [\n   *                 [-1, 1, 0, -1],\n   *                 [1, 1, 3, 1]\n   *             ],\n   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * </script><pre>\n   *\n   */\n  difference: function (path1, path2, board) {\n    return this.greinerHormann(path1, path2, \"difference\", board);\n  }\n}; //);\n\nJXG.extend(Mat.Clip, /** @lends JXG.Math.Clip */{});\nexport default Mat.Clip;","map":{"version":3,"names":["JXG","Const","Coords","Mat","Geometry","Type","Clip","_isSeparator","node","isNaN","coords","usrCoords","makeDoublyLinkedList","S","i","first","components","le","length","_next","_prev","push","_end","Vertex","alpha","path","pathname","type","pos","intersection","elementClass","OBJECT_CLASS_POINT","data","done","idx","neighbour","entry_exit","_addToList","list","len","eps","Math","abs","sortIntersections","P_crossings","j","P","Q","last","next_node","P_intersect","P_le","sort","a","b","concat","_inbetween","q","p1","p2","px","py","qx","qy","_print_array","arr","end","console","log","e","_print_list","cnt","_noOverlap","q1","q2","k","sqrt","minp","maxp","minq","maxq","no_overlap","min","max","findIntersections","C","board","res","crds","S_le","C_le","Si","Si1","Cj","Cj1","d1","d2","IS","IC","S_intersect","C_intersect","S_crossings","C_crossings","hasMultCompsS","hasMultCompsC","DEBUG","meetSegmentSegment","distance","Infinity","norm","COORDS_BY_USER","_getPosition","p3","s1","det3p","s2","s3","_classifyDegenerateIntersections","Pp","Pm","Qp","Qm","side","tmp","det","oppositeDir","s4","endless","exists","_tours","random","affineRatio","delayedStatus","toString","_handleIntersectionChains","start_status","P_start","intersection_chain","wait_for_exit","_handleFullyDegenerateCase","l","M","leP","leQ","is_on_Q","is_fully_degenerated","_getStatus","status","windingNumber","markEntryExit","path1","path2","starters","start","chain_start","_starter","_stayOnPath","stay","_addVertex","vertex","tracing","clip_type","current","maxCnt","S_idx","NaN","_getCoordsArrays","isEmptyCase","doClose","pathX","pathY","handleEmptyIntersection","signedPolygon","reverse","_countCrossingIntersections","intersections","sum","_getPath","obj","r","rad","angle","steps","OBJECT_CLASS_CURVE","OBJECT_TYPE_ARC","OBJECT_TYPE_SECTOR","radiuspoint","center","anglepoint","floor","PI","Radius","atan2","cos","sin","points","numberPoints","OBJECT_TYPE_POLYGON","vertices","OBJECT_CLASS_CIRCLE","isArray","greinerHormann","subject","clip","S_starters","C_starters","pop","union","difference","extend"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/math/clip.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\nconsole.log(\"P:\", P.coords.usrCoords, P.data.type)\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains the Math.Clip namespace for clipping and computing boolean operations\n * on polygons and curves\n *\n * // TODO:\n * * Check if input polygons are closed. If not, handle this case.\n */\n\nimport JXG from \"../jxg\";\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Type from \"../utils/type\";\n\n/**\n * Math.Clip namespace definition. This namespace contains algorithms for Boolean operations on paths, i.e.\n * intersection, union and difference of paths. Base is the Greiner-Hormann algorithm.\n * @name JXG.Math.Clip\n * @exports Mat.Clip as JXG.Math.Clip\n * @namespace\n */\n// Mat.Clip = function () {\n// };\n\n// JXG.extend(Mat.Clip.prototype, /** @lends JXG.Curve.prototype */ {\n\nMat.Clip = {\n    _isSeparator: function (node) {\n        return isNaN(node.coords.usrCoords[1]) && isNaN(node.coords.usrCoords[2]);\n    },\n\n    /**\n     * Add pointers to an array S such that it is a circular doubly-linked list.\n     *\n     * @private\n     * @param  {Array} S Array\n     * @return {Array} return containing the starter indices of each component.\n     */\n    makeDoublyLinkedList: function (S) {\n        var i,\n            first = null,\n            components = [],\n            le = S.length;\n\n        if (le > 0) {\n            for (i = 0; i < le; i++) {\n                // S[i]._next = S[(i + 1) % le];\n                // S[i]._prev = S[(le + i - 1) % le];\n\n                // If S[i] is component separator we proceed with the next node.\n                if (this._isSeparator(S[i])) {\n                    S[i]._next = S[(i + 1) % le];\n                    S[i]._prev = S[(le + i - 1) % le];\n                    continue;\n                }\n\n                // Now we know that S[i] is a path component\n                if (first === null) {\n                    // Start the component if it is not yet started.\n                    first = i;\n                    components.push(first);\n                }\n                if (this._isSeparator(S[(i + 1) % le]) || i === le - 1) {\n                    // If the next node is a component separator or if the node is the last node,\n                    // then we close the loop\n\n                    S[i]._next = S[first];\n                    S[first]._prev = S[i];\n                    S[i]._end = true;\n                    first = null;\n                } else {\n                    // Here, we are not at the end of component\n                    S[i]._next = S[(i + 1) % le];\n                    S[first]._prev = S[i];\n                }\n                if (!this._isSeparator(S[(le + i - 1) % le])) {\n                    S[i]._prev = S[(le + i - 1) % le];\n                }\n            }\n        }\n        return components;\n    },\n\n    /**\n     * JavaScript object containing the intersection of two paths. Every intersection point is on one path, but\n     * comes with a neighbour point having the same coordinates and being on the other path.\n     *\n     * The intersection point is inserted into the doubly linked list of the path.\n     *\n     * @private\n     * @param  {JXG.Coords} coords JSXGraph Coords object containing the coordinates of the intersection\n     * @param  {Number} i        Number of the segment of the subject path (first path) containing the intersection.\n     * @param  {Number} alpha    The intersection is a p_1 + alpha*(p_2 - p_1), where p_1 and p_2 are the end points\n     *      of the i-th segment.\n     * @param  {Array} path      Pointer to the path containing the intersection point\n     * @param  {String} pathname Name of the path: 'S' or 'C'.\n     */\n    Vertex: function (coords, i, alpha, path, pathname, type) {\n        this.pos = i;\n        this.intersection = true;\n        this.coords = coords;\n        this.elementClass = Const.OBJECT_CLASS_POINT;\n\n        this.data = {\n            alpha: alpha,\n            path: path,\n            pathname: pathname,\n            done: false,\n            type: type,\n            idx: 0\n        };\n\n        // Set after initialisation\n        this.neighbour = null;\n        this.entry_exit = false;\n    },\n\n    _addToList: function (list, coords, pos) {\n        var len = list.length,\n            eps = Mat.eps * Mat.eps;\n\n        if (\n            len > 0 &&\n            Math.abs(list[len - 1].coords.usrCoords[0] - coords.usrCoords[0]) < eps &&\n            Math.abs(list[len - 1].coords.usrCoords[1] - coords.usrCoords[1]) < eps &&\n            Math.abs(list[len - 1].coords.usrCoords[2] - coords.usrCoords[2]) < eps\n        ) {\n            // Skip point\n            return;\n        }\n        list.push({\n            pos: pos,\n            intersection: false,\n            coords: coords,\n            elementClass: Const.OBJECT_CLASS_POINT\n        });\n    },\n\n    /**\n     * Sort the intersection points into their path.\n     * @private\n     * @param  {Array} P_crossings Array of arrays. Each array contains the intersections of the path\n     *      with one segment of the other path.\n     * @return {Array}  Array of intersection points ordered by first occurrence in the path.\n     */\n    sortIntersections: function (P_crossings) {\n        var i,\n            j,\n            P,\n            Q,\n            last,\n            next_node,\n            P_intersect = [],\n            P_le = P_crossings.length;\n\n        for (i = 0; i < P_le; i++) {\n            P_crossings[i].sort(function (a, b) {\n                return a.data.alpha > b.data.alpha ? 1 : -1;\n            });\n\n            if (P_crossings[i].length > 0) {\n                // console.log(\"Crossings\", P_crossings[i])\n                last = P_crossings[i].length - 1;\n                P = P_crossings[i][0];\n\n                //console.log(\"SORT\", P.coords.usrCoords)\n                Q = P.data.path[P.pos];\n                next_node = Q._next; // Store the next \"normal\" node\n\n                if (i === P_le - 1) {\n                    Q._end = false;\n                }\n\n                if (P.data.alpha === 0.0 && P.data.type === \"T\") {\n                    // console.log(\"SKIP\", P.coords.usrCoords, P.data.type, P.neighbour.data.type);\n                    Q.intersection = true;\n                    Q.data = P.data;\n                    Q.neighbour = P.neighbour;\n                    Q.neighbour.neighbour = Q;\n                    Q.entry_exit = false;\n                    P_crossings[i][0] = Q;\n                } else {\n                    // Insert the first intersection point\n                    P._prev = Q;\n                    P._prev._next = P;\n                }\n\n                // Insert the other intersection points, but the last\n                for (j = 1; j <= last; j++) {\n                    P = P_crossings[i][j];\n                    P._prev = P_crossings[i][j - 1];\n                    P._prev._next = P;\n                }\n\n                // Link last intersection point to the next node\n                P = P_crossings[i][last];\n                P._next = next_node;\n                P._next._prev = P;\n\n                if (i === P_le - 1) {\n                    P._end = true;\n                    //console.log(\"END\", P._end, P.coords.usrCoords, P._prev.coords.usrCoords, P._next.coords.usrCoords);\n                }\n\n                P_intersect = P_intersect.concat(P_crossings[i]);\n            }\n        }\n        return P_intersect;\n    },\n\n    _inbetween: function (q, p1, p2) {\n        var alpha,\n            eps = Mat.eps * Mat.eps,\n            px = p2[1] - p1[1],\n            py = p2[2] - p1[2],\n            qx = q[1] - p1[1],\n            qy = q[2] - p1[2];\n\n        if (px === 0 && py === 0 && qx === 0 && qy === 0) {\n            // All three points are equal\n            return true;\n        }\n        if (Math.abs(qx) < eps && Math.abs(px) < eps) {\n            alpha = qy / py;\n        } else {\n            alpha = qx / px;\n        }\n        if (Math.abs(alpha) < eps) {\n            alpha = 0.0;\n        }\n        return alpha;\n    },\n\n    _print_array: function (arr) {\n        var i, end;\n        for (i = 0; i < arr.length; i++) {\n            //console.log(i, arr[i].coords.usrCoords,  arr[i].data.type);\n            try {\n                end = \"\";\n                if (arr[i]._end) {\n                    end = \" end\";\n                }\n                console.log(\n                    i,\n                    arr[i].coords.usrCoords,\n                    arr[i].data.type,\n                    \"\\t\",\n                    \"prev\",\n                    arr[i]._prev.coords.usrCoords,\n                    \"next\",\n                    arr[i]._next.coords.usrCoords + end\n                );\n            } catch (e) {\n                console.log(i, arr[i].coords.usrCoords);\n            }\n        }\n    },\n\n    _print_list: function (P) {\n        var cnt = 0,\n            alpha;\n        while (cnt < 100) {\n            if (P.data) {\n                alpha = P.data.alpha;\n            } else {\n                alpha = \"-\";\n            }\n            console.log(\n                \"\\t\",\n                P.coords.usrCoords,\n                \"\\n\\t\\tis:\",\n                P.intersection,\n                \"end:\",\n                P._end,\n                alpha,\n                \"\\n\\t\\t-:\",\n                P._prev.coords.usrCoords,\n                \"\\n\\t\\t+:\",\n                P._next.coords.usrCoords,\n                \"\\n\\t\\tn:\",\n                P.intersection ? P.neighbour.coords.usrCoords : \"-\"\n            );\n            if (P._end) {\n                break;\n            }\n            P = P._next;\n            cnt++;\n        }\n    },\n\n    _noOverlap: function (p1, p2, q1, q2) {\n        var k,\n            eps = Math.sqrt(Mat.eps),\n            minp,\n            maxp,\n            minq,\n            maxq,\n            no_overlap = false;\n\n        for (k = 0; k < 3; k++) {\n            minp = Math.min(p1[k], p2[k]);\n            maxp = Math.max(p1[k], p2[k]);\n            minq = Math.min(q1[k], q2[k]);\n            maxq = Math.max(q1[k], q2[k]);\n            if (maxp < minq - eps || minp > maxq + eps) {\n                no_overlap = true;\n                break;\n            }\n        }\n        return no_overlap;\n    },\n\n    /**\n     * Find all intersections between two paths.\n     * @private\n     * @param  {Array} S     Subject path\n     * @param  {Array} C     Clip path\n     * @param  {JXG.Board} board JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}  Array containing two arrays. The first array contains the intersection vertices\n     * of the subject path and the second array contains the intersection vertices of the clip path.\n     * @see JXG.Clip#Vertex\n     */\n    findIntersections: function (S, C, board) {\n        var res = [], eps = Mat.eps * 100,\n            i, j, crds,\n            S_le = S.length,\n            C_le = C.length,\n            Si, Si1, Cj, Cj1, d1, d2,\n            alpha, type, IS, IC,\n            S_intersect = [],\n            C_intersect = [],\n            S_crossings = [],\n            C_crossings = [],\n            hasMultCompsS = false,\n            hasMultCompsC = false,\n            DEBUG = false;\n\n        for (j = 0; j < C_le; j++) {\n            C_crossings.push([]);\n        }\n\n        // Run through the subject path.\n        for (i = 0; i < S_le; i++) {\n            S_crossings.push([]);\n\n            // Test if S[i] or its successor is a path separator.\n            // If yes, we know that the path consists of multiple components.\n            // We immediately jump to the next segment.\n            if (this._isSeparator(S[i]) || this._isSeparator(S[(i + 1) % S_le])) {\n                hasMultCompsS = true;\n                continue;\n            }\n\n            // If the path consists of multiple components then there is\n            // no path-closing segment between the last node and the first\n            // node. In this case we can leave the loop now.\n            if (hasMultCompsS && i === S_le - 1) {\n                break;\n            }\n\n            Si = S[i].coords.usrCoords;\n            Si1 = S[(i + 1) % S_le].coords.usrCoords;\n            // Run through the clip path.\n            for (j = 0; j < C_le; j++) {\n                // Test if C[j] or its successor is a path separator.\n                // If yes, we know that the path consists of multiple components.\n                // We immediately jump to the next segment.\n                if (this._isSeparator(C[j]) || this._isSeparator(C[(j + 1) % C_le])) {\n                    hasMultCompsC = true;\n                    continue;\n                }\n\n                // If the path consists of multiple components then there is\n                // no path-closing segment between the last node and the first\n                // node. In this case we can leave the loop now.\n                if (hasMultCompsC && j === C_le - 1) {\n                    break;\n                }\n\n                // Test if bounding boxes of the two curve segments overlap\n                // If not, the expensive intersection test can be skipped.\n                Cj = C[j].coords.usrCoords;\n                Cj1 = C[(j + 1) % C_le].coords.usrCoords;\n\n                if (this._noOverlap(Si, Si1, Cj, Cj1)) {\n                    continue;\n                }\n\n                // Intersection test\n                res = Geometry.meetSegmentSegment(Si, Si1, Cj, Cj1);\n\n                d1 = Geometry.distance(Si, Si1, 3);\n                d2 = Geometry.distance(Cj, Cj1, 3);\n\n                // Found an intersection point\n                if (\n                    // \"Regular\" intersection\n                    (res[1] * d1 > -eps &&\n                        res[1] < 1 - eps / d1 &&\n                        res[2] * d2 > -eps &&\n                        res[2] < 1 - eps / d2) ||\n                    // Collinear segments\n                    (res[1] === Infinity && res[2] === Infinity && Mat.norm(res[0], 3) < eps)\n                ) {\n                    crds = new Coords(Const.COORDS_BY_USER, res[0], board);\n                    type = \"X\";\n\n                    // Handle degenerated cases\n                    if (Math.abs(res[1]) * d1 < eps || Math.abs(res[2]) * d2 < eps) {\n                        // Crossing / bouncing at vertex or\n                        // end of delayed crossing / bouncing\n                        type = \"T\";\n                        if (Math.abs(res[1]) * d1 < eps) {\n                            res[1] = 0;\n                        }\n                        if (Math.abs(res[2]) * d2 < eps) {\n                            res[2] = 0;\n                        }\n                        if (res[1] === 0) {\n                            crds = new Coords(Const.COORDS_BY_USER, Si, board);\n                        } else {\n                            crds = new Coords(Const.COORDS_BY_USER, Cj, board);\n                        }\n\n                        if (DEBUG) {\n                            console.log(\n                                \"Degenerate case I\",\n                                res[1],\n                                res[2],\n                                crds.usrCoords,\n                                \"type\",\n                                type\n                            );\n                        }\n                    } else if (\n                        res[1] === Infinity &&\n                        res[2] === Infinity &&\n                        Mat.norm(res[0], 3) < eps\n                    ) {\n                        // console.log(C_intersect);\n\n                        // Collinear segments\n                        // Here, there might be two intersection points to be added\n\n                        alpha = this._inbetween(Si, Cj, Cj1);\n                        if (DEBUG) {\n                            // console.log(\"alpha Si\", alpha, Si);\n                            // console.log(j, Cj)\n                            // console.log((j + 1) % C_le, Cj1)\n                        }\n                        if (alpha >= 0 && alpha < 1) {\n                            type = \"T\";\n                            crds = new Coords(Const.COORDS_BY_USER, Si, board);\n                            res[1] = 0;\n                            res[2] = alpha;\n                            IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n                            IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n                            IS.neighbour = IC;\n                            IC.neighbour = IS;\n                            S_crossings[i].push(IS);\n                            C_crossings[j].push(IC);\n                            if (DEBUG) {\n                                console.log(\n                                    \"Degenerate case II\",\n                                    res[1],\n                                    res[2],\n                                    crds.usrCoords,\n                                    \"type T\"\n                                );\n                            }\n                        }\n                        alpha = this._inbetween(Cj, Si, Si1);\n                        if (DEBUG) {\n                            // console.log(\"alpha Cj\", alpha, Si, Geometry.distance(Si, Cj, 3));\n                        }\n                        if (Geometry.distance(Si, Cj, 3) > eps && alpha >= 0 && alpha < 1) {\n                            type = \"T\";\n                            crds = new Coords(Const.COORDS_BY_USER, Cj, board);\n                            res[1] = alpha;\n                            res[2] = 0;\n                            IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n                            IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n                            IS.neighbour = IC;\n                            IC.neighbour = IS;\n                            S_crossings[i].push(IS);\n                            C_crossings[j].push(IC);\n                            if (DEBUG) {\n                                console.log(\n                                    \"Degenerate case III\",\n                                    res[1],\n                                    res[2],\n                                    crds.usrCoords,\n                                    \"type T\"\n                                );\n                            }\n                        }\n                        continue;\n                    }\n                    if (DEBUG) {\n                        console.log(\"IS\", i, j, crds.usrCoords, type);\n                    }\n\n                    IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n                    IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n                    IS.neighbour = IC;\n                    IC.neighbour = IS;\n\n                    S_crossings[i].push(IS);\n                    C_crossings[j].push(IC);\n                }\n            }\n        }\n\n        // For both paths, sort their intersection points\n        S_intersect = this.sortIntersections(S_crossings);\n\n        if (DEBUG) {\n            console.log(\">>>>>> Intersections \");\n            console.log(\"S_intersect\");\n            this._print_array(S_intersect);\n            console.log(\"----------\");\n        }\n        for (i = 0; i < S_intersect.length; i++) {\n            S_intersect[i].data.idx = i;\n            S_intersect[i].neighbour.data.idx = i;\n        }\n        C_intersect = this.sortIntersections(C_crossings);\n\n        if (DEBUG) {\n            console.log(\"C_intersect\");\n            this._print_array(C_intersect);\n            console.log(\"<<<<<< Phase 1 done\");\n        }\n        return [S_intersect, C_intersect];\n    },\n\n    /**\n     * It is testedd if the point q lies to the left or right\n     * of the poylgonal chain [p1, p2, p3].\n     * @param {Array} q User coords array\n     * @param {Array} p1 User coords array\n     * @param {Array} p2 User coords array\n     * @param {Array} p3 User coords array\n     * @returns string 'left' or 'right'\n     * @private\n     */\n    _getPosition: function (q, p1, p2, p3) {\n        var s1 = Geometry.det3p(q, p1, p2),\n            s2 = Geometry.det3p(q, p2, p3),\n            s3 = Geometry.det3p(p1, p2, p3);\n\n        // Left turn\n        if (s3 >= 0) {\n            if (s1 >= 0 && s2 >= 0) {\n                return \"left\";\n            }\n            return \"right\";\n        }\n        // Right turn\n        if (s1 >= 0 || s2 >= 0) {\n            return \"left\";\n        }\n        return \"right\";\n    },\n\n    /**\n     * Determine the delayed status of degenerated intersection points.\n     * It is of the form\n     *   ['on|left|right', 'on|left|right']\n     * <p>\n     * If all four determinants are zero, we add random noise to the point.\n     *\n     * @param {JXG.Math.Clip.Vertex} P Start of path\n     * @private\n     * @see JXG.Math.Clip#markEntryExit\n     * @see JXG.Math.Clip#_handleIntersectionChains\n     */\n    _classifyDegenerateIntersections: function (P) {\n        var Pp, Pm, Qp, Qm,  Q,\n            side, cnt, tmp, det,\n            oppositeDir,\n            s1, s2, s3, s4,\n            endless = true,\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\n                \"\\n-------------- _classifyDegenerateIntersections()\",\n                Type.exists(P.data) ? P.data.pathname : \" \"\n            );\n        }\n        det = Geometry.det3p;\n        cnt = 0;\n        P._tours = 0;\n        while (endless) {\n            if (DEBUG) {\n                console.log(\"Inspect P:\", P.coords.usrCoords, P.data ? P.data.type : \" \");\n            }\n            if (P.intersection && P.data.type === \"T\") {\n                // Handle the degenerate cases\n                // Decide if they are (delayed) bouncing or crossing intersections\n                Pp = P._next.coords.usrCoords; // P+\n                Pm = P._prev.coords.usrCoords; // P-\n\n                // If the intersection point is degenerated and\n                // equal to the start and end of one component,\n                // then there will be two adjacent points with\n                // the same coordinate.\n                // In that case, we proceed to the next node.\n                if (Geometry.distance(P.coords.usrCoords, Pp, 3) < Mat.eps) {\n                    Pp = P._next._next.coords.usrCoords;\n                }\n                if (Geometry.distance(P.coords.usrCoords, Pm, 3) < Mat.eps) {\n                    Pm = P._prev._prev.coords.usrCoords;\n                }\n\n                Q = P.neighbour;\n                Qm = Q._prev.coords.usrCoords; // Q-\n                Qp = Q._next.coords.usrCoords; // Q+\n                if (Geometry.distance(Q.coords.usrCoords, Qp, 3) < Mat.eps) {\n                    Qp = Q._next._next.coords.usrCoords;\n                }\n                if (Geometry.distance(Q.coords.usrCoords, Qm, 3) < Mat.eps) {\n                    Qm = Q._prev._prev.coords.usrCoords;\n                }\n\n                if (DEBUG) {\n                    console.log(\"P chain:\", Pm, P.coords.usrCoords, Pp);\n                    console.log(\"Q chain:\", Qm, P.neighbour.coords.usrCoords, Qp);\n                    console.log(\"Pm\", this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp));\n                    console.log(\"Pp\", this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp));\n                }\n\n                s1 = det(P.coords.usrCoords, Pm, Qm);\n                s2 = det(P.coords.usrCoords, Pp, Qp);\n                s3 = det(P.coords.usrCoords, Pm, Qp);\n                s4 = det(P.coords.usrCoords, Pp, Qm);\n\n                if (s1 === 0 && s2 === 0 && s3 === 0 && s4 === 0) {\n                    P.coords.usrCoords[1] *= 1 + Math.random() * Mat.eps;\n                    P.coords.usrCoords[2] *= 1 + Math.random() * Mat.eps;\n                    Q.coords.usrCoords[1] = P.coords.usrCoords[1];\n                    Q.coords.usrCoords[2] = P.coords.usrCoords[2];\n                    s1 = det(P.coords.usrCoords, Pm, Qm);\n                    s2 = det(P.coords.usrCoords, Pp, Qp);\n                    s3 = det(P.coords.usrCoords, Pm, Qp);\n                    s4 = det(P.coords.usrCoords, Pp, Qm);\n                    if (DEBUG) {\n                        console.log(\"Random shift\", P.coords.usrCoords);\n                        console.log(s1, s2, s3, s4, s2 === 0);\n                        console.log(\n                            this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp),\n                            this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)\n                        );\n                    }\n                }\n                oppositeDir = false;\n                if (s1 === 0) {\n                    // Q-, Q=P, P- on straight line\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pm, Qm) < 0) {\n                        oppositeDir = true;\n                    }\n                } else if (s2 === 0) {\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pp, Qp) < 0) {\n                        oppositeDir = true;\n                    }\n                } else if (s3 === 0) {\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pm, Qp) > 0) {\n                        oppositeDir = true;\n                    }\n                } else if (s4 === 0) {\n                    if (Geometry.affineRatio(P.coords.usrCoords, Pp, Qm) > 0) {\n                        oppositeDir = true;\n                    }\n                }\n                if (oppositeDir) {\n                    // Swap Qm and Qp\n                    // Then Qm Q Qp has the same direction as Pm P Pp\n                    tmp = Qm;\n                    Qm = Qp;\n                    Qp = tmp;\n                    tmp = s1;\n                    s1 = s3;\n                    s3 = tmp;\n                    tmp = s2;\n                    s2 = s4;\n                    s4 = tmp;\n                }\n\n                if (DEBUG) {\n                    console.log(s1, s2, s3, s4, oppositeDir);\n                }\n\n                if (!Type.exists(P.delayedStatus)) {\n                    P.delayedStatus = [];\n                }\n\n                if (s1 === 0 && s2 === 0) {\n                    // Line [P-,P] equals [Q-,Q] and line [P,P+] equals [Q,Q+]\n                    // Interior of delayed crossing / bouncing\n                    P.delayedStatus = [\"on\", \"on\"];\n                } else if (s1 === 0) {\n                    // P- on line [Q-,Q], P+ not on line [Q,Q+]\n                    // Begin / end of delayed crossing / bouncing\n                    side = this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp);\n                    P.delayedStatus = [\"on\", side];\n                } else if (s2 === 0) {\n                    // P+ on line [Q,Q+], P- not on line [Q-,Q]\n                    // Begin / end of delayed crossing / bouncing\n                    side = this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp);\n                    P.delayedStatus = [side, \"on\"];\n                } else {\n                    // Neither P+ on line [Q,Q+], nor P- on line [Q-,Q]\n                    // No delayed crossing / bouncing\n                    if (P.delayedStatus.length === 0) {\n                        if (\n                            this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp) !==\n                            this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)\n                        ) {\n                            P.data.type = \"X\";\n                        } else {\n                            P.data.type = \"B\";\n                        }\n                    }\n                }\n\n                if (DEBUG) {\n                    console.log(\n                        \">>>> P:\",\n                        P.coords.usrCoords,\n                        \"delayedStatus:\",\n                        P.delayedStatus.toString(),\n                        P.data ? P.data.type : \" \",\n                        \"\\n---\"\n                    );\n                }\n            }\n\n            if (Type.exists(P._tours)) {\n                P._tours++;\n            }\n\n            if (P._tours > 3 || P._end || cnt > 1000) {\n                // Jump out if either\n                // - we reached the end\n                // - there are more than 1000 intersection points\n                // - P._tours > 3: We went already 4 times through this path.\n                if (cnt > 1000) {\n                    console.log(\"Clipping: _classifyDegenerateIntersections exit\");\n                }\n                if (Type.exists(P._tours)) {\n                    delete P._tours;\n                }\n                break;\n            }\n            if (P.intersection) {\n                cnt++;\n            }\n            P = P._next;\n        }\n        if (DEBUG) {\n            console.log(\"------------------------\");\n        }\n    },\n\n    /**\n     * At this point the degenerated intersections have been classified.\n     * Now we decide if the intersection chains of the given path\n     * ultimatively cross the other path or bounce.\n     *\n     * @param {JXG.Math.Clip.Vertex} P Start of path\n     *\n     * @see JXG.Math.Clip#markEntryExit\n     * @see JXG.Math.Clip#_classifyDegenerateIntersections\n     * @private\n     */\n    _handleIntersectionChains: function (P) {\n        var cnt = 0,\n            start_status = \"Null\",\n            P_start,\n            endless = true,\n            intersection_chain = false,\n            wait_for_exit = false,\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\n                \"\\n-------------- _handleIntersectionChains()\",\n                Type.exists(P.data) ? P.data.pathname : \" \"\n            );\n        }\n        while (endless) {\n            if (P.intersection === true) {\n                if (DEBUG) {\n                    if (P.data.type === \"T\") {\n                        console.log(\n                            \"Degenerate point\",\n                            P.coords.usrCoords,\n                            P.data.type,\n                            P.data.type === \"T\" ? P.delayedStatus : \" \"\n                        );\n                    } else {\n                        console.log(\"Intersection point\", P.coords.usrCoords, P.data.type);\n                    }\n                }\n                if (P.data.type === \"T\") {\n                    if (P.delayedStatus[0] !== \"on\" && P.delayedStatus[1] === \"on\") {\n                        // First point of intersection chain\n                        intersection_chain = true;\n                        P_start = P;\n                        start_status = P.delayedStatus[0];\n                    } else if (\n                        intersection_chain &&\n                        P.delayedStatus[0] === \"on\" &&\n                        P.delayedStatus[1] === \"on\"\n                    ) {\n                        // Interior of intersection chain\n                        P.data.type = \"B\";\n                        if (DEBUG) {\n                            console.log(\"Interior\", P.coords.usrCoords);\n                        }\n                    } else if (\n                        intersection_chain &&\n                        P.delayedStatus[0] === \"on\" &&\n                        P.delayedStatus[1] !== \"on\"\n                    ) {\n                        // Last point of intersection chain\n                        intersection_chain = false;\n                        if (start_status === P.delayedStatus[1]) {\n                            // Intersection chain is delayed bouncing\n                            P_start.data.type = \"DB\";\n                            P.data.type = \"DB\";\n                            if (DEBUG) {\n                                console.log(\n                                    \"Chain: delayed bouncing\",\n                                    P_start.coords.usrCoords,\n                                    \"...\",\n                                    P.coords.usrCoords\n                                );\n                            }\n                        } else {\n                            // Intersection chain is delayed crossing\n                            P_start.data.type = \"DX\";\n                            P.data.type = \"DX\";\n                            if (DEBUG) {\n                                console.log(\n                                    \"Chain: delayed crossing\",\n                                    P_start.coords.usrCoords,\n                                    \"...\",\n                                    P.coords.usrCoords\n                                );\n                            }\n                        }\n                    }\n                }\n                cnt++;\n            }\n            if (P._end) {\n                wait_for_exit = true;\n            }\n            if (wait_for_exit && !intersection_chain) {\n                break;\n            }\n            if (cnt > 1000) {\n                console.log(\n                    \"Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations\"\n                );\n                break;\n            }\n            P = P._next;\n        }\n    },\n\n    /**\n     * Handle the case that all vertices of one path are contained\n     * in the other path. In this case we search for a midpoint of an edge\n     * which is not contained in the other path and add it to the path.\n     * It will be used as starting point for the entry/exit algorithm.\n     *\n     * @private\n     * @param {Array} S Subject path\n     * @param {Array} C Clip path\n     * @param {JXG.board} board JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     */\n    _handleFullyDegenerateCase: function (S, C, board) {\n        var P, Q, l, M, crds,\n            q1, q2, node, i, j,\n            leP, leQ, is_on_Q,\n            tmp, is_fully_degenerated,\n            arr = [S, C];\n\n        for (l = 0; l < 2; l++) {\n            P = arr[l];\n            leP = P.length;\n            for (i = 0, is_fully_degenerated = true; i < leP; i++) {\n                if (!P[i].intersection) {\n                    is_fully_degenerated = false;\n                    break;\n                }\n            }\n\n            if (is_fully_degenerated) {\n                // All nodes of P are also on the other path.\n                Q = arr[(l + 1) % 2];\n                leQ = Q.length;\n\n                // We search for a midpoint of one edge of P which is not the other path and\n                // we add that midpoint to P.\n                for (i = 0; i < leP; i++) {\n                    q1 = P[i].coords.usrCoords;\n                    q2 = P[i]._next.coords.usrCoords;\n\n                    // M is the midpoint\n                    M = [(q1[0] + q2[0]) * 0.5, (q1[1] + q2[1]) * 0.5, (q1[2] + q2[2]) * 0.5];\n\n                    // Test if M is on path Q. If this is not the case,\n                    // we take M as additional point of P.\n                    for (j = 0, is_on_Q = false; j < leQ; j++) {\n                        if (\n                            Math.abs(\n                                Geometry.det3p(\n                                    Q[j].coords.usrCoords,\n                                    Q[(j + 1) % leQ].coords.usrCoords,\n                                    M\n                                )\n                            ) < Mat.eps\n                        ) {\n                            is_on_Q = true;\n                            break;\n                        }\n                    }\n                    if (!is_on_Q) {\n                        // The midpoint is added to the doubly-linked list.\n                        crds = new Coords(Const.COORDS_BY_USER, M, board);\n                        node = {\n                            pos: i,\n                            intersection: false,\n                            coords: crds,\n                            elementClass: Const.OBJECT_CLASS_POINT\n                        };\n\n                        tmp = P[i]._next;\n                        P[i]._next = node;\n                        node._prev = P[i];\n                        node._next = tmp;\n                        tmp._prev = node;\n\n                        if (P[i]._end) {\n                            P[i]._end = false;\n                            node._end = true;\n                        }\n\n                        break;\n                    }\n                }\n            }\n        }\n    },\n\n    _getStatus: function (P, path) {\n        var status;\n        while (P.intersection) {\n            if (P._end) {\n                break;\n            }\n            P = P._next;\n        }\n        if (Geometry.windingNumber(P.coords.usrCoords, path) === 0) {\n            // Outside\n            status = \"entry\";\n            // console.log(P.coords.usrCoords, ' is outside')\n        } else {\n            // Inside\n            status = \"exit\";\n            // console.log(P.coords.usrCoords, ' is inside')\n        }\n\n        return [P, status];\n    },\n\n    /**\n     * Mark the intersection vertices of path1 as entry points or as exit points\n     * in respect to path2.\n     * <p>\n     * This is the simple algorithm as in\n     * Greiner, Günther; Kai Hormann (1998). \"Efficient clipping of arbitrary polygons\".\n     * ACM Transactions on Graphics. 17 (2): 71–83\n     * <p>\n     * The algorithm handles also \"delayed crossings\" from\n     * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n     * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n     * and - as an additional improvement -\n     * handles self intersections of delayed crossings (A.W. 2021).\n     *\n     * @private\n     * @param  {Array} path1 First path\n     * @param  {Array} path2 Second path\n     */\n    markEntryExit: function (path1, path2, starters) {\n        var status, P, cnt, res,\n            i, len, start,\n            endless = true,\n            chain_start = null,\n            intersection_chain = 0,\n            DEBUG = false;\n\n        len = starters.length;\n        for (i = 0; i < len; i++) {\n            start = starters[i];\n            if (DEBUG) {\n                console.log(\n                    \"\\n;;;;;;;;;; Labelling phase\",\n                    Type.exists(path1[start].data) ? path1[start].data.pathname : \" \",\n                    path1[start].coords.usrCoords\n                );\n            }\n            this._classifyDegenerateIntersections(path1[start]);\n            this._handleIntersectionChains(path1[start]);\n            if (DEBUG) {\n                console.log(\"\\n---- back to markEntryExit\");\n            }\n\n            // Decide if the first point of the component is inside or outside\n            // of the other path.\n            res = this._getStatus(path1[start], path2);\n            P = res[0];\n            status = res[1];\n            if (DEBUG) {\n                console.log(\"Start node:\", P.coords.usrCoords, status);\n            }\n\n            P._starter = true;\n\n            // Greiner-Hormann entry/exit algorithm\n            // with additional handling of delayed crossing / bouncing\n            cnt = 0;\n            chain_start = null;\n            intersection_chain = 0;\n\n            while (endless) {\n                if (P.intersection === true) {\n                    if (P.data.type === \"X\" && intersection_chain === 1) {\n                        // While we are in an intersection chain, i.e. a delayed crossing,\n                        // we stumble on a crossing intersection.\n                        // Probably, the other path is self intersecting.\n                        // We end the intersection chain here and\n                        // mark this event by setting intersection_chain = 2.\n                        chain_start.entry_exit = status;\n                        if (status === \"exit\") {\n                            chain_start.data.type = \"X\";\n                        }\n                        intersection_chain = 2;\n                    }\n\n                    if (P.data.type === \"X\" || P.data.type === \"DB\") {\n                        P.entry_exit = status;\n                        status = status === \"entry\" ? \"exit\" : \"entry\";\n                        if (DEBUG) {\n                            console.log(\"mark:\", P.coords.usrCoords, P.data.type, P.entry_exit);\n                        }\n                    }\n\n                    if (P.data.type === \"DX\") {\n                        if (intersection_chain === 0) {\n                            // Start of intersection chain.\n                            // No active intersection chain yet,\n                            // i.e. we did not pass a the first node of a delayed crossing.\n                            chain_start = P;\n                            intersection_chain = 1;\n                            if (DEBUG) {\n                                console.log(\n                                    \"Start intersection chain:\",\n                                    P.coords.usrCoords,\n                                    P.data.type,\n                                    status\n                                );\n                            }\n                        } else if (intersection_chain === 1) {\n                            // Active intersection chain (intersection_chain===1)!\n                            // End of delayed crossing chain reached\n                            P.entry_exit = status;\n                            chain_start.entry_exit = status;\n                            if (status === \"exit\") {\n                                chain_start.data.type = \"X\";\n                            } else {\n                                P.data.type = \"X\";\n                            }\n                            status = status === \"entry\" ? \"exit\" : \"entry\";\n\n                            if (DEBUG) {\n                                console.log(\n                                    \"mark':\",\n                                    chain_start.coords.usrCoords,\n                                    chain_start.data.type,\n                                    chain_start.entry_exit\n                                );\n                                console.log(\n                                    \"mark:\",\n                                    P.coords.usrCoords,\n                                    P.data.type,\n                                    P.entry_exit\n                                );\n                            }\n                            chain_start = null;\n                            intersection_chain = 0;\n                        } else if (intersection_chain === 2) {\n                            // The delayed crossing had been interrupted by a crossing intersection.\n                            // Now we treat the end of the delayed crossing as regular crossing.\n                            P.entry_exit = status;\n                            P.data.type = \"X\";\n                            status = status === \"entry\" ? \"exit\" : \"entry\";\n                            chain_start = null;\n                            intersection_chain = 0;\n                        }\n                    }\n                }\n\n                P = P._next;\n                if (Type.exists(P._starter) || cnt > 10000) {\n                    break;\n                }\n\n                cnt++;\n            }\n        }\n    },\n\n    /**\n     *\n     * @private\n     * @param {Array} P\n     * @param {Boolean} isBackward\n     * @returns {Boolean} True, if the node is an intersection and is of type 'X'\n     */\n    _stayOnPath: function (P, status) {\n        var stay = true;\n\n        if (P.intersection && P.data.type !== \"B\") {\n            stay = status === P.entry_exit;\n        }\n        return stay;\n    },\n\n    /**\n     * Add a point to the clipping path and returns if the algorithms\n     * arrived at an intersection point which has already been visited.\n     * In this case, true is returned.\n     *\n     * @param {Array} path Resulting path\n     * @param {JXG.Math.Clip.Vertex} vertex Point to be added\n     * @param {Boolean} DEBUG debug output to console.log\n     * @returns {Boolean} true: point has been visited before, false otherwise\n     * @private\n     */\n    _addVertex: function (path, vertex, DEBUG) {\n        if (!isNaN(vertex.coords.usrCoords[1]) && !isNaN(vertex.coords.usrCoords[2])) {\n            path.push(vertex);\n        }\n        if (vertex.intersection && vertex.data.done) {\n            if (DEBUG) {\n                console.log(\n                    \"Add last intersection point\",\n                    vertex.coords.usrCoords,\n                    \"on\",\n                    vertex.data.pathname,\n                    vertex.entry_exit,\n                    vertex.data.type\n                );\n            }\n            return true;\n        }\n        if (vertex.intersection) {\n            vertex.data.done = true;\n\n            if (DEBUG) {\n                console.log(\n                    \"Add intersection point\",\n                    vertex.coords.usrCoords,\n                    \"on\",\n                    vertex.data.pathname,\n                    vertex.entry_exit,\n                    vertex.data.type\n                );\n            }\n        }\n        return false;\n    },\n\n    /**\n     * Tracing phase of the Greiner-Hormann algorithm, see\n     * Greiner, Günther; Kai Hormann (1998).\n     * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71–83\n     *\n     * Boolean operations on polygons are distinguished: 'intersection', 'union', 'difference'.\n     *\n     * @private\n     * @param  {Array} S           Subject path\n     * @param  {Array} S_intersect Array containing the intersection vertices of the subject path\n     * @param  {String} clip_type  contains the Boolean operation: 'intersection', 'union', or 'difference'\n     * @return {Array}             Array consisting of two arrays containing the x-coordinates and the y-coordintaes of\n     *      the resulting path.\n     */\n    tracing: function (S, S_intersect, clip_type) {\n        var P, status, current, start,\n            cnt = 0,\n            maxCnt = 10000,\n            S_idx = 0,\n            path = [],\n            done = false,\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\"\\n------ Start Phase 3\");\n        }\n\n        // reverse = (clip_type === 'difference' || clip_type === 'union') ? true : false;\n        while (S_idx < S_intersect.length && cnt < maxCnt) {\n            // Take the first intersection node of the subject path\n            // which is not yet included as start point.\n            current = S_intersect[S_idx];\n            if (\n                current.data.done ||\n                current.data.type !== \"X\" /*|| !this._isCrossing(current, reverse)*/\n            ) {\n                S_idx++;\n                continue;\n            }\n\n            if (DEBUG) {\n                console.log(\n                    \"\\nStart\",\n                    current.data.pathname,\n                    current.coords.usrCoords,\n                    current.data.type,\n                    current.entry_exit,\n                    S_idx\n                );\n            }\n            if (path.length > 0) {\n                // Add a new path\n                path.push([NaN, NaN]);\n            }\n\n            // Start now the tracing with that node of the subject path\n            start = current.data.idx;\n            P = S;\n\n            done = this._addVertex(path, current, DEBUG);\n            status = current.entry_exit;\n            do {\n                if (done) {\n                    break;\n                }\n                //\n                // Decide if we follow the current path forward or backward.\n                // for example, in case the clipping is of type \"intersection\"\n                // and the current intersection node is of type entry, we go forward.\n                //\n                if (\n                    (clip_type === \"intersection\" && current.entry_exit === \"entry\") ||\n                    (clip_type === \"union\" && current.entry_exit === \"exit\") ||\n                    (clip_type === \"difference\" &&\n                        (P === S) === (current.entry_exit === \"exit\"))\n                ) {\n                    if (DEBUG) {\n                        console.log(\"Go forward on\", current.data.pathname, current.entry_exit);\n                    }\n\n                    //\n                    // Take the next nodes and add them to the path\n                    // as long as they are not intersection nodes of type 'X'.\n                    //\n                    do {\n                        current = current._next;\n                        done = this._addVertex(path, current, DEBUG);\n                        if (done) {\n                            break;\n                        }\n                    } while (this._stayOnPath(current, status));\n                    cnt++;\n                } else {\n                    if (DEBUG) {\n                        console.log(\"Go backward on\", current.data.pathname);\n                    }\n                    //\n                    // Here, we go backward:\n                    // Take the previous nodes and add them to the path\n                    // as long as they are not intersection nodes of type 'X'.\n                    //\n                    do {\n                        current = current._prev;\n                        done = this._addVertex(path, current, DEBUG);\n                        if (done) {\n                            break;\n                        }\n                    } while (this._stayOnPath(current, status));\n                    cnt++;\n                }\n\n                if (done) {\n                    break;\n                }\n\n                if (!current.neighbour) {\n                    console.log(\n                        \"Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!\",\n                        cnt\n                    );\n                    return [[0], [0]];\n                }\n                //\n                // We stopped the forward or backward loop, because we've\n                // arrived at a crossing intersection node, i.e. we have to\n                // switch to the other path now.\n                if (DEBUG) {\n                    console.log(\n                        \"Switch from\",\n                        current.coords.usrCoords,\n                        current.data.pathname,\n                        \"to\",\n                        current.neighbour.coords.usrCoords,\n                        \"on\",\n                        current.neighbour.data.pathname\n                    );\n                }\n                current = current.neighbour;\n                if (current.data.done) {\n                    break;\n                }\n                current.data.done = true;\n                status = current.entry_exit;\n\n                // if (current.data.done) {\n                //     // We arrived at an intersection node which is already\n                //     // added to the clipping path.\n                //     // We add it again to close the clipping path and jump out of the\n                //     // loop.\n                //     path.push(current);\n                //     if (DEBUG) {\n                //         console.log(\"Push last\", current.coords.usrCoords);\n                //     }\n                //     break;\n                // }\n                P = current.data.path;\n\n                // Polygon closed:\n                // if (DEBUG) {\n                //     console.log(\"End of loop:\", \"start=\", start, \"idx=\", current.data.idx);\n                // }\n                // } while (!(current.data.pathname === 'S' && current.data.idx === start) && cnt < maxCnt);\n            } while (current.data.idx !== start && cnt < maxCnt);\n\n            if (cnt >= maxCnt) {\n                console.log(\"Tracing: stopping an infinite loop!\", cnt);\n            }\n\n            S_idx++;\n        }\n        return this._getCoordsArrays(path, false);\n    },\n\n    /**\n     * Handle path clipping if one of the two paths is empty.\n     * @private\n     * @param  {Array} S        First path, array of JXG.Coords\n     * @param  {Array} C        Second path, array of JXG.Coords\n     * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n     * @return {Boolean}        true, if one of the input paths is empty, false otherwise.\n     */\n    isEmptyCase: function (S, C, clip_type) {\n        if (clip_type === \"intersection\" && (S.length === 0 || C.length === 0)) {\n            return true;\n        }\n        if (clip_type === \"union\" && S.length === 0 && C.length === 0) {\n            return true;\n        }\n        if (clip_type === \"difference\" && S.length === 0) {\n            return true;\n        }\n\n        return false;\n    },\n\n    _getCoordsArrays: function (path, doClose) {\n        var pathX = [],\n            pathY = [],\n            i,\n            le = path.length;\n\n        for (i = 0; i < le; i++) {\n            if (path[i].coords) {\n                pathX.push(path[i].coords.usrCoords[1]);\n                pathY.push(path[i].coords.usrCoords[2]);\n            } else {\n                pathX.push(path[i][0]);\n                pathY.push(path[i][1]);\n            }\n        }\n        if (doClose && le > 0) {\n            if (path[0].coords) {\n                pathX.push(path[0].coords.usrCoords[1]);\n                pathY.push(path[0].coords.usrCoords[2]);\n            } else {\n                pathX.push(path[0][0]);\n                pathY.push(path[0][1]);\n            }\n        }\n\n        return [pathX, pathY];\n    },\n\n    /**\n     * Handle cases when there are no intersection points of the two paths. This is the case if the\n     * paths are disjoint or one is contained in the other.\n     * @private\n     * @param  {Array} S        First path, array of JXG.Coords\n     * @param  {Array} C        Second path, array of JXG.Coords\n     * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     */\n    handleEmptyIntersection: function (S, C, clip_type) {\n        var P,\n            Q,\n            doClose = false,\n            path = [];\n\n        // Handle trivial cases\n        if (S.length === 0) {\n            if (clip_type === \"union\") {\n                // S cup C = C\n                path = C;\n            } else {\n                // S cap C = S \\ C = {}\n                path = [];\n            }\n            return this._getCoordsArrays(path, true);\n        }\n        if (C.length === 0) {\n            if (clip_type === \"intersection\") {\n                // S cap C = {}\n                path = [];\n            } else {\n                // S cup C = S \\ C = S\n                path = S;\n            }\n            return this._getCoordsArrays(path, true);\n        }\n\n        // From now on, both paths have non-zero length.\n        // The two paths have no crossing intersections,\n        // but there might be bouncing intersections.\n\n        // First, we find -- if possible -- on each path a point which is not an intersection point.\n        if (S.length > 0) {\n            P = S[0];\n            while (P.intersection) {\n                P = P._next;\n                if (P._end) {\n                    break;\n                }\n            }\n        }\n        if (C.length > 0) {\n            Q = C[0];\n            while (Q.intersection) {\n                Q = Q._next;\n                if (Q._end) {\n                    break;\n                }\n            }\n        }\n\n        // Test if one curve is contained by the other\n        if (Geometry.windingNumber(P.coords.usrCoords, C) === 0) {\n            // P is outside of C:\n            // Either S is disjoint from C or C is inside of S\n            if (Geometry.windingNumber(Q.coords.usrCoords, S) !== 0) {\n                // C is inside of S, i.e. C subset of S\n\n                if (clip_type === \"union\") {\n                    path = path.concat(S);\n                    path.push(S[0]);\n                } else if (clip_type === \"difference\") {\n                    path = path.concat(S);\n                    path.push(S[0]);\n                    if (Geometry.signedPolygon(S) * Geometry.signedPolygon(C) > 0) {\n                        // Pathes have same orientation, we have to revert one.\n                        path.reverse();\n                    }\n                    path.push([NaN, NaN]);\n                }\n                if (clip_type === \"difference\" || clip_type === \"intersection\") {\n                    path = path.concat(C);\n                    path.push(C[0]);\n                    doClose = false;\n                }\n            } else {\n                // The curves are disjoint\n                if (clip_type === \"difference\") {\n                    path = path.concat(S);\n                    doClose = true;\n                } else if (clip_type === \"union\") {\n                    path = path.concat(S);\n                    path.push(S[0]);\n                    path.push([NaN, NaN]);\n                    path = path.concat(C);\n                    path.push(C[0]);\n                }\n            }\n        } else {\n            // S inside of C, i.e. S subset of C\n            if (clip_type === \"intersection\") {\n                path = path.concat(S);\n                doClose = true;\n            } else if (clip_type === \"union\") {\n                path = path.concat(C);\n                path.push(C[0]);\n            }\n\n            // 'difference': path is empty\n        }\n\n        return this._getCoordsArrays(path, doClose);\n    },\n\n    /**\n     * Count intersection points of type 'X'.\n     * @param {JXG.Mat.Clip.Vertex} intersections\n     * @returns Number\n     * @private\n     */\n    _countCrossingIntersections: function (intersections) {\n        var i,\n            le = intersections.length,\n            sum = 0;\n\n        for (i = 0; i < le; i++) {\n            if (intersections[i].data.type === \"X\") {\n                sum++;\n            }\n        }\n        return sum;\n    },\n\n    /**\n     * Create path from all sorts of input elements and convert it\n     * to a suitable input path for greinerHormann().\n     *\n     * @private\n     * @param {Object} obj Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n     * array of coordinate pairs.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @returns {Array} Array of JXG.Coords elements containing a path.\n     * @see JXG.Math.Clip#greinerHormann\n     */\n    _getPath: function (obj, board) {\n        var i, len, r,\n            rad, angle, alpha, steps,\n            S = [];\n\n        // Collect all points into path array S\n        if (\n            obj.elementClass === Const.OBJECT_CLASS_CURVE &&\n            (obj.type === Const.OBJECT_TYPE_ARC || obj.type === Const.OBJECT_TYPE_SECTOR)\n        ) {\n            angle = Geometry.rad(obj.radiuspoint, obj.center, obj.anglepoint);\n            steps = Math.floor((angle * 180) / Math.PI);\n            r = obj.Radius();\n            rad = angle / steps;\n            alpha = Math.atan2(\n                obj.radiuspoint.coords.usrCoords[2] - obj.center.coords.usrCoords[2],\n                obj.radiuspoint.coords.usrCoords[1] - obj.center.coords.usrCoords[1]\n            );\n\n            if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n                this._addToList(S, obj.center.coords, 0);\n            }\n            for (i = 0; i <= steps; i++) {\n                this._addToList(\n                    S,\n                    new Coords(\n                        Const.COORDS_BY_USER,\n                        [\n                            obj.center.coords.usrCoords[0],\n                            obj.center.coords.usrCoords[1] + Math.cos(i * rad + alpha) * r,\n                            obj.center.coords.usrCoords[2] + Math.sin(i * rad + alpha) * r\n                        ],\n                        board\n                    ),\n                    i + 1\n                );\n            }\n            if (obj.type === Const.OBJECT_TYPE_SECTOR) {\n                this._addToList(S, obj.center.coords, steps + 2);\n            }\n        } else if (obj.elementClass === Const.OBJECT_CLASS_CURVE && Type.exists(obj.points)) {\n            len = obj.numberPoints;\n            for (i = 0; i < len; i++) {\n                this._addToList(S, obj.points[i], i);\n            }\n        } else if (obj.type === Const.OBJECT_TYPE_POLYGON) {\n            for (i = 0; i < obj.vertices.length; i++) {\n                this._addToList(S, obj.vertices[i].coords, i);\n            }\n        } else if (obj.elementClass === Const.OBJECT_CLASS_CIRCLE) {\n            steps = 359;\n            r = obj.Radius();\n            rad = (2 * Math.PI) / steps;\n            for (i = 0; i <= steps; i++) {\n                this._addToList(\n                    S,\n                    new Coords(\n                        Const.COORDS_BY_USER,\n                        [\n                            obj.center.coords.usrCoords[0],\n                            obj.center.coords.usrCoords[1] + Math.cos(i * rad) * r,\n                            obj.center.coords.usrCoords[2] + Math.sin(i * rad) * r\n                        ],\n                        board\n                    ),\n                    i\n                );\n            }\n        } else if (Type.isArray(obj)) {\n            len = obj.length;\n            for (i = 0; i < len; i++) {\n                if (Type.exists(obj[i].coords)) {\n                    // Point type\n                    this._addToList(S, obj[i].coords, i);\n                } else if (Type.isArray(obj[i])) {\n                    // Coordinate pair\n                    this._addToList(S, new Coords(Const.COORDS_BY_USER, obj[i], board), i);\n                } else if (Type.exists(obj[i].usrCoords)) {\n                    // JXG.Coordinates\n                    this._addToList(S, obj[i], i);\n                }\n            }\n        }\n\n        return S;\n    },\n\n    /**\n     * Determine the intersection, union or difference of two closed paths.\n     * <p>\n     * This is an implementation of the Greiner-Hormann algorithm, see\n     * Günther Greiner and Kai Hormann (1998).\n     * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71–83.\n     * and\n     * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n     * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n     * <p>\n     * It is assumed that the pathes are closed, whereby it does not matter if the last point indeed\n     * equals the first point. In contrast to the original Greiner-Hormann algorithm,\n     * this algorithm can cope with many degenerate cases. A degenerate case is a vertext of one path\n     * which is contained in the other path.\n     * <p>\n     *\n     * <p>Problematic are:\n     * <ul>\n     *   <li>degenerate cases where one path additionally has self-intersections\n     *   <li>differences with one path having self-intersections.\n     * </ul>\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path, usually called 'subject'.\n     * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n     * array of coordinate pairs.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path, usually called 'clip'.\n     * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n     * array of coordinate pairs.\n     * @param  {String} clip_type Determines the type of boolean operation on the two paths.\n     *  Possible values are 'intersection', 'union', or 'difference'.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#intersection\n     * @see JXG.Math.Clip#union\n     * @see JXG.Math.Clip#difference\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-3, 3, 0, -3],\n     *             [3, 3, 0, 3]\n     *         ],\n     *         {strokeColor: 'black'});\n     *\n     *     var curve2 = board.create('curve', [\n     *             [-4, 4, 0, -4],\n     *             [2, 2, 4, 2]\n     *         ],\n     *         {strokeColor: 'blue'});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n     *\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *\n     *         var curve1 = board.create('curve', [\n     *                 [-3, 3, 0, -3],\n     *                 [3, 3, 0, 3]\n     *             ],\n     *             {strokeColor: 'black'});\n     *\n     *         var curve2 = board.create('curve', [\n     *                 [-4, 4, 0, -4],\n     *                 [2, 2, 4, 2]\n     *             ],\n     *             {strokeColor: 'blue'});\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n     *\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-3, 3, 0, -3],\n     *             [3, 3, 0, 3]\n     *         ],\n     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *             {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG6075c918-4d57-4b72-b600-6597a6a4f44e\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG6075c918-4d57-4b72-b600-6597a6a4f44e',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('curve', [\n     *                 [-3, 3, 0, -3],\n     *                 [3, 3, 0, 3]\n     *             ],\n     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *                 {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-4, 4, 0, -4],\n     *             [4, 4, -2, 4]\n     *         ],\n     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *     var curve2 = board.create('circle', [[0, 0], [0, -2]],\n     *             {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n     *             center: {visible: true, size: 5}, point2: {size: 5}});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n     *\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG46b3316b-5ab9-4928-9473-ccb476ca4185\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG46b3316b-5ab9-4928-9473-ccb476ca4185',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('curve', [\n     *                 [-4, 4, 0, -4],\n     *                 [4, 4, -2, 4]\n     *             ],\n     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *         var curve2 = board.create('circle', [[0, 0], [0, -2]],\n     *                 {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n     *                 center: {visible: true, size: 5}, point2: {size: 5}});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n     *\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     * @example\n     * var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n     * clip_path.updateDataArray = function() {\n     *     var bbox = this.board.getBoundingBox(),\n     *         canvas, triangle;\n     *\n     *     canvas = [[bbox[0], bbox[1]], // ul\n     *          [bbox[0], bbox[3]], // ll\n     *          [bbox[2], bbox[3]], // lr\n     *          [bbox[2], bbox[1]], // ur\n     *          [bbox[0], bbox[1]]] // ul\n     *     triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n     *\n     *     var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n     *     this.dataX = a[0];\n     *     this.dataY = a[1];\n     * };\n     *\n     * </pre><div id=\"JXGe94da07a-2a01-4498-ad62-f71a327f8e25\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXGe94da07a-2a01-4498-ad62-f71a327f8e25',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n     *     clip_path.updateDataArray = function() {\n     *         var bbox = this.board.getBoundingBox(),\n     *             canvas, triangle;\n     *\n     *         canvas = [[bbox[0], bbox[1]], // ul\n     *              [bbox[0], bbox[3]], // ll\n     *              [bbox[2], bbox[3]], // lr\n     *              [bbox[2], bbox[1]], // ur\n     *              [bbox[0], bbox[1]]] // ul\n     *         triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n     *\n     *         var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    greinerHormann: function (subject, clip, clip_type, board) {\n        //},\n        // subject_first_point_type, clip_first_point_type) {\n\n        var len,\n            S = [],\n            C = [],\n            S_intersect = [],\n            // C_intersect = [],\n            S_starters,\n            C_starters,\n            res = [],\n            DEBUG = false;\n\n        if (DEBUG) {\n            console.log(\"\\n------------ GREINER-HORMANN --------------\");\n        }\n        // Collect all subject points into subject array S\n        S = this._getPath(subject, board);\n        len = S.length;\n        if (\n            len > 0 &&\n            Geometry.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < Mat.eps\n        ) {\n            S.pop();\n        }\n\n        // Collect all points into clip array C\n        C = this._getPath(clip, board);\n        len = C.length;\n        if (\n            len > 0 &&\n            Geometry.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) <\n                Mat.eps * Mat.eps\n        ) {\n            C.pop();\n        }\n\n        // Handle cases where at least one of the paths is empty\n        if (this.isEmptyCase(S, C, clip_type)) {\n            return [[], []];\n        }\n\n        // Add pointers for doubly linked lists\n        S_starters = this.makeDoublyLinkedList(S);\n        C_starters = this.makeDoublyLinkedList(C);\n\n        if (DEBUG) {\n            this._print_array(S);\n            console.log(\"Components:\", S_starters);\n            this._print_array(C);\n            console.log(\"Components:\", C_starters);\n        }\n\n        res = this.findIntersections(S, C, board);\n        S_intersect = res[0];\n\n        this._handleFullyDegenerateCase(S, C, board);\n\n        // Phase 2: mark intersection points as entry or exit points\n        this.markEntryExit(S, C, S_starters);\n\n        // if (S[0].coords.distance(Const.COORDS_BY_USER, C[0].coords) === 0) {\n        //     // Randomly disturb the first point of the second path\n        //     // if both paths start at the same point.\n        //     C[0].usrCoords[1] *= 1 + Math.random() * 0.0001 - 0.00005;\n        //     C[0].usrCoords[2] *= 1 + Math.random() * 0.0001 - 0.00005;\n        // }\n        this.markEntryExit(C, S, C_starters);\n\n        // Handle cases without intersections\n        if (this._countCrossingIntersections(S_intersect) === 0) {\n            return this.handleEmptyIntersection(S, C, clip_type);\n        }\n\n        // Phase 3: tracing\n        return this.tracing(S, S_intersect, clip_type);\n    },\n\n    /**\n     * Union of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n     * Computed by the Greiner-Hormann algorithm.\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#greinerHormann\n     * @see JXG.Math.Clip#intersection\n     * @see JXG.Math.Clip#difference\n     *\n     * @example\n     *     var curve1 = board.create('curve', [\n     *             [-3, 3, 0, -3],\n     *             [3, 3, 0, 3]\n     *         ],\n     *         {strokeColor: 'black'});\n     *\n     *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *             {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXG7c5204aa-3824-4464-819c-80df7bf1d917\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG7c5204aa-3824-4464-819c-80df7bf1d917',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('curve', [\n     *                 [-3, 3, 0, -3],\n     *                 [3, 3, 0, 3]\n     *             ],\n     *             {strokeColor: 'black'});\n     *\n     *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n     *                 {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    union: function (path1, path2, board) {\n        return this.greinerHormann(path1, path2, \"union\", board);\n    },\n\n    /**\n     * Intersection of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n     * Computed by the Greiner-Hormann algorithm.\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#greinerHormann\n     * @see JXG.Math.Clip#union\n     * @see JXG.Math.Clip#difference\n     *\n     * @example\n     * var p = [];\n     * p.push(board.create('point', [0, -5]));\n     * p.push(board.create('point', [-5, 0]));\n     * p.push(board.create('point', [-3, 3]));\n     *\n     * var curve1 = board.create('ellipse', p,\n     *                 {strokeColor: 'black'});\n     *\n     * var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n     *                                     [0, 0],\n     *                                     0, 2 * Math.PI],\n     *                       {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n     *\n     * var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     * clip_path.updateDataArray = function() {\n     *     var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n     *\n     *     this.dataX = a[0];\n     *     this.dataY = a[1];\n     * };\n     *\n     * board.update();\n     *\n     * </pre><div id=\"JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *     var p = [];\n     *     p.push(board.create('point', [0, -5]));\n     *     p.push(board.create('point', [-5, 0]));\n     *     p.push(board.create('point', [-3, 3]));\n     *\n     *     var curve1 = board.create('ellipse', p,\n     *                     {strokeColor: 'black'});\n     *\n     *     var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n     *                                         [0, 0],\n     *                                         0, 2 * Math.PI],\n     *                           {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n     *\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n     *\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     *\n     */\n    intersection: function (path1, path2, board) {\n        return this.greinerHormann(path1, path2, \"intersection\", board);\n    },\n\n    /**\n     * Difference of two closed paths, i.e. path1 minus path2.\n     * The paths could be JSXGraph elements circle, curve, or polygon.\n     * Computed by the Greiner-Hormann algorithm.\n     *\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n     * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n     * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n     * user coordinates and screen coordinates.\n     * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n     *      the resulting path.\n     *\n     * @see JXG.Math.Clip#greinerHormann\n     * @see JXG.Math.Clip#intersection\n     * @see JXG.Math.Clip#union\n     *\n     * @example\n     *     var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n     *             {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *     var curve2 = board.create('curve', [\n     *             [-1, 1, 0, -1],\n     *             [1, 1, 3, 1]\n     *         ],\n     *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *     clip_path.updateDataArray = function() {\n     *         var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n     *         this.dataX = a[0];\n     *         this.dataY = a[1];\n     *     };\n     *\n     *     board.update();\n     *\n     * </pre><div id=\"JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n     * <script type=\"text/javascript\">\n     *     (function() {\n     *         var board = JXG.JSXGraph.initBoard('JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3',\n     *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n     *         var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n     *                 {strokeColor: 'blue', fillColor: 'none'});\n     *\n     *         var curve2 = board.create('curve', [\n     *                 [-1, 1, 0, -1],\n     *                 [1, 1, 3, 1]\n     *             ],\n     *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n     *\n     *\n     *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n     *         clip_path.updateDataArray = function() {\n     *             var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n     *             this.dataX = a[0];\n     *             this.dataY = a[1];\n     *         };\n     *\n     *         board.update();\n     *\n     *     })();\n     *\n     * </script><pre>\n     *\n     */\n    difference: function (path1, path2, board) {\n        return this.greinerHormann(path1, path2, \"difference\", board);\n    }\n}; //);\n\nJXG.extend(Mat.Clip, /** @lends JXG.Math.Clip */ {});\n\nexport default Mat.Clip;\n"],"mappings":"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AI,CAAC2H,MAAM,CAACkD,GAAG,CAACpK,CAAC,CAAC,CAACH,SAAS,CAAC,EAAE;UACtC;UACA,IAAI,CAAC0B,UAAU,CAACxB,CAAC,EAAEqK,GAAG,CAACpK,CAAC,CAAC,EAAEA,CAAC,CAAC;QACjC;MACJ;IACJ;IAEA,OAAOD,CAAC;EACZ,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI8C,KAAK,EAAE,SAAAA,CAAUzD,KAAK,EAAEC,KAAK,EAAEjE,KAAK,EAAE;IAClC,OAAO,IAAI,CAACmH,cAAc,CAACnD,KAAK,EAAEC,KAAK,EAAE,OAAO,EAAEjE,KAAK,CAAC;EAC5D,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIzD,YAAY,EAAE,SAAAA,CAAUyH,KAAK,EAAEC,KAAK,EAAEjE,KAAK,EAAE;IACzC,OAAO,IAAI,CAACmH,cAAc,CAACnD,KAAK,EAAEC,KAAK,EAAE,cAAc,EAAEjE,KAAK,CAAC;EACnE,CAAC;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI0H,UAAU,EAAE,SAAAA,CAAU1D,KAAK,EAAEC,KAAK,EAAEjE,KAAK,EAAE;IACvC,OAAO,IAAI,CAACmH,cAAc,CAACnD,KAAK,EAAEC,KAAK,EAAE,YAAY,EAAEjE,KAAK,CAAC;EACjE;AACJ,CAAC,CAAC,CAAC;;AAEHtF,GAAG,CAACiN,MAAM,CAAC9M,GAAG,CAACG,IAAI,EAAE,2BAA4B,CAAC,CAAC,CAAC;AAEpD,eAAeH,GAAG,CAACG,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}