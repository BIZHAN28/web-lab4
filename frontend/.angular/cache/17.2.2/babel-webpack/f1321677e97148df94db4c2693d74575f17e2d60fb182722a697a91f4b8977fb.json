{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the namespace Math.Symbolic is defined, which holds methods\n * and algorithms for symbolic computations.\n * @author graphjs\n */\n\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Server from \"../server/server\";\nimport Type from \"../utils/type\";\nvar undef;\n\n/**\n * The JXG.Math.Symbolic namespace holds algorithms for symbolic computations.\n * @name JXG.Math.Symbolic\n * @exports Mat.Symbolic as JXG.Math.Symbolic\n * @namespace\n */\nMat.Symbolic = {\n  /**\n   * Generates symbolic coordinates for the part of a construction including all the elements from that\n   * a specific element depends of. These coordinates will be stored in GeometryElement.symbolic.\n   * @param {JXG.Board} board The board that's element get some symbolic coordinates.\n   * @param {JXG.GeometryElement} element All ancestor of this element get symbolic coordinates.\n   * @param {String} variable Name for the coordinates, e.g. x or u.\n   * @param {String} append Method for how to append the number of the coordinates. Possible values are\n   *                        'underscore' (e.g. x_2), 'none' (e.g. x2), 'brace' (e.g. x[2]).\n   * @returns {Number} Number of coordinates given.\n   * @memberof JXG.Math.Symbolic\n   */\n  generateSymbolicCoordinatesPartial: function (board, element, variable, append) {\n    var t_num,\n      t,\n      k,\n      list = element.ancestors,\n      count = 0,\n      makeCoords = function (num) {\n        var r;\n        if (append === \"underscore\") {\n          r = variable + \"_{\" + num + \"}\";\n        } else if (append === \"brace\") {\n          r = variable + \"[\" + num + \"]\";\n        } else {\n          r = variable + num;\n        }\n        return r;\n      };\n    board.listOfFreePoints = [];\n    board.listOfDependantPoints = [];\n    for (t in list) {\n      if (list.hasOwnProperty(t)) {\n        t_num = 0;\n        if (Type.isPoint(list[t])) {\n          for (k in list[t].ancestors) {\n            if (list[t].ancestors.hasOwnProperty(k)) {\n              t_num++;\n            }\n          }\n          if (t_num === 0) {\n            list[t].symbolic.x = list[t].coords.usrCoords[1];\n            list[t].symbolic.y = list[t].coords.usrCoords[2];\n            board.listOfFreePoints.push(list[t]);\n          } else {\n            count += 1;\n            list[t].symbolic.x = makeCoords(count);\n            count += 1;\n            list[t].symbolic.y = makeCoords(count);\n            board.listOfDependantPoints.push(list[t]);\n          }\n        }\n      }\n    }\n    if (Type.isPoint(element)) {\n      element.symbolic.x = \"x\";\n      element.symbolic.y = \"y\";\n    }\n    return count;\n  },\n  /**\n   * Clears all .symbolic.x and .symbolic.y members on every point of a given board.\n   * @param {JXG.Board} board The board that's points get cleared their symbolic coordinates.\n   * @memberof JXG.Math.Symbolic\n   */\n  clearSymbolicCoordinates: function (board) {\n    var clear = function (list) {\n      var t,\n        l = list && list.length || 0;\n      for (t = 0; t < l; t++) {\n        if (Type.isPoint(list[t])) {\n          list[t].symbolic.x = \"\";\n          list[t].symbolic.y = \"\";\n        }\n      }\n    };\n    clear(board.listOfFreePoints);\n    clear(board.listOfDependantPoints);\n    delete board.listOfFreePoints;\n    delete board.listOfDependantPoints;\n  },\n  /**\n   * Generates polynomials for a part of the construction including all the points from that\n   * a specific element depends of.\n   * @param {JXG.Board} board The board that's points polynomials will be generated.\n   * @param {JXG.GeometryElement} element All points in the set of ancestors of this element are used to generate the set of polynomials.\n   * @param {Boolean} generateCoords\n   * @returns {Array} An array of polynomials as strings.\n   * @memberof JXG.Math.Symbolic\n   */\n  generatePolynomials: function (board, element, generateCoords) {\n    var t,\n      k,\n      i,\n      list = element.ancestors,\n      number_of_ancestors,\n      pgs = [],\n      result = [];\n    if (generateCoords) {\n      this.generateSymbolicCoordinatesPartial(board, element, \"u\", \"brace\");\n    }\n    list[element.id] = element;\n    for (t in list) {\n      if (list.hasOwnProperty(t)) {\n        number_of_ancestors = 0;\n        pgs = [];\n        if (Type.isPoint(list[t])) {\n          for (k in list[t].ancestors) {\n            if (list[t].ancestors.hasOwnProperty(k)) {\n              number_of_ancestors++;\n            }\n          }\n          if (number_of_ancestors > 0) {\n            pgs = list[t].generatePolynomial();\n            for (i = 0; i < pgs.length; i++) {\n              result.push(pgs[i]);\n            }\n          }\n        }\n      }\n    }\n    if (generateCoords) {\n      this.clearSymbolicCoordinates(board);\n    }\n    return result;\n  },\n  /**\n   * Calculate geometric locus of a point given on a board. Invokes python script on server.\n   * @param {JXG.Board} board The board on which the point lies.\n   * @param {JXG.Point} point The point that will be traced.\n   * @returns {Array} An array of points.\n   * @memberof JXG.Math.Symbolic\n   */\n  geometricLocusByGroebnerBase: function (board, point) {\n    var poly,\n      polyStr,\n      result,\n      P1,\n      P2,\n      i,\n      xs,\n      xe,\n      ys,\n      ye,\n      c,\n      s,\n      tx,\n      bol = board.options.locus,\n      oldRadius = {},\n      numDependent = this.generateSymbolicCoordinatesPartial(board, point, \"u\", \"brace\"),\n      xsye = new Coords(Const.COORDS_BY_USR, [0, 0], board),\n      xeys = new Coords(Const.COORDS_BY_USR, [board.canvasWidth, board.canvasHeight], board),\n      sf = 1,\n      transx = 0,\n      transy = 0,\n      rot = 0;\n    if (Server.modules.geoloci === undef) {\n      Server.loadModule(\"geoloci\");\n    }\n    if (Server.modules.geoloci === undef) {\n      throw new Error(\"JSXGraph: Unable to load JXG.Server module 'geoloci.py'.\");\n    }\n    xs = xsye.usrCoords[1];\n    xe = xeys.usrCoords[1];\n    ys = xeys.usrCoords[2];\n    ye = xsye.usrCoords[2];\n\n    // Optimizations - but only if the user wants to\n    //   Step 1: Translate all related points, such that one point P1 (board.options.locus.toOrigin if set\n    //     or a random point otherwise) is moved to (0, 0)\n    //   Step 2: Rotate the construction around the new P1, such that another point P2 (board.options.locus.to10 if set\n    //     or a random point \\neq P1 otherwise) is moved onto the positive x-axis\n    //  Step 3: Dilate the construction, such that P2 is moved to (1, 0)\n    //  Step 4: Give the scale factor (sf), the rotation (rot) and the translation vector (transx, transy) to\n    //    the server, which retransforms the plot (if any).\n\n    // Step 1\n    if (bol.translateToOrigin && board.listOfFreePoints.length > 0) {\n      if (bol.toOrigin !== undef && bol.toOrigin !== null && Type.isInArray(board.listOfFreePoints, bol.toOrigin.id)) {\n        P1 = bol.toOrigin;\n      } else {\n        P1 = board.listOfFreePoints[0];\n      }\n      transx = P1.symbolic.x;\n      transy = P1.symbolic.y;\n      // translate the whole construction\n      for (i = 0; i < board.listOfFreePoints.length; i++) {\n        board.listOfFreePoints[i].symbolic.x -= transx;\n        board.listOfFreePoints[i].symbolic.y -= transy;\n      }\n      xs -= transx;\n      xe -= transx;\n      ys -= transy;\n      ye -= transy;\n\n      // Step 2\n      if (bol.translateTo10 && board.listOfFreePoints.length > 1) {\n        if (bol.to10 !== undef && bol.to10 !== null && bol.to10.id !== bol.toOrigin.id && Type.isInArray(board.listOfFreePoints, bol.to10.id)) {\n          P2 = bol.to10;\n        } else {\n          if (board.listOfFreePoints[0].id === P1.id) {\n            P2 = board.listOfFreePoints[1];\n          } else {\n            P2 = board.listOfFreePoints[0];\n          }\n        }\n        rot = Geometry.rad([1, 0], [0, 0], [P2.symbolic.x, P2.symbolic.y]);\n        c = Math.cos(-rot);\n        s = Math.sin(-rot);\n        for (i = 0; i < board.listOfFreePoints.length; i++) {\n          tx = board.listOfFreePoints[i].symbolic.x;\n          board.listOfFreePoints[i].symbolic.x = c * board.listOfFreePoints[i].symbolic.x - s * board.listOfFreePoints[i].symbolic.y;\n          board.listOfFreePoints[i].symbolic.y = s * tx + c * board.listOfFreePoints[i].symbolic.y;\n        }\n\n        // thanks to the rotation this is zero\n        P2.symbolic.y = 0;\n        tx = xs;\n        xs = c * xs - s * ys;\n        ys = s * tx + c * ys;\n        tx = xe;\n        xe = c * xe - s * ye;\n        ye = s * tx + c * ye;\n\n        // Step 3\n        if (bol.stretch && Math.abs(P2.symbolic.x) > Mat.eps) {\n          sf = P2.symbolic.x;\n          for (i = 0; i < board.listOfFreePoints.length; i++) {\n            board.listOfFreePoints[i].symbolic.x /= sf;\n            board.listOfFreePoints[i].symbolic.y /= sf;\n          }\n          for (i = 0; i < board.objectsList.length; i++) {\n            if (board.objectsList[i].elementClass === Const.OBJECT_CLASS_CIRCLE && board.objectsList[i].method === \"pointRadius\") {\n              oldRadius[i] = board.objectsList[i].radius;\n              board.objectsList[i].radius /= sf;\n            }\n          }\n          xs /= sf;\n          xe /= sf;\n          ys /= sf;\n          ye /= sf;\n\n          // this is now 1\n          P2.symbolic.x = 1;\n        }\n      }\n\n      // make the coordinates \"as rational as possible\"\n      for (i = 0; i < board.listOfFreePoints.length; i++) {\n        tx = board.listOfFreePoints[i].symbolic.x;\n        if (Math.abs(tx) < Mat.eps) {\n          board.listOfFreePoints[i].symbolic.x = 0;\n        }\n        if (Math.abs(tx - Math.round(tx)) < Mat.eps) {\n          board.listOfFreePoints[i].symbolic.x = Math.round(tx);\n        }\n        tx = board.listOfFreePoints[i].symbolic.y;\n        if (Math.abs(tx) < Mat.eps) {\n          board.listOfFreePoints[i].symbolic.y = 0;\n        }\n        if (Math.abs(tx - Math.round(tx)) < Mat.eps) {\n          board.listOfFreePoints[i].symbolic.y = Math.round(tx);\n        }\n      }\n    }\n\n    // end of optimizations\n\n    poly = this.generatePolynomials(board, point);\n    polyStr = poly.join(\",\");\n    this.cbp = function (data) {\n      result = data;\n    };\n    this.cb = Type.bind(this.cbp, this);\n    Server.modules.geoloci.lociCoCoA(xs, xe, ys, ye, numDependent, polyStr, sf, rot, transx, transy, this.cb, true);\n    this.clearSymbolicCoordinates(board);\n    for (i in oldRadius) {\n      if (oldRadius.hasOwnProperty(i)) {\n        board.objects[i].radius = oldRadius[i];\n      }\n    }\n    return result;\n  }\n};\nexport default Mat.Symbolic;","map":{"version":3,"names":["Const","Coords","Mat","Geometry","Server","Type","undef","Symbolic","generateSymbolicCoordinatesPartial","board","element","variable","append","t_num","t","k","list","ancestors","count","makeCoords","num","r","listOfFreePoints","listOfDependantPoints","hasOwnProperty","isPoint","symbolic","x","coords","usrCoords","y","push","clearSymbolicCoordinates","clear","l","length","generatePolynomials","generateCoords","i","number_of_ancestors","pgs","result","id","generatePolynomial","geometricLocusByGroebnerBase","point","poly","polyStr","P1","P2","xs","xe","ys","ye","c","s","tx","bol","options","locus","oldRadius","numDependent","xsye","COORDS_BY_USR","xeys","canvasWidth","canvasHeight","sf","transx","transy","rot","modules","geoloci","loadModule","Error","translateToOrigin","toOrigin","isInArray","translateTo10","to10","rad","Math","cos","sin","stretch","abs","eps","objectsList","elementClass","OBJECT_CLASS_CIRCLE","method","radius","round","join","cbp","data","cb","bind","lociCoCoA","objects"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/math/symbolic.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview In this file the namespace Math.Symbolic is defined, which holds methods\n * and algorithms for symbolic computations.\n * @author graphjs\n */\n\nimport Const from \"../base/constants\";\nimport Coords from \"../base/coords\";\nimport Mat from \"./math\";\nimport Geometry from \"./geometry\";\nimport Server from \"../server/server\";\nimport Type from \"../utils/type\";\n\nvar undef;\n\n/**\n * The JXG.Math.Symbolic namespace holds algorithms for symbolic computations.\n * @name JXG.Math.Symbolic\n * @exports Mat.Symbolic as JXG.Math.Symbolic\n * @namespace\n */\nMat.Symbolic = {\n    /**\n     * Generates symbolic coordinates for the part of a construction including all the elements from that\n     * a specific element depends of. These coordinates will be stored in GeometryElement.symbolic.\n     * @param {JXG.Board} board The board that's element get some symbolic coordinates.\n     * @param {JXG.GeometryElement} element All ancestor of this element get symbolic coordinates.\n     * @param {String} variable Name for the coordinates, e.g. x or u.\n     * @param {String} append Method for how to append the number of the coordinates. Possible values are\n     *                        'underscore' (e.g. x_2), 'none' (e.g. x2), 'brace' (e.g. x[2]).\n     * @returns {Number} Number of coordinates given.\n     * @memberof JXG.Math.Symbolic\n     */\n    generateSymbolicCoordinatesPartial: function (board, element, variable, append) {\n        var t_num,\n            t,\n            k,\n            list = element.ancestors,\n            count = 0,\n            makeCoords = function (num) {\n                var r;\n\n                if (append === \"underscore\") {\n                    r = variable + \"_{\" + num + \"}\";\n                } else if (append === \"brace\") {\n                    r = variable + \"[\" + num + \"]\";\n                } else {\n                    r = variable + num;\n                }\n\n                return r;\n            };\n\n        board.listOfFreePoints = [];\n        board.listOfDependantPoints = [];\n\n        for (t in list) {\n            if (list.hasOwnProperty(t)) {\n                t_num = 0;\n\n                if (Type.isPoint(list[t])) {\n                    for (k in list[t].ancestors) {\n                        if (list[t].ancestors.hasOwnProperty(k)) {\n                            t_num++;\n                        }\n                    }\n\n                    if (t_num === 0) {\n                        list[t].symbolic.x = list[t].coords.usrCoords[1];\n                        list[t].symbolic.y = list[t].coords.usrCoords[2];\n                        board.listOfFreePoints.push(list[t]);\n                    } else {\n                        count += 1;\n                        list[t].symbolic.x = makeCoords(count);\n                        count += 1;\n                        list[t].symbolic.y = makeCoords(count);\n                        board.listOfDependantPoints.push(list[t]);\n                    }\n                }\n            }\n        }\n\n        if (Type.isPoint(element)) {\n            element.symbolic.x = \"x\";\n            element.symbolic.y = \"y\";\n        }\n\n        return count;\n    },\n\n    /**\n     * Clears all .symbolic.x and .symbolic.y members on every point of a given board.\n     * @param {JXG.Board} board The board that's points get cleared their symbolic coordinates.\n     * @memberof JXG.Math.Symbolic\n     */\n    clearSymbolicCoordinates: function (board) {\n        var clear = function (list) {\n            var t,\n                l = (list && list.length) || 0;\n\n            for (t = 0; t < l; t++) {\n                if (Type.isPoint(list[t])) {\n                    list[t].symbolic.x = \"\";\n                    list[t].symbolic.y = \"\";\n                }\n            }\n        };\n\n        clear(board.listOfFreePoints);\n        clear(board.listOfDependantPoints);\n\n        delete board.listOfFreePoints;\n        delete board.listOfDependantPoints;\n    },\n\n    /**\n     * Generates polynomials for a part of the construction including all the points from that\n     * a specific element depends of.\n     * @param {JXG.Board} board The board that's points polynomials will be generated.\n     * @param {JXG.GeometryElement} element All points in the set of ancestors of this element are used to generate the set of polynomials.\n     * @param {Boolean} generateCoords\n     * @returns {Array} An array of polynomials as strings.\n     * @memberof JXG.Math.Symbolic\n     */\n    generatePolynomials: function (board, element, generateCoords) {\n        var t,\n            k,\n            i,\n            list = element.ancestors,\n            number_of_ancestors,\n            pgs = [],\n            result = [];\n\n        if (generateCoords) {\n            this.generateSymbolicCoordinatesPartial(board, element, \"u\", \"brace\");\n        }\n\n        list[element.id] = element;\n\n        for (t in list) {\n            if (list.hasOwnProperty(t)) {\n                number_of_ancestors = 0;\n                pgs = [];\n\n                if (Type.isPoint(list[t])) {\n                    for (k in list[t].ancestors) {\n                        if (list[t].ancestors.hasOwnProperty(k)) {\n                            number_of_ancestors++;\n                        }\n                    }\n                    if (number_of_ancestors > 0) {\n                        pgs = list[t].generatePolynomial();\n\n                        for (i = 0; i < pgs.length; i++) {\n                            result.push(pgs[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (generateCoords) {\n            this.clearSymbolicCoordinates(board);\n        }\n\n        return result;\n    },\n\n    /**\n     * Calculate geometric locus of a point given on a board. Invokes python script on server.\n     * @param {JXG.Board} board The board on which the point lies.\n     * @param {JXG.Point} point The point that will be traced.\n     * @returns {Array} An array of points.\n     * @memberof JXG.Math.Symbolic\n     */\n    geometricLocusByGroebnerBase: function (board, point) {\n        var poly,\n            polyStr,\n            result,\n            P1,\n            P2,\n            i,\n            xs,\n            xe,\n            ys,\n            ye,\n            c,\n            s,\n            tx,\n            bol = board.options.locus,\n            oldRadius = {},\n            numDependent = this.generateSymbolicCoordinatesPartial(board, point, \"u\", \"brace\"),\n            xsye = new Coords(Const.COORDS_BY_USR, [0, 0], board),\n            xeys = new Coords(\n                Const.COORDS_BY_USR,\n                [board.canvasWidth, board.canvasHeight],\n                board\n            ),\n            sf = 1,\n            transx = 0,\n            transy = 0,\n            rot = 0;\n\n        if (Server.modules.geoloci === undef) {\n            Server.loadModule(\"geoloci\");\n        }\n\n        if (Server.modules.geoloci === undef) {\n            throw new Error(\"JSXGraph: Unable to load JXG.Server module 'geoloci.py'.\");\n        }\n\n        xs = xsye.usrCoords[1];\n        xe = xeys.usrCoords[1];\n        ys = xeys.usrCoords[2];\n        ye = xsye.usrCoords[2];\n\n        // Optimizations - but only if the user wants to\n        //   Step 1: Translate all related points, such that one point P1 (board.options.locus.toOrigin if set\n        //     or a random point otherwise) is moved to (0, 0)\n        //   Step 2: Rotate the construction around the new P1, such that another point P2 (board.options.locus.to10 if set\n        //     or a random point \\neq P1 otherwise) is moved onto the positive x-axis\n        //  Step 3: Dilate the construction, such that P2 is moved to (1, 0)\n        //  Step 4: Give the scale factor (sf), the rotation (rot) and the translation vector (transx, transy) to\n        //    the server, which retransforms the plot (if any).\n\n        // Step 1\n        if (bol.translateToOrigin && board.listOfFreePoints.length > 0) {\n            if (\n                bol.toOrigin !== undef &&\n                bol.toOrigin !== null &&\n                Type.isInArray(board.listOfFreePoints, bol.toOrigin.id)\n            ) {\n                P1 = bol.toOrigin;\n            } else {\n                P1 = board.listOfFreePoints[0];\n            }\n\n            transx = P1.symbolic.x;\n            transy = P1.symbolic.y;\n            // translate the whole construction\n            for (i = 0; i < board.listOfFreePoints.length; i++) {\n                board.listOfFreePoints[i].symbolic.x -= transx;\n                board.listOfFreePoints[i].symbolic.y -= transy;\n            }\n\n            xs -= transx;\n            xe -= transx;\n            ys -= transy;\n            ye -= transy;\n\n            // Step 2\n            if (bol.translateTo10 && board.listOfFreePoints.length > 1) {\n                if (\n                    bol.to10 !== undef &&\n                    bol.to10 !== null &&\n                    bol.to10.id !== bol.toOrigin.id &&\n                    Type.isInArray(board.listOfFreePoints, bol.to10.id)\n                ) {\n                    P2 = bol.to10;\n                } else {\n                    if (board.listOfFreePoints[0].id === P1.id) {\n                        P2 = board.listOfFreePoints[1];\n                    } else {\n                        P2 = board.listOfFreePoints[0];\n                    }\n                }\n\n                rot = Geometry.rad([1, 0], [0, 0], [P2.symbolic.x, P2.symbolic.y]);\n                c = Math.cos(-rot);\n                s = Math.sin(-rot);\n\n                for (i = 0; i < board.listOfFreePoints.length; i++) {\n                    tx = board.listOfFreePoints[i].symbolic.x;\n                    board.listOfFreePoints[i].symbolic.x =\n                        c * board.listOfFreePoints[i].symbolic.x -\n                        s * board.listOfFreePoints[i].symbolic.y;\n                    board.listOfFreePoints[i].symbolic.y =\n                        s * tx + c * board.listOfFreePoints[i].symbolic.y;\n                }\n\n                // thanks to the rotation this is zero\n                P2.symbolic.y = 0;\n\n                tx = xs;\n                xs = c * xs - s * ys;\n                ys = s * tx + c * ys;\n                tx = xe;\n                xe = c * xe - s * ye;\n                ye = s * tx + c * ye;\n\n                // Step 3\n                if (bol.stretch && Math.abs(P2.symbolic.x) > Mat.eps) {\n                    sf = P2.symbolic.x;\n\n                    for (i = 0; i < board.listOfFreePoints.length; i++) {\n                        board.listOfFreePoints[i].symbolic.x /= sf;\n                        board.listOfFreePoints[i].symbolic.y /= sf;\n                    }\n\n                    for (i = 0; i < board.objectsList.length; i++) {\n                        if (\n                            board.objectsList[i].elementClass === Const.OBJECT_CLASS_CIRCLE &&\n                            board.objectsList[i].method === \"pointRadius\"\n                        ) {\n                            oldRadius[i] = board.objectsList[i].radius;\n                            board.objectsList[i].radius /= sf;\n                        }\n                    }\n\n                    xs /= sf;\n                    xe /= sf;\n                    ys /= sf;\n                    ye /= sf;\n\n                    // this is now 1\n                    P2.symbolic.x = 1;\n                }\n            }\n\n            // make the coordinates \"as rational as possible\"\n            for (i = 0; i < board.listOfFreePoints.length; i++) {\n                tx = board.listOfFreePoints[i].symbolic.x;\n\n                if (Math.abs(tx) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.x = 0;\n                }\n\n                if (Math.abs(tx - Math.round(tx)) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.x = Math.round(tx);\n                }\n\n                tx = board.listOfFreePoints[i].symbolic.y;\n\n                if (Math.abs(tx) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.y = 0;\n                }\n\n                if (Math.abs(tx - Math.round(tx)) < Mat.eps) {\n                    board.listOfFreePoints[i].symbolic.y = Math.round(tx);\n                }\n            }\n        }\n\n        // end of optimizations\n\n        poly = this.generatePolynomials(board, point);\n        polyStr = poly.join(\",\");\n\n        this.cbp = function (data) {\n            result = data;\n        };\n\n        this.cb = Type.bind(this.cbp, this);\n\n        Server.modules.geoloci.lociCoCoA(\n            xs,\n            xe,\n            ys,\n            ye,\n            numDependent,\n            polyStr,\n            sf,\n            rot,\n            transx,\n            transy,\n            this.cb,\n            true\n        );\n\n        this.clearSymbolicCoordinates(board);\n\n        for (i in oldRadius) {\n            if (oldRadius.hasOwnProperty(i)) {\n                board.objects[i].radius = oldRadius[i];\n            }\n        }\n\n        return result;\n    }\n};\n\nexport default Mat.Symbolic;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}