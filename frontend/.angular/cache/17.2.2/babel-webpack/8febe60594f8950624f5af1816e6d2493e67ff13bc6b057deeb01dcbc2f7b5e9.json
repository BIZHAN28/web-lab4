{"ast":null,"code":"/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport EventEmitter from \"../utils/event\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\n\n/**\n * @fileoverview In this file the Coords object is defined, a class to manage all\n * properties and methods coordinates usually have.\n */\n\n/**\n * Constructs a new Coordinates object.\n * @class This is the Coordinates class.\n * All members a coordinate has to provide\n * are defined here.\n * @param {Number} method The type of coordinates given by the user. Accepted values are <b>COORDS_BY_SCREEN</b> and <b>COORDS_BY_USER</b>.\n * @param {Array} coordinates An array of affine coordinates.\n * @param {JXG.Board} board A reference to a board.\n * @param {Boolean} [emitter=true]\n * @constructor\n */\nJXG.Coords = function (method, coordinates, board, emitter) {\n  /**\n   * Stores the board the object is used on.\n   * @type JXG.Board\n   */\n  this.board = board;\n\n  /**\n   * Stores coordinates for user view as homogeneous coordinates.\n   * @type Array\n   */\n  this.usrCoords = [];\n  //this.usrCoords = new Float64Array(3);\n\n  /**\n   * Stores coordinates for screen view as homogeneous coordinates.\n   * @type Array\n   */\n  this.scrCoords = [];\n  //this.scrCoords = new Float64Array(3);\n\n  /**\n   * If true, this coordinates object will emit update events every time\n   * the coordinates are set.\n   * @type boolean\n   * @default true\n   */\n  this.emitter = !Type.exists(emitter) || emitter;\n  if (this.emitter) {\n    EventEmitter.eventify(this);\n  }\n  this.setCoordinates(method, coordinates, false, true);\n};\nJXG.extend(JXG.Coords.prototype, /** @lends JXG.Coords.prototype */{\n  /**\n   * Normalize homogeneous coordinates\n   * @private\n   */\n  normalizeUsrCoords: function () {\n    if (Math.abs(this.usrCoords[0]) > Mat.eps) {\n      this.usrCoords[1] /= this.usrCoords[0];\n      this.usrCoords[2] /= this.usrCoords[0];\n      this.usrCoords[0] = 1.0;\n    }\n  },\n  /**\n   * Compute screen coordinates out of given user coordinates.\n   * @private\n   */\n  usr2screen: function (doRound) {\n    var mround = Math.round,\n      // Is faster on IE, maybe slower with JIT compilers\n      b = this.board,\n      uc = this.usrCoords,\n      oc = b.origin.scrCoords;\n    if (doRound === true) {\n      this.scrCoords[0] = mround(uc[0]);\n      this.scrCoords[1] = mround(uc[0] * oc[1] + uc[1] * b.unitX);\n      this.scrCoords[2] = mround(uc[0] * oc[2] - uc[2] * b.unitY);\n    } else {\n      this.scrCoords[0] = uc[0];\n      this.scrCoords[1] = uc[0] * oc[1] + uc[1] * b.unitX;\n      this.scrCoords[2] = uc[0] * oc[2] - uc[2] * b.unitY;\n    }\n  },\n  /**\n   * Compute user coordinates out of given screen coordinates.\n   * @private\n   */\n  screen2usr: function () {\n    var o = this.board.origin.scrCoords,\n      sc = this.scrCoords,\n      b = this.board;\n    this.usrCoords[0] = 1.0;\n    this.usrCoords[1] = (sc[1] - o[1]) / b.unitX;\n    this.usrCoords[2] = (o[2] - sc[2]) / b.unitY;\n  },\n  /**\n   * Calculate distance of one point to another.\n   * @param {Number} coord_type The type of coordinates used here. Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.\n   * @param {JXG.Coords} coordinates The Coords object to which the distance is calculated.\n   * @returns {Number} The distance\n   */\n  distance: function (coord_type, coordinates) {\n    var sum = 0,\n      c,\n      ucr = this.usrCoords,\n      scr = this.scrCoords,\n      f;\n    if (coord_type === Const.COORDS_BY_USER) {\n      c = coordinates.usrCoords;\n      f = ucr[0] - c[0];\n      sum = f * f;\n      if (sum > Mat.eps * Mat.eps) {\n        return Number.POSITIVE_INFINITY;\n      }\n      return Mat.hypot(ucr[1] - c[1], ucr[2] - c[2]);\n    } else {\n      c = coordinates.scrCoords;\n      return Mat.hypot(scr[1] - c[1], scr[2] - c[2]);\n    }\n  },\n  /**\n   * Set coordinates by either user coordinates or screen coordinates and recalculate the other one.\n   * @param {Number} coord_type The type of coordinates used here. Possible values are <b>COORDS_BY_USER</b> and <b>COORDS_BY_SCREEN</b>.\n   * @param {Array} coordinates An array of affine coordinates the Coords object is set to.\n   * @param {Boolean} [doRound=true] flag If true or null round the coordinates in usr2screen. This is used in smooth curve plotting.\n   * The IE needs rounded coordinates. Id doRound==false we have to round in updatePathString.\n   * @param {Boolean} [noevent=false]\n   * @returns {JXG.Coords} Reference to the coords object.\n   */\n  setCoordinates: function (coord_type, coordinates, doRound, noevent) {\n    var uc = this.usrCoords,\n      sc = this.scrCoords,\n      // Original values\n      ou = [uc[0], uc[1], uc[2]],\n      os = [sc[0], sc[1], sc[2]];\n    if (coord_type === Const.COORDS_BY_USER) {\n      if (coordinates.length === 2) {\n        // Euclidean coordinates\n        uc[0] = 1.0;\n        uc[1] = coordinates[0];\n        uc[2] = coordinates[1];\n      } else {\n        // Homogeneous coordinates (normalized)\n        uc[0] = coordinates[0];\n        uc[1] = coordinates[1];\n        uc[2] = coordinates[2];\n        this.normalizeUsrCoords();\n      }\n      this.usr2screen(doRound);\n    } else {\n      if (coordinates.length === 2) {\n        // Euclidean coordinates\n        sc[1] = coordinates[0];\n        sc[2] = coordinates[1];\n      } else {\n        // Homogeneous coordinates (normalized)\n        sc[1] = coordinates[1];\n        sc[2] = coordinates[2];\n      }\n      this.screen2usr();\n    }\n    if (this.emitter && !noevent && (os[1] !== sc[1] || os[2] !== sc[2])) {\n      this.triggerEventHandlers([\"update\"], [ou, os]);\n    }\n    return this;\n  },\n  /**\n   * Copy array, either scrCoords or usrCoords\n   * Uses slice() in case of standard arrays and set() in case of\n   * typed arrays.\n   * @private\n   * @param {String} obj Either 'scrCoords' or 'usrCoords'\n   * @param {Number} offset Offset, defaults to 0 if not given\n   * @returns {Array} Returns copy of the coords array either as standard array or as\n   *   typed array.\n   */\n  copy: function (obj, offset) {\n    if (offset === undefined) {\n      offset = 0;\n    }\n    return this[obj].slice(offset);\n  },\n  /**\n   * Test if one of the usrCoords is NaN or the coordinates are infinite.\n   * @returns {Boolean} true if the coordinates are finite, false otherwise.\n   */\n  isReal: function () {\n    return !isNaN(this.usrCoords[1] + this.usrCoords[2]) && Math.abs(this.usrCoords[0]) > Mat.eps;\n  },\n  /**\n   * Triggered whenever the coordinates change.\n   * @name JXG.Coords#update\n   * @param {Array} ou Old user coordinates\n   * @param {Array} os Old screen coordinates\n   * @event\n   */\n  __evt__update: function (ou, os) {},\n  /**\n   * @ignore\n   */\n  __evt: function () {}\n});\nexport default JXG.Coords;","map":{"version":3,"names":["JXG","Const","EventEmitter","Type","Mat","Coords","method","coordinates","board","emitter","usrCoords","scrCoords","exists","eventify","setCoordinates","extend","prototype","normalizeUsrCoords","Math","abs","eps","usr2screen","doRound","mround","round","b","uc","oc","origin","unitX","unitY","screen2usr","o","sc","distance","coord_type","sum","c","ucr","scr","f","COORDS_BY_USER","Number","POSITIVE_INFINITY","hypot","noevent","ou","os","length","triggerEventHandlers","copy","obj","offset","undefined","slice","isReal","isNaN","__evt__update","__evt"],"sources":["D:/study things/web/weblab4-main/node_modules/jsxgraph/src/base/coords.js"],"sourcesContent":["/*\n    Copyright 2008-2023\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Bianca Valentin,\n        Alfred Wassermann,\n        Peter Wilfahrt\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <https://www.gnu.org/licenses/>\n    and <https://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true, AMprocessNode: true, MathJax: true, document: true */\n/*jslint nomen: true, plusplus: true*/\n\nimport JXG from \"../jxg\";\nimport Const from \"./constants\";\nimport EventEmitter from \"../utils/event\";\nimport Type from \"../utils/type\";\nimport Mat from \"../math/math\";\n\n/**\n * @fileoverview In this file the Coords object is defined, a class to manage all\n * properties and methods coordinates usually have.\n */\n\n/**\n * Constructs a new Coordinates object.\n * @class This is the Coordinates class.\n * All members a coordinate has to provide\n * are defined here.\n * @param {Number} method The type of coordinates given by the user. Accepted values are <b>COORDS_BY_SCREEN</b> and <b>COORDS_BY_USER</b>.\n * @param {Array} coordinates An array of affine coordinates.\n * @param {JXG.Board} board A reference to a board.\n * @param {Boolean} [emitter=true]\n * @constructor\n */\nJXG.Coords = function (method, coordinates, board, emitter) {\n    /**\n     * Stores the board the object is used on.\n     * @type JXG.Board\n     */\n    this.board = board;\n\n    /**\n     * Stores coordinates for user view as homogeneous coordinates.\n     * @type Array\n     */\n    this.usrCoords = [];\n    //this.usrCoords = new Float64Array(3);\n\n    /**\n     * Stores coordinates for screen view as homogeneous coordinates.\n     * @type Array\n     */\n    this.scrCoords = [];\n    //this.scrCoords = new Float64Array(3);\n\n    /**\n     * If true, this coordinates object will emit update events every time\n     * the coordinates are set.\n     * @type boolean\n     * @default true\n     */\n    this.emitter = !Type.exists(emitter) || emitter;\n\n    if (this.emitter) {\n        EventEmitter.eventify(this);\n    }\n    this.setCoordinates(method, coordinates, false, true);\n};\n\nJXG.extend(\n    JXG.Coords.prototype,\n    /** @lends JXG.Coords.prototype */ {\n        /**\n         * Normalize homogeneous coordinates\n         * @private\n         */\n        normalizeUsrCoords: function () {\n            if (Math.abs(this.usrCoords[0]) > Mat.eps) {\n                this.usrCoords[1] /= this.usrCoords[0];\n                this.usrCoords[2] /= this.usrCoords[0];\n                this.usrCoords[0] = 1.0;\n            }\n        },\n\n        /**\n         * Compute screen coordinates out of given user coordinates.\n         * @private\n         */\n        usr2screen: function (doRound) {\n            var mround = Math.round, // Is faster on IE, maybe slower with JIT compilers\n                b = this.board,\n                uc = this.usrCoords,\n                oc = b.origin.scrCoords;\n\n            if (doRound === true) {\n                this.scrCoords[0] = mround(uc[0]);\n                this.scrCoords[1] = mround(uc[0] * oc[1] + uc[1] * b.unitX);\n                this.scrCoords[2] = mround(uc[0] * oc[2] - uc[2] * b.unitY);\n            } else {\n                this.scrCoords[0] = uc[0];\n                this.scrCoords[1] = uc[0] * oc[1] + uc[1] * b.unitX;\n                this.scrCoords[2] = uc[0] * oc[2] - uc[2] * b.unitY;\n            }\n        },\n\n        /**\n         * Compute user coordinates out of given screen coordinates.\n         * @private\n         */\n        screen2usr: function () {\n            var o = this.board.origin.scrCoords,\n                sc = this.scrCoords,\n                b = this.board;\n\n            this.usrCoords[0] = 1.0;\n            this.usrCoords[1] = (sc[1] - o[1]) / b.unitX;\n            this.usrCoords[2] = (o[2] - sc[2]) / b.unitY;\n        },\n\n        /**\n         * Calculate distance of one point to another.\n         * @param {Number} coord_type The type of coordinates used here. Possible values are <b>JXG.COORDS_BY_USER</b> and <b>JXG.COORDS_BY_SCREEN</b>.\n         * @param {JXG.Coords} coordinates The Coords object to which the distance is calculated.\n         * @returns {Number} The distance\n         */\n        distance: function (coord_type, coordinates) {\n            var sum = 0,\n                c,\n                ucr = this.usrCoords,\n                scr = this.scrCoords,\n                f;\n\n            if (coord_type === Const.COORDS_BY_USER) {\n                c = coordinates.usrCoords;\n                f = ucr[0] - c[0];\n                sum = f * f;\n\n                if (sum > Mat.eps * Mat.eps) {\n                    return Number.POSITIVE_INFINITY;\n                }\n                return Mat.hypot(ucr[1] - c[1], ucr[2] - c[2]);\n            } else {\n                c = coordinates.scrCoords;\n                return Mat.hypot(scr[1] - c[1], scr[2] - c[2]);\n            }\n        },\n\n        /**\n         * Set coordinates by either user coordinates or screen coordinates and recalculate the other one.\n         * @param {Number} coord_type The type of coordinates used here. Possible values are <b>COORDS_BY_USER</b> and <b>COORDS_BY_SCREEN</b>.\n         * @param {Array} coordinates An array of affine coordinates the Coords object is set to.\n         * @param {Boolean} [doRound=true] flag If true or null round the coordinates in usr2screen. This is used in smooth curve plotting.\n         * The IE needs rounded coordinates. Id doRound==false we have to round in updatePathString.\n         * @param {Boolean} [noevent=false]\n         * @returns {JXG.Coords} Reference to the coords object.\n         */\n        setCoordinates: function (coord_type, coordinates, doRound, noevent) {\n            var uc = this.usrCoords,\n                sc = this.scrCoords,\n                // Original values\n                ou = [uc[0], uc[1], uc[2]],\n                os = [sc[0], sc[1], sc[2]];\n\n            if (coord_type === Const.COORDS_BY_USER) {\n                if (coordinates.length === 2) {\n                    // Euclidean coordinates\n                    uc[0] = 1.0;\n                    uc[1] = coordinates[0];\n                    uc[2] = coordinates[1];\n                } else {\n                    // Homogeneous coordinates (normalized)\n                    uc[0] = coordinates[0];\n                    uc[1] = coordinates[1];\n                    uc[2] = coordinates[2];\n                    this.normalizeUsrCoords();\n                }\n                this.usr2screen(doRound);\n            } else {\n                if (coordinates.length === 2) {\n                    // Euclidean coordinates\n                    sc[1] = coordinates[0];\n                    sc[2] = coordinates[1];\n                } else {\n                    // Homogeneous coordinates (normalized)\n                    sc[1] = coordinates[1];\n                    sc[2] = coordinates[2];\n                }\n                this.screen2usr();\n            }\n\n            if (this.emitter && !noevent && (os[1] !== sc[1] || os[2] !== sc[2])) {\n                this.triggerEventHandlers([\"update\"], [ou, os]);\n            }\n\n            return this;\n        },\n\n        /**\n         * Copy array, either scrCoords or usrCoords\n         * Uses slice() in case of standard arrays and set() in case of\n         * typed arrays.\n         * @private\n         * @param {String} obj Either 'scrCoords' or 'usrCoords'\n         * @param {Number} offset Offset, defaults to 0 if not given\n         * @returns {Array} Returns copy of the coords array either as standard array or as\n         *   typed array.\n         */\n        copy: function (obj, offset) {\n            if (offset === undefined) {\n                offset = 0;\n            }\n\n            return this[obj].slice(offset);\n        },\n\n        /**\n         * Test if one of the usrCoords is NaN or the coordinates are infinite.\n         * @returns {Boolean} true if the coordinates are finite, false otherwise.\n         */\n        isReal: function () {\n            return (\n                !isNaN(this.usrCoords[1] + this.usrCoords[2]) &&\n                Math.abs(this.usrCoords[0]) > Mat.eps\n            );\n        },\n\n        /**\n         * Triggered whenever the coordinates change.\n         * @name JXG.Coords#update\n         * @param {Array} ou Old user coordinates\n         * @param {Array} os Old screen coordinates\n         * @event\n         */\n        __evt__update: function (ou, os) {},\n\n        /**\n         * @ignore\n         */\n        __evt: function () {}\n    }\n);\n\nexport default JXG.Coords;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}